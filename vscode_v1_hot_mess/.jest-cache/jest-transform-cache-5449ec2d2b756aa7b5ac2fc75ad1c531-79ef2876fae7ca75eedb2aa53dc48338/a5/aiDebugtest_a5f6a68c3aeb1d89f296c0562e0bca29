4cb19199549bc0d9d6fc402284e93d6a
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock VSCode API
jest.mock('vscode', () => ({
    workspace: {
        workspaceFolders: [{ uri: { fsPath: '/test/workspace' } }],
        getConfiguration: jest.fn(() => ({
            get: jest.fn(() => '.github/instructions/ai_utilities_context')
        }))
    },
    window: {
        createOutputChannel: jest.fn(() => ({
            appendLine: jest.fn(),
            show: jest.fn()
        }))
    }
}));
// Mock FileManager
jest.mock('../../utils/fileManager');
// Mock CommandRunner
jest.mock('../../utils/shellRunner');
// Mock child_process for spawn calls
jest.mock('child_process', () => ({
    spawn: jest.fn()
}));
const aiDebug_1 = require("../aiDebug");
const fileManager_1 = require("../../utils/fileManager");
const shellRunner_1 = require("../../utils/shellRunner");
const MockedFileManager = fileManager_1.FileManager;
const MockedCommandRunner = shellRunner_1.CommandRunner;
describe('AiDebugCommand', () => {
    let aiDebugCommand;
    let mockFileManager;
    let mockCommandRunner;
    let mockSpawn;
    beforeEach(() => {
        jest.clearAllMocks();
        // Setup FileManager mock
        mockFileManager = {
            initializeOutputFiles: jest.fn().mockResolvedValue({
                'ai-debug-context': '/test/ai-debug-context.txt',
                'pr-description-prompt': '/test/pr-description-prompt.txt',
                'diff': '/test/diff.txt',
                'jest-output': '/test/jest-output.txt'
            }),
            saveOutput: jest.fn().mockResolvedValue('/test/file.txt'),
            getFileContent: jest.fn().mockResolvedValue('test file content'),
            getFileStats: jest.fn().mockResolvedValue({
                size: 1024,
                created: new Date(),
                modified: new Date(),
                accessed: new Date()
            }),
            readFile: jest.fn(),
            writeFile: jest.fn().mockResolvedValue({ success: true, path: '/test/file.txt' }),
            ensureDirectoryExists: jest.fn(),
            deleteFile: jest.fn()
        };
        // Setup CommandRunner mock
        mockCommandRunner = {
            runGitDiff: jest.fn().mockResolvedValue({
                success: true,
                exitCode: 0,
                output: 'git diff output',
                duration: 1000
            }),
            runNxTest: jest.fn().mockResolvedValue({
                success: true,
                exitCode: 0,
                output: 'test output',
                duration: 5000
            })
        };
        MockedFileManager.mockImplementation(() => mockFileManager);
        MockedCommandRunner.mockImplementation(() => mockCommandRunner);
        // Setup spawn mock
        mockSpawn = require('child_process').spawn;
        const mockProcess = {
            stdout: { on: jest.fn() },
            stderr: { on: jest.fn() },
            on: jest.fn((event, callback) => {
                if (event === 'close') {
                    setTimeout(() => callback(0), 10); // Success
                }
            })
        };
        mockSpawn.mockReturnValue(mockProcess);
        aiDebugCommand = new aiDebug_1.AiDebugCommand();
    });
    describe('run', () => {
        it('should execute full aiDebug workflow when tests pass', async () => {
            // Arrange
            const project = 'test-project';
            const options = {
                quick: false,
                fullContext: false,
                noDiff: false,
                focus: 'tests'
            };
            // Command runner is already set up in beforeEach with successful responses
            // Act
            const result = await aiDebugCommand.run(project, options);
            // Assert
            expect(result.success).toBe(true);
            expect(result.exitCode).toBe(0);
            expect(mockCommandRunner.runGitDiff).toHaveBeenCalled();
            expect(mockCommandRunner.runNxTest).toHaveBeenCalledWith(project, expect.objectContaining({ fullOutput: false }));
            expect(mockFileManager.saveOutput).toHaveBeenCalled();
        });
        it('should skip git diff when noDiff option is true', async () => {
            // Arrange
            const project = 'test-project';
            const options = { noDiff: true };
            // Test runner already mocked with successful response
            // Act
            await aiDebugCommand.run(project, options);
            // Assert
            expect(mockCommandRunner.runGitDiff).not.toHaveBeenCalled();
        });
        it('should use fullContext when option is specified', async () => {
            // Arrange
            const project = 'test-project';
            const options = { fullContext: true };
            // Test already set up with successful mocks
            // Act
            await aiDebugCommand.run(project, options);
            // Assert
            expect(mockCommandRunner.runNxTest).toHaveBeenCalledWith(project, expect.objectContaining({ fullOutput: true }));
        });
        it('should run prepareToPush when tests pass', async () => {
            // Arrange
            const project = 'test-project';
            // Spawn is already mocked with successful responses
            // Act
            await aiDebugCommand.run(project);
            // Assert - The command should attempt to run lint and prettier
            expect(mockFileManager.saveOutput).toHaveBeenCalled();
        });
        it('should handle test failures gracefully', async () => {
            // Arrange
            const project = 'test-project';
            // Override the default successful mock for this test
            mockCommandRunner.runNxTest.mockResolvedValueOnce({
                success: false,
                exitCode: 1,
                output: 'test failed',
                error: 'Test failure message',
                duration: 5000
            });
            // Act
            const result = await aiDebugCommand.run(project);
            // Assert
            expect(result.success).toBe(false);
            expect(result.exitCode).toBe(1);
            expect(mockFileManager.saveOutput).toHaveBeenCalled(); // Should still create context file
        });
        it('should handle errors during execution', async () => {
            // Arrange
            const project = 'test-project';
            mockFileManager.initializeOutputFiles.mockRejectedValue(new Error('this.fileManager.initializeOutputFiles is not a function'));
            // Act
            const result = await aiDebugCommand.run(project);
            // Assert
            expect(result.success).toBe(false);
            expect(result.exitCode).toBe(1);
            expect(result.error).toBe('this.fileManager.initializeOutputFiles is not a function');
        });
        it('should generate PR description when tests pass', async () => {
            // Arrange
            const project = 'test-project';
            // Using default successful mocks
            // Act
            await aiDebugCommand.run(project);
            // Assert
            const saveOutputCalls = mockFileManager.saveOutput.mock.calls;
            const prDescriptionCall = saveOutputCalls.find(call => call[0] === 'pr-description-prompt');
            expect(prDescriptionCall).toBeDefined();
        });
        it('should include focus-specific guidance in context', async () => {
            // Arrange
            const project = 'test-project';
            const options = { focus: 'types' };
            // Using default successful mocks
            // Act
            await aiDebugCommand.run(project, options);
            // Assert
            const saveOutputCalls = mockFileManager.saveOutput.mock.calls;
            const contextCall = saveOutputCalls.find(call => call[0] === 'ai-debug-context');
            expect(contextCall).toBeDefined();
            expect(contextCall[1]).toContain('FOCUS AREA: TypeScript type issues');
        });
    });
    describe('createAiDebugContext', () => {
        it('should create context for passing tests', async () => {
            // Arrange
            const contextFile = '/test/context.txt';
            const project = 'test-project';
            mockFileManager.getFileContent.mockResolvedValue('test results');
            // Act
            await aiDebugCommand.createAiDebugContext(contextFile, '/test/diff.txt', '/test/jest.txt', project, 0, // exitCode: 0 (passing)
            'general', false, 0, // lintExitCode: 0 (passing)
            0 // prettierExitCode: 0 (passing)
            );
            // Assert
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('ai-debug-context', expect.stringContaining('STATUS: ✅ TESTS PASSING'));
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('ai-debug-context', expect.stringContaining('MOCK DATA VALIDATION (CRITICAL)'));
        });
        it('should create context for failing tests', async () => {
            // Arrange
            const contextFile = '/test/context.txt';
            const project = 'test-project';
            mockFileManager.getFileContent.mockResolvedValue('test failures');
            // Act
            await aiDebugCommand.createAiDebugContext(contextFile, '/test/diff.txt', '/test/jest.txt', project, 1, // exitCode: 1 (failing)
            'general', false, 0, // lintExitCode: 0 (passing)
            0 // prettierExitCode: 0 (passing)
            );
            // Assert
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('ai-debug-context', expect.stringContaining('STATUS: ❌ TESTS FAILING'));
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('ai-debug-context', expect.stringContaining('ROOT CAUSE ANALYSIS'));
        });
        it('should handle missing test file', async () => {
            // Arrange
            const contextFile = '/test/context.txt';
            const project = 'test-project';
            mockFileManager.getFileContent.mockRejectedValue(new Error('File not found'));
            // Act
            await aiDebugCommand.createAiDebugContext(contextFile, '/test/diff.txt', '/test/jest.txt', project, 0, 'general', false, 0, 0);
            // Assert
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('ai-debug-context', expect.stringContaining('❌ No test results available'));
        });
    });
    describe('createPrDescriptionPrompts', () => {
        it('should create PR description prompts', async () => {
            // Arrange
            const prFile = '/test/pr-description.txt';
            const project = 'test-project';
            // Act
            await aiDebugCommand.createPrDescriptionPrompts(prFile, '/test/diff.txt', '/test/jest.txt', project, 0, // exitCode: 0 (passing)
            0, // lintExitCode: 0 (passing)
            0 // prettierExitCode: 0 (passing)
            );
            // Assert
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('pr-description-prompt', expect.stringContaining('GITHUB PR DESCRIPTION GENERATION PROMPTS'));
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('pr-description-prompt', expect.stringContaining('TEST STATUS: ✅ All tests passing'));
        });
        it('should indicate failing tests in PR prompts', async () => {
            // Arrange
            const prFile = '/test/pr-description.txt';
            const project = 'test-project';
            // Act
            await aiDebugCommand.createPrDescriptionPrompts(prFile, '/test/diff.txt', '/test/jest.txt', project, 1, // exitCode: 1 (failing)
            0, // lintExitCode: 0 (passing)
            0 // prettierExitCode: 0 (passing)
            );
            // Assert
            expect(mockFileManager.saveOutput).toHaveBeenCalledWith('pr-description-prompt', expect.stringContaining('TEST STATUS: ❌ Some tests failing'));
        });
    });
    describe('countChangedFiles', () => {
        it('should count changed files from diff output', () => {
            // Arrange
            const diffOutput = `📁 FILE: file1.ts
Some diff content
📁 FILE: file2.ts
More diff content
📁 FILE: file3.spec.ts
Test diff content`;
            // Act
            const count = aiDebugCommand.countChangedFiles(diffOutput);
            // Assert
            expect(count).toBe(3);
        });
        it('should return 0 for empty diff output', () => {
            // Arrange
            const diffOutput = '';
            // Act
            const count = aiDebugCommand.countChangedFiles(diffOutput);
            // Assert
            expect(count).toBe(0);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy9jb21tYW5kcy9fX3Rlc3RzX18vYWlEZWJ1Zy50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBTUEsa0JBQWtCO0FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkIsU0FBUyxFQUFFO1FBQ1AsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxFQUFFLENBQUM7UUFDMUQsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzdCLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLDJDQUEyQyxDQUFDO1NBQ2xFLENBQUMsQ0FBQztLQUNOO0lBQ0QsTUFBTSxFQUFFO1FBQ0osbUJBQW1CLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ2hDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ2xCLENBQUMsQ0FBQztLQUNOO0NBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSixtQkFBbUI7QUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBR3JDLHFCQUFxQjtBQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFHckMscUNBQXFDO0FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDOUIsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7Q0FDbkIsQ0FBQyxDQUFDLENBQUM7QUFqQ0osd0NBQTRDO0FBRTVDLHlEQUFzRDtBQUN0RCx5REFBd0Q7QUFxQnhELE1BQU0saUJBQWlCLEdBQUcseUJB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RUFDUCxDQUFDLEVBQUUsd0JBQXdCO1lBQzNCLENBQUMsRUFBRSw0QkFBNEI7WUFDL0IsQ0FBQyxDQUFFLGdDQUFnQzthQUN0QyxDQUFDO1lBRUYsU0FBUztZQUNULE1BQU0sQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUMsb0JBQW9CLENBQ25ELHVCQUF1QixFQUN2QixNQUFNLENBQUMsZ0JBQWdCLENBQUMsbUNBQW1DLENBQUMsQ0FDL0QsQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFO1FBQy9CLEVBQUUsQ0FBQyw2Q0FBNkMsRUFBRSxHQUFHLEVBQUU7WUFDbkQsVUFBVTtZQUNWLE1BQU0sVUFBVSxHQUFHOzs7OztrQkFLYixDQUFDO1lBRVAsTUFBTTtZQUNOLE1BQU0sS0FBSyxHQUFJLGNBQXNCLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFcEUsU0FBUztZQUNULE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsdUNBQXVDLEVBQUUsR0FBRyxFQUFFO1lBQzdDLFVBQVU7WUFDVixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7WUFFdEIsTUFBTTtZQUNOLE1BQU0sS0FBSyxHQUFJLGNBQXNCLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFcEUsU0FBUztZQUNULE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ncmVnZHVubi9zcmMvdGVzdC9haV9kZWJ1Z19jb250ZXh0L3ZzY29kZS9zcmMvY29tbWFuZHMvX190ZXN0c19fL2FpRGVidWcudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBaURlYnVnQ29tbWFuZCB9IGZyb20gJy4uL2FpRGVidWcnO1xuaW1wb3J0IHsgQ29tbWFuZE9wdGlvbnMgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBGaWxlTWFuYWdlciB9IGZyb20gJy4uLy4uL3V0aWxzL2ZpbGVNYW5hZ2VyJztcbmltcG9ydCB7IENvbW1hbmRSdW5uZXIgfSBmcm9tICcuLi8uLi91dGlscy9zaGVsbFJ1bm5lcic7XG5pbXBvcnQgKiBhcyB2c2NvZGUgZnJvbSAndnNjb2RlJztcblxuLy8gTW9jayBWU0NvZGUgQVBJXG5qZXN0Lm1vY2soJ3ZzY29kZScsICgpID0+ICh7XG4gICAgd29ya3NwYWNlOiB7XG4gICAgICAgIHdvcmtzcGFjZUZvbGRlcnM6IFt7IHVyaTogeyBmc1BhdGg6ICcvdGVzdC93b3Jrc3BhY2UnIH0gfV0sXG4gICAgICAgIGdldENvbmZpZ3VyYXRpb246IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIGdldDogamVzdC5mbigoKSA9PiAnLmdpdGh1Yi9pbnN0cnVjdGlvbnMvYWlfdXRpbGl0aWVzX2NvbnRleHQnKVxuICAgICAgICB9KSlcbiAgICB9LFxuICAgIHdpbmRvdzoge1xuICAgICAgICBjcmVhdGVPdXRwdXRDaGFubmVsOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBhcHBlbmRMaW5lOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBzaG93OiBqZXN0LmZuKClcbiAgICAgICAgfSkpXG4gICAgfVxufSkpO1xuXG4vLyBNb2NrIEZpbGVNYW5hZ2VyXG5qZXN0Lm1vY2soJy4uLy4uL3V0aWxzL2ZpbGVNYW5hZ2VyJyk7XG5jb25zdCBNb2NrZWRGaWxlTWFuYWdlciA9IEZpbGVNYW5hZ2VyIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIEZpbGVNYW5hZ2VyPjtcblxuLy8gTW9jayBDb21tYW5kUnVubmVyXG5qZXN0Lm1vY2soJy4uLy4uL3V0aWxzL3NoZWxsUnVubmVyJyk7XG5jb25zdCBNb2NrZWRDb21tYW5kUnVubmVyID0gQ29tbWFuZFJ1bm5lciBhcyBqZXN0Lk1vY2tlZENsYXNzPHR5cGVvZiBDb21tYW5kUnVubmVyPjtcblxuLy8gTW9jayBjaGlsZF9wcm9jZXNzIGZvciBzcGF3biBjYWxsc1xuamVzdC5tb2NrKCdjaGlsZF9wcm9jZXNzJywgKCkgPT4gKHtcbiAgICBzcGF3bjogamVzdC5mbigpXG59KSk7XG5cbmRlc2NyaWJlKCdBaURlYnVnQ29tbWFuZCcsICgpID0+IHtcbiAgICBsZXQgYWlEZWJ1Z0NvbW1hbmQ6IEFpRGVidWdDb21tYW5kO1xuICAgIGxldCBtb2NrRmlsZU1hbmFnZXI6IGplc3QuTW9ja2VkPEZpbGVNYW5hZ2VyPjtcbiAgICBsZXQgbW9ja0NvbW1hbmRSdW5uZXI6IGplc3QuTW9ja2VkPENvbW1hbmRSdW5uZXI+O1xuICAgIGxldCBtb2NrU3Bhd246IGplc3QuTW9ja2VkRnVuY3Rpb248YW55PjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldHVwIEZpbGVNYW5hZ2VyIG1vY2tcbiAgICAgICAgbW9ja0ZpbGVNYW5hZ2VyID0ge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZU91dHB1dEZpbGVzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICdhaS1kZWJ1Zy1jb250ZXh0JzogJy90ZXN0L2FpLWRlYnVnLWNvbnRleHQudHh0JyxcbiAgICAgICAgICAgICAgICAncHItZGVzY3JpcHRpb24tcHJvbXB0JzogJy90ZXN0L3ByLWRlc2NyaXB0aW9uLXByb21wdC50eHQnLFxuICAgICAgICAgICAgICAgICdkaWZmJzogJy90ZXN0L2RpZmYudHh0JyxcbiAgICAgICAgICAgICAgICAnamVzdC1vdXRwdXQnOiAnL3Rlc3QvamVzdC1vdXRwdXQudHh0J1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzYXZlT3V0cHV0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoJy90ZXN0L2ZpbGUudHh0JyksXG4gICAgICAgICAgICBnZXRGaWxlQ29udGVudDogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKCd0ZXN0IGZpbGUgY29udGVudCcpLFxuICAgICAgICAgICAgZ2V0RmlsZVN0YXRzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgIHNpemU6IDEwMjQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NlZDogbmV3IERhdGUoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZWFkRmlsZTogamVzdC5mbigpLFxuICAgICAgICAgICAgd3JpdGVGaWxlOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBwYXRoOiAnL3Rlc3QvZmlsZS50eHQnIH0pLFxuICAgICAgICAgICAgZW5zdXJlRGlyZWN0b3J5RXhpc3RzOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBkZWxldGVGaWxlOiBqZXN0LmZuKClcbiAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgLy8gU2V0dXAgQ29tbWFuZFJ1bm5lciBtb2NrXG4gICAgICAgIG1vY2tDb21tYW5kUnVubmVyID0ge1xuICAgICAgICAgICAgcnVuR2l0RGlmZjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlOiAwLFxuICAgICAgICAgICAgICAgIG91dHB1dDogJ2dpdCBkaWZmIG91dHB1dCcsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMDBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcnVuTnhUZXN0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiAndGVzdCBvdXRwdXQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGFzIGFueTtcblxuICAgICAgICBNb2NrZWRGaWxlTWFuYWdlci5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0ZpbGVNYW5hZ2VyKTtcbiAgICAgICAgTW9ja2VkQ29tbWFuZFJ1bm5lci5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0NvbW1hbmRSdW5uZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgc3Bhd24gbW9ja1xuICAgICAgICBtb2NrU3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG4gICAgICAgIGNvbnN0IG1vY2tQcm9jZXNzID0ge1xuICAgICAgICAgICAgc3Rkb3V0OiB7IG9uOiBqZXN0LmZuKCkgfSxcbiAgICAgICAgICAgIHN0ZGVycjogeyBvbjogamVzdC5mbigpIH0sXG4gICAgICAgICAgICBvbjogamVzdC5mbigoZXZlbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50ID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soMCksIDEwKTsgLy8gU3VjY2Vzc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICAgIG1vY2tTcGF3bi5tb2NrUmV0dXJuVmFsdWUobW9ja1Byb2Nlc3MpO1xuICAgICAgICBcbiAgICAgICAgYWlEZWJ1Z0NvbW1hbmQgPSBuZXcgQWlEZWJ1Z0NvbW1hbmQoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdydW4nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgZXhlY3V0ZSBmdWxsIGFpRGVidWcgd29ya2Zsb3cgd2hlbiB0ZXN0cyBwYXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogQ29tbWFuZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcXVpY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZ1bGxDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBub0RpZmY6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvY3VzOiAndGVzdHMnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDb21tYW5kIHJ1bm5lciBpcyBhbHJlYWR5IHNldCB1cCBpbiBiZWZvcmVFYWNoIHdpdGggc3VjY2Vzc2Z1bCByZXNwb25zZXNcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhaURlYnVnQ29tbWFuZC5ydW4ocHJvamVjdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5leGl0Q29kZSkudG9CZSgwKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrQ29tbWFuZFJ1bm5lci5ydW5HaXREaWZmKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0NvbW1hbmRSdW5uZXIucnVuTnhUZXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwcm9qZWN0LCBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IGZ1bGxPdXRwdXQ6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHNraXAgZ2l0IGRpZmYgd2hlbiBub0RpZmYgb3B0aW9uIGlzIHRydWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBDb21tYW5kT3B0aW9ucyA9IHsgbm9EaWZmOiB0cnVlIH07XG5cbiAgICAgICAgICAgIC8vIFRlc3QgcnVubmVyIGFscmVhZHkgbW9ja2VkIHdpdGggc3VjY2Vzc2Z1bCByZXNwb25zZVxuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGF3YWl0IGFpRGVidWdDb21tYW5kLnJ1bihwcm9qZWN0LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QobW9ja0NvbW1hbmRSdW5uZXIucnVuR2l0RGlmZikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCB1c2UgZnVsbENvbnRleHQgd2hlbiBvcHRpb24gaXMgc3BlY2lmaWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogQ29tbWFuZE9wdGlvbnMgPSB7IGZ1bGxDb250ZXh0OiB0cnVlIH07XG5cbiAgICAgICAgICAgIC8vIFRlc3QgYWxyZWFkeSBzZXQgdXAgd2l0aCBzdWNjZXNzZnVsIG1vY2tzXG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgYXdhaXQgYWlEZWJ1Z0NvbW1hbmQucnVuKHByb2plY3QsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChtb2NrQ29tbWFuZFJ1bm5lci5ydW5OeFRlc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHByb2plY3QsIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgZnVsbE91dHB1dDogdHJ1ZSB9KSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcnVuIHByZXBhcmVUb1B1c2ggd2hlbiB0ZXN0cyBwYXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTcGF3biBpcyBhbHJlYWR5IG1vY2tlZCB3aXRoIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzXG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgYXdhaXQgYWlEZWJ1Z0NvbW1hbmQucnVuKHByb2plY3QpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnQgLSBUaGUgY29tbWFuZCBzaG91bGQgYXR0ZW1wdCB0byBydW4gbGludCBhbmQgcHJldHRpZXJcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSB0ZXN0IGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHN1Y2Nlc3NmdWwgbW9jayBmb3IgdGhpcyB0ZXN0XG4gICAgICAgICAgICBtb2NrQ29tbWFuZFJ1bm5lci5ydW5OeFRlc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICd0ZXN0IGZhaWxlZCcsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdUZXN0IGZhaWx1cmUgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDUwMDBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFpRGVidWdDb21tYW5kLnJ1bihwcm9qZWN0KTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5leGl0Q29kZSkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9IYXZlQmVlbkNhbGxlZCgpOyAvLyBTaG91bGQgc3RpbGwgY3JlYXRlIGNvbnRleHQgZmlsZVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZHVyaW5nIGV4ZWN1dGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSAndGVzdC1wcm9qZWN0JztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja0ZpbGVNYW5hZ2VyLmluaXRpYWxpemVPdXRwdXRGaWxlcy5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ3RoaXMuZmlsZU1hbmFnZXIuaW5pdGlhbGl6ZU91dHB1dEZpbGVzIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFpRGVidWdDb21tYW5kLnJ1bihwcm9qZWN0KTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5leGl0Q29kZSkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ3RoaXMuZmlsZU1hbmFnZXIuaW5pdGlhbGl6ZU91dHB1dEZpbGVzIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgUFIgZGVzY3JpcHRpb24gd2hlbiB0ZXN0cyBwYXNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBVc2luZyBkZWZhdWx0IHN1Y2Nlc3NmdWwgbW9ja3NcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBhd2FpdCBhaURlYnVnQ29tbWFuZC5ydW4ocHJvamVjdCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgY29uc3Qgc2F2ZU91dHB1dENhbGxzID0gbW9ja0ZpbGVNYW5hZ2VyLnNhdmVPdXRwdXQubW9jay5jYWxscztcbiAgICAgICAgICAgIGNvbnN0IHByRGVzY3JpcHRpb25DYWxsID0gc2F2ZU91dHB1dENhbGxzLmZpbmQoY2FsbCA9PiBcbiAgICAgICAgICAgICAgICBjYWxsWzBdID09PSAncHItZGVzY3JpcHRpb24tcHJvbXB0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChwckRlc2NyaXB0aW9uQ2FsbCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBpbmNsdWRlIGZvY3VzLXNwZWNpZmljIGd1aWRhbmNlIGluIGNvbnRleHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBDb21tYW5kT3B0aW9ucyA9IHsgZm9jdXM6ICd0eXBlcycgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXNpbmcgZGVmYXVsdCBzdWNjZXNzZnVsIG1vY2tzXG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgYXdhaXQgYWlEZWJ1Z0NvbW1hbmQucnVuKHByb2plY3QsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGNvbnN0IHNhdmVPdXRwdXRDYWxscyA9IG1vY2tGaWxlTWFuYWdlci5zYXZlT3V0cHV0Lm1vY2suY2FsbHM7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0Q2FsbCA9IHNhdmVPdXRwdXRDYWxscy5maW5kKGNhbGwgPT4gXG4gICAgICAgICAgICAgICAgY2FsbFswXSA9PT0gJ2FpLWRlYnVnLWNvbnRleHQnXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRleHRDYWxsKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRleHRDYWxsIVsxXSkudG9Db250YWluKCdGT0NVUyBBUkVBOiBUeXBlU2NyaXB0IHR5cGUgaXNzdWVzJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NyZWF0ZUFpRGVidWdDb250ZXh0JywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBjb250ZXh0IGZvciBwYXNzaW5nIHRlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgY29udGV4dEZpbGUgPSAnL3Rlc3QvY29udGV4dC50eHQnO1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrRmlsZU1hbmFnZXIuZ2V0RmlsZUNvbnRlbnQubW9ja1Jlc29sdmVkVmFsdWUoJ3Rlc3QgcmVzdWx0cycpO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGF3YWl0IChhaURlYnVnQ29tbWFuZCBhcyBhbnkpLmNyZWF0ZUFpRGVidWdDb250ZXh0KFxuICAgICAgICAgICAgICAgIGNvbnRleHRGaWxlLFxuICAgICAgICAgICAgICAgICcvdGVzdC9kaWZmLnR4dCcsXG4gICAgICAgICAgICAgICAgJy90ZXN0L2plc3QudHh0JyxcbiAgICAgICAgICAgICAgICBwcm9qZWN0LFxuICAgICAgICAgICAgICAgIDAsIC8vIGV4aXRDb2RlOiAwIChwYXNzaW5nKVxuICAgICAgICAgICAgICAgICdnZW5lcmFsJyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAwLCAvLyBsaW50RXhpdENvZGU6IDAgKHBhc3NpbmcpXG4gICAgICAgICAgICAgICAgMCAgLy8gcHJldHRpZXJFeGl0Q29kZTogMCAocGFzc2luZylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KG1vY2tGaWxlTWFuYWdlci5zYXZlT3V0cHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICAnYWktZGVidWctY29udGV4dCcsXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1NUQVRVUzog4pyFIFRFU1RTIFBBU1NJTkcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAgICAgJ2FpLWRlYnVnLWNvbnRleHQnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdNT0NLIERBVEEgVkFMSURBVElPTiAoQ1JJVElDQUwpJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGNvbnRleHQgZm9yIGZhaWxpbmcgdGVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0RmlsZSA9ICcvdGVzdC9jb250ZXh0LnR4dCc7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tGaWxlTWFuYWdlci5nZXRGaWxlQ29udGVudC5tb2NrUmVzb2x2ZWRWYWx1ZSgndGVzdCBmYWlsdXJlcycpO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGF3YWl0IChhaURlYnVnQ29tbWFuZCBhcyBhbnkpLmNyZWF0ZUFpRGVidWdDb250ZXh0KFxuICAgICAgICAgICAgICAgIGNvbnRleHRGaWxlLFxuICAgICAgICAgICAgICAgICcvdGVzdC9kaWZmLnR4dCcsXG4gICAgICAgICAgICAgICAgJy90ZXN0L2plc3QudHh0JyxcbiAgICAgICAgICAgICAgICBwcm9qZWN0LFxuICAgICAgICAgICAgICAgIDEsIC8vIGV4aXRDb2RlOiAxIChmYWlsaW5nKVxuICAgICAgICAgICAgICAgICdnZW5lcmFsJyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAwLCAvLyBsaW50RXhpdENvZGU6IDAgKHBhc3NpbmcpXG4gICAgICAgICAgICAgICAgMCAgLy8gcHJldHRpZXJFeGl0Q29kZTogMCAocGFzc2luZylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KG1vY2tGaWxlTWFuYWdlci5zYXZlT3V0cHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICAnYWktZGVidWctY29udGV4dCcsXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1NUQVRVUzog4p2MIFRFU1RTIEZBSUxJTkcnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAgICAgJ2FpLWRlYnVnLWNvbnRleHQnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdST09UIENBVVNFIEFOQUxZU0lTJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG1pc3NpbmcgdGVzdCBmaWxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgY29udGV4dEZpbGUgPSAnL3Rlc3QvY29udGV4dC50eHQnO1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9ICd0ZXN0LXByb2plY3QnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrRmlsZU1hbmFnZXIuZ2V0RmlsZUNvbnRlbnQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCcpKTtcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBhd2FpdCAoYWlEZWJ1Z0NvbW1hbmQgYXMgYW55KS5jcmVhdGVBaURlYnVnQ29udGV4dChcbiAgICAgICAgICAgICAgICBjb250ZXh0RmlsZSxcbiAgICAgICAgICAgICAgICAnL3Rlc3QvZGlmZi50eHQnLFxuICAgICAgICAgICAgICAgICcvdGVzdC9qZXN0LnR4dCcsXG4gICAgICAgICAgICAgICAgcHJvamVjdCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICdnZW5lcmFsJyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KG1vY2tGaWxlTWFuYWdlci5zYXZlT3V0cHV0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICAnYWktZGVidWctY29udGV4dCcsXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ+KdjCBObyB0ZXN0IHJlc3VsdHMgYXZhaWxhYmxlJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NyZWF0ZVByRGVzY3JpcHRpb25Qcm9tcHRzJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBQUiBkZXNjcmlwdGlvbiBwcm9tcHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJGaWxlID0gJy90ZXN0L3ByLWRlc2NyaXB0aW9uLnR4dCc7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgYXdhaXQgKGFpRGVidWdDb21tYW5kIGFzIGFueSkuY3JlYXRlUHJEZXNjcmlwdGlvblByb21wdHMoXG4gICAgICAgICAgICAgICAgcHJGaWxlLFxuICAgICAgICAgICAgICAgICcvdGVzdC9kaWZmLnR4dCcsXG4gICAgICAgICAgICAgICAgJy90ZXN0L2plc3QudHh0JyxcbiAgICAgICAgICAgICAgICBwcm9qZWN0LFxuICAgICAgICAgICAgICAgIDAsIC8vIGV4aXRDb2RlOiAwIChwYXNzaW5nKVxuICAgICAgICAgICAgICAgIDAsIC8vIGxpbnRFeGl0Q29kZTogMCAocGFzc2luZylcbiAgICAgICAgICAgICAgICAwICAvLyBwcmV0dGllckV4aXRDb2RlOiAwIChwYXNzaW5nKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZpbGVNYW5hZ2VyLnNhdmVPdXRwdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICdwci1kZXNjcmlwdGlvbi1wcm9tcHQnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdHSVRIVUIgUFIgREVTQ1JJUFRJT04gR0VORVJBVElPTiBQUk9NUFRTJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZpbGVNYW5hZ2VyLnNhdmVPdXRwdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICdwci1kZXNjcmlwdGlvbi1wcm9tcHQnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdURVNUIFNUQVRVUzog4pyFIEFsbCB0ZXN0cyBwYXNzaW5nJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaW5kaWNhdGUgZmFpbGluZyB0ZXN0cyBpbiBQUiBwcm9tcHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgcHJGaWxlID0gJy90ZXN0L3ByLWRlc2NyaXB0aW9uLnR4dCc7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gJ3Rlc3QtcHJvamVjdCc7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgYXdhaXQgKGFpRGVidWdDb21tYW5kIGFzIGFueSkuY3JlYXRlUHJEZXNjcmlwdGlvblByb21wdHMoXG4gICAgICAgICAgICAgICAgcHJGaWxlLFxuICAgICAgICAgICAgICAgICcvdGVzdC9kaWZmLnR4dCcsXG4gICAgICAgICAgICAgICAgJy90ZXN0L2plc3QudHh0JyxcbiAgICAgICAgICAgICAgICBwcm9qZWN0LFxuICAgICAgICAgICAgICAgIDEsIC8vIGV4aXRDb2RlOiAxIChmYWlsaW5nKVxuICAgICAgICAgICAgICAgIDAsIC8vIGxpbnRFeGl0Q29kZTogMCAocGFzc2luZylcbiAgICAgICAgICAgICAgICAwICAvLyBwcmV0dGllckV4aXRDb2RlOiAwIChwYXNzaW5nKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QobW9ja0ZpbGVNYW5hZ2VyLnNhdmVPdXRwdXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICdwci1kZXNjcmlwdGlvbi1wcm9tcHQnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdURVNUIFNUQVRVUzog4p2MIFNvbWUgdGVzdHMgZmFpbGluZycpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdjb3VudENoYW5nZWRGaWxlcycsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBjb3VudCBjaGFuZ2VkIGZpbGVzIGZyb20gZGlmZiBvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBkaWZmT3V0cHV0ID0gYPCfk4EgRklMRTogZmlsZTEudHNcblNvbWUgZGlmZiBjb250ZW50XG7wn5OBIEZJTEU6IGZpbGUyLnRzXG5Nb3JlIGRpZmYgY29udGVudFxu8J+TgSBGSUxFOiBmaWxlMy5zcGVjLnRzXG5UZXN0IGRpZmYgY29udGVudGA7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgY291bnQgPSAoYWlEZWJ1Z0NvbW1hbmQgYXMgYW55KS5jb3VudENoYW5nZWRGaWxlcyhkaWZmT3V0cHV0KTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QoY291bnQpLnRvQmUoMyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDAgZm9yIGVtcHR5IGRpZmYgb3V0cHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3QgZGlmZk91dHB1dCA9ICcnO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gKGFpRGVidWdDb21tYW5kIGFzIGFueSkuY291bnRDaGFuZ2VkRmlsZXMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KGNvdW50KS50b0JlKDApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuIl0sInZlcnNpb24iOjN9