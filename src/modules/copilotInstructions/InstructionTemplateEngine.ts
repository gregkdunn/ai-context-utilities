/**
 * Instruction Template Engine
 * Generates Copilot instruction files from templates
 */

import * as path from 'path';
import { WorkspaceAnalysis } from '../../utils/WorkspaceAnalyzer';
import { FrameworkTemplates } from './templates/FrameworkTemplates';

export class InstructionTemplateEngine {
    private templates: FrameworkTemplates;
    
    constructor(private workspaceRoot: string) {
        this.templates = new FrameworkTemplates();
    }
    
    /**
     * Generate main copilot-instructions.md file
     */
    async generateMainInstructions(workspace: WorkspaceAnalysis): Promise<string> {
        const workspaceName = path.basename(this.workspaceRoot);
        const timestamp = new Date().toISOString();
        const version = '3.5.0'; // Extension version
        
        // Build technology stack description
        const techStack = this.buildTechStackDescription(workspace);
        
        // Build framework links
        const frameworkLinks = this.buildFrameworkLinks(workspace);
        
        const template = `# Copilot Instructions for ${workspaceName}

<!-- Generated by AI Context Utilities Extension v${version} -->
<!-- Last Updated: ${timestamp} -->

## Overview
This repository uses ${this.getMainFrameworks(workspace)} with ${this.getTestFrameworks(workspace)}.

## AI Context Utilities
These files are automatically generated by the AI Context Utilities extension to provide real-time context for debugging and understanding code changes:

- **[Debugging Context](./ai-utilities-context/ai-debug-context.txt)** - Consolidated git diff and test run data optimized for AI analysis
- **[Git Diff Data](./ai-utilities-context/diff.txt)** - Current uncommitted changes in the repository  
- **[Test Output](./ai-utilities-context/test-output.txt)** - Latest test execution results and failures
- **[PR Description](./ai-utilities-context/pr-description.txt)** - AI-ready context for generating pull request descriptions

These files are updated automatically when you run tests or prepare commits using the AI Context Utilities commands.

## Technology Stack
${techStack}

## Framework-Specific Guidelines
${frameworkLinks}

## Code Style Guidelines
- Follow existing code patterns and conventions
- Use TypeScript strict mode where applicable
- Prefer functional programming patterns
- Write comprehensive tests for all new features
- Use meaningful variable and function names
- Keep functions small and focused

## Testing Guidelines
- Write tests before implementing features (TDD)
- Aim for high code coverage (>80%)
- Test edge cases and error conditions
- Use descriptive test names that explain the behavior
- Mock external dependencies appropriately

## Project Conventions
<!-- User customization section - preserved during updates -->
<!-- Add your project-specific conventions below -->

## Performance Considerations
- Optimize for readability first, performance second
- Use lazy loading for large modules
- Implement proper error boundaries
- Cache expensive computations when appropriate

## Security Guidelines
- Never commit sensitive data or credentials
- Validate all user inputs
- Use parameterized queries for database operations
- Keep dependencies up to date
- Follow OWASP security best practices

---
*To update these instructions, use Command Palette > "Add Copilot Instruction Contexts"*
*To restore a previous version, use the backup/restore options in the command*`;

        return template;
    }
    
    /**
     * Generate framework-specific instruction file
     */
    async generateFrameworkInstructions(
        framework: string,
        workspace: WorkspaceAnalysis
    ): Promise<string | null> {
        const template = this.templates.getTemplate(framework);
        if (!template) {
            return null;
        }
        
        // Replace placeholders in template
        let content = template;
        
        // Replace version placeholder
        const frameworkInfo = this.findFrameworkInfo(framework, workspace);
        if (frameworkInfo && frameworkInfo.version) {
            content = content.replace(/\{\{version\}\}/g, frameworkInfo.version);
        }
        
        // Replace test framework placeholder
        const testFramework = this.getTestFrameworks(workspace);
        content = content.replace(/\{\{testFramework\}\}/g, testFramework);
        
        return content;
    }
    
    /**
     * Build technology stack description
     */
    private buildTechStackDescription(workspace: WorkspaceAnalysis): string {
        const items: string[] = [];
        
        // Language
        if (workspace.typescript.version) {
            items.push(`- **Language**: TypeScript ${workspace.typescript.version}${workspace.typescript.hasConfig ? ' (configured)' : ''}`);
        } else if (workspace.typescript.hasConfig) {
            items.push('- **Language**: TypeScript (configured)');
        } else {
            items.push('- **Language**: JavaScript');
        }
        
        // Frontend frameworks
        if (workspace.frontendFrameworks.length > 0) {
            items.push(`- **Frontend**: ${workspace.frontendFrameworks.join(', ')}`);
        }
        
        // Testing frameworks
        if (workspace.testFrameworks.length > 0) {
            items.push(`- **Testing**: ${workspace.testFrameworks.join(', ')}`);
        }
        
        // Build tools
        if (workspace.buildTools.length > 0) {
            items.push(`- **Build**: ${workspace.buildTools.join(', ')}`);
        }
        
        // Package manager
        if (workspace.packageManager !== 'unknown') {
            items.push(`- **Package Manager**: ${workspace.packageManager}`);
        }
        
        return items.join('\n');
    }
    
    /**
     * Build framework-specific guideline links
     */
    private buildFrameworkLinks(workspace: WorkspaceAnalysis): string {
        const links: string[] = [];
        
        // Add Angular link if detected
        if (workspace.frontendFrameworks.some(f => f.toLowerCase().includes('angular'))) {
            links.push('- [Angular Best Practices](./angular/angular-best-practices.md)');
            links.push('- [Angular LLM Documentation](./angular/llms-full.txt)');
        }
        
        // Add React link if detected
        if (workspace.frontendFrameworks.some(f => f.toLowerCase().includes('react'))) {
            links.push('- [React Best Practices](./react/react-best-practices.md)');
        }
        
        // Add Vue link if detected
        if (workspace.frontendFrameworks.some(f => f.toLowerCase().includes('vue'))) {
            links.push('- [Vue Best Practices](./vue/vue-best-practices.md)');
        }
        
        // Add TypeScript link if detected
        if (workspace.typescript.version || workspace.typescript.hasConfig) {
            links.push('- [TypeScript Guidelines](./typescript/typescript-best-practices.md)');
        }
        
        // Add test framework links
        if (workspace.testFrameworks.some(f => f.toLowerCase().includes('jest'))) {
            links.push('- [Jest Testing Patterns](./jest/jest-best-practices.md)');
        }
        
        if (workspace.testFrameworks.some(f => f.toLowerCase().includes('vitest'))) {
            links.push('- [Vitest Testing Patterns](./vitest/vitest-best-practices.md)');
        }
        
        return links.length > 0 
            ? links.join('\n') 
            : '<!-- No framework-specific guidelines detected -->';
    }
    
    /**
     * Get main frameworks description
     */
    private getMainFrameworks(workspace: WorkspaceAnalysis): string {
        if (workspace.frontendFrameworks.length === 0) {
            return workspace.typescript.version ? 'TypeScript' : 'JavaScript';
        }
        
        const mainFrameworks = workspace.frontendFrameworks
            .map(f => f.split(' ')[0])
            .join(' and ');
            
        return mainFrameworks;
    }
    
    /**
     * Get test frameworks description
     */
    private getTestFrameworks(workspace: WorkspaceAnalysis): string {
        if (workspace.testFrameworks.length === 0) {
            return 'no test framework detected';
        }
        
        return workspace.testFrameworks
            .map(f => f.split(' ')[0])
            .join(' and ');
    }
    
    /**
     * Find framework info in workspace analysis
     */
    private findFrameworkInfo(
        framework: string, 
        workspace: WorkspaceAnalysis
    ): { version: string | null } | null {
        // Check frontend frameworks
        const frontend = workspace.frontendFrameworks.find(
            f => f.toLowerCase().includes(framework.toLowerCase())
        );
        
        if (frontend) {
            const versionMatch = frontend.match(/(\d+\.\d+)/);
            return { version: versionMatch ? versionMatch[1] : null };
        }
        
        // Check test frameworks
        const test = workspace.testFrameworks.find(
            f => f.toLowerCase().includes(framework.toLowerCase())
        );
        
        if (test) {
            const versionMatch = test.match(/(\d+\.\d+)/);
            return { version: versionMatch ? versionMatch[1] : null };
        }
        
        // Check TypeScript
        if (framework.toLowerCase() === 'typescript') {
            return { version: workspace.typescript.version };
        }
        
        return null;
    }
}