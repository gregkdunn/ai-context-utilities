import { StatusTracker, CommandStatus, StatusHistory } from '../statusTracker';\nimport * as vscode from 'vscode';\n\n// Mock VSCode API\njest.mock('vscode', () => ({\n    window: {\n        createStatusBarItem: jest.fn(() => ({\n            text: '',\n            tooltip: '',\n            command: '',\n            show: jest.fn(),\n            dispose: jest.fn()\n        })),\n        showInformationMessage: jest.fn(),\n        showErrorMessage: jest.fn()\n    },\n    StatusBarAlignment: {\n        Left: 1\n    },\n    workspace: {\n        getConfiguration: jest.fn(() => ({\n            get: jest.fn((key: string, defaultValue?: any) => {\n                if (key === 'showNotifications') return true;\n                return defaultValue;\n            })\n        }))\n    }\n}));\n\ndescribe('StatusTracker', () => {\n    let statusTracker: StatusTracker;\n    let mockContext: vscode.ExtensionContext;\n\n    beforeEach(() => {\n        mockContext = {\n            subscriptions: [],\n            globalState: {\n                get: jest.fn().mockReturnValue([]),\n                update: jest.fn()\n            }\n        } as any;\n\n        statusTracker = new StatusTracker(mockContext);\n    });\n\n    afterEach(() => {\n        statusTracker.dispose();\n    });\n\n    describe('Command Lifecycle', () => {\n        test('should start tracking a command', () => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project', { quick: true });\n            \n            expect(commandId).toBeDefined();\n            expect(commandId).toContain('aiDebug');\n            expect(commandId).toContain('test-project');\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status).toBeDefined();\n            expect(status!.command).toBe('aiDebug');\n            expect(status!.project).toBe('test-project');\n            expect(status!.status).toBe('running');\n            expect(status!.progress).toBe(0);\n        });\n\n        test('should update command progress', () => {\n            const commandId = statusTracker.startCommand('nxTest', 'test-project');\n            \n            statusTracker.updateProgress(commandId, 50, 'Running tests...');\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.progress).toBe(50);\n            expect(status!.message).toBe('Running tests...');\n        });\n\n        test('should clamp progress values', () => {\n            const commandId = statusTracker.startCommand('gitDiff');\n            \n            statusTracker.updateProgress(commandId, -10);\n            expect(statusTracker.getStatus(commandId)!.progress).toBe(0);\n            \n            statusTracker.updateProgress(commandId, 150);\n            expect(statusTracker.getStatus(commandId)!.progress).toBe(100);\n        });\n\n        test('should update command status', () => {\n            const commandId = statusTracker.startCommand('prepareToPush', 'test-project');\n            \n            statusTracker.updateStatus(commandId, 'success', 'Completed successfully');\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.status).toBe('success');\n            expect(status!.message).toBe('Completed successfully');\n            expect(status!.endTime).toBeDefined();\n            expect(status!.duration).toBeDefined();\n        });\n\n        test('should complete a command with result', () => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project');\n            \n            const result = {\n                success: true,\n                exitCode: 0,\n                output: 'Test output',\n                duration: 5000,\n                outputFiles: ['file1.txt', 'file2.txt']\n            };\n            \n            statusTracker.completeCommand(commandId, result);\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.status).toBe('success');\n            expect(status!.progress).toBe(100);\n            expect(status!.output).toBe('Test output');\n            expect(status!.outputFiles).toEqual(['file1.txt', 'file2.txt']);\n            expect(status!.duration).toBe(5000);\n        });\n\n        test('should cancel a running command', () => {\n            const commandId = statusTracker.startCommand('nxTest', 'test-project');\n            \n            statusTracker.cancelCommand(commandId);\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.status).toBe('cancelled');\n            expect(status!.metadata.cancelled).toBe(true);\n            expect(status!.message).toBe('Cancelled by user');\n        });\n    });\n\n    describe('Output Management', () => {\n        test('should append output to command', () => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project');\n            \n            statusTracker.appendOutput(commandId, 'Line 1\\n');\n            statusTracker.appendOutput(commandId, 'Line 2\\n');\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.output).toBe('Line 1\\nLine 2\\n');\n        });\n\n        test('should append error to command', () => {\n            const commandId = statusTracker.startCommand('nxTest', 'test-project');\n            \n            statusTracker.appendError(commandId, 'Error 1\\n');\n            statusTracker.appendError(commandId, 'Error 2\\n');\n            \n            const status = statusTracker.getStatus(commandId);\n            expect(status!.error).toBe('Error 1\\nError 2\\n');\n        });\n    });\n\n    describe('Status Queries', () => {\n        test('should get all statuses', () => {\n            const cmd1 = statusTracker.startCommand('aiDebug', 'project1');\n            const cmd2 = statusTracker.startCommand('nxTest', 'project2');\n            \n            const statuses = statusTracker.getAllStatuses();\n            expect(statuses).toHaveLength(2);\n            expect(statuses.map(s => s.id)).toContain(cmd1);\n            expect(statuses.map(s => s.id)).toContain(cmd2);\n        });\n\n        test('should get running commands only', () => {\n            const cmd1 = statusTracker.startCommand('aiDebug', 'project1');\n            const cmd2 = statusTracker.startCommand('nxTest', 'project2');\n            \n            statusTracker.updateStatus(cmd1, 'success');\n            \n            const running = statusTracker.getRunningCommands();\n            expect(running).toHaveLength(1);\n            expect(running[0].id).toBe(cmd2);\n        });\n    });\n\n    describe('History Management', () => {\n        test('should add completed commands to history', () => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project');\n            \n            const result = {\n                success: true,\n                exitCode: 0,\n                output: 'Success',\n                duration: 3000,\n                outputFiles: ['output.txt']\n            };\n            \n            statusTracker.completeCommand(commandId, result);\n            \n            const history = statusTracker.getHistory();\n            expect(history).toHaveLength(1);\n            expect(history[0].command).toBe('aiDebug');\n            expect(history[0].success).toBe(true);\n            expect(history[0].duration).toBe(3000);\n            expect(history[0].filesGenerated).toBe(1);\n        });\n\n        test('should limit history size', () => {\n            // Create more commands than the max history size (50)\n            for (let i = 0; i < 60; i++) {\n                const commandId = statusTracker.startCommand('aiDebug', `project-${i}`);\n                const result = {\n                    success: true,\n                    exitCode: 0,\n                    output: `Output ${i}`,\n                    duration: 1000,\n                    outputFiles: []\n                };\n                statusTracker.completeCommand(commandId, result);\n            }\n            \n            const history = statusTracker.getHistory();\n            expect(history.length).toBeLessThanOrEqual(50);\n        });\n\n        test('should clear history', () => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project');\n            statusTracker.completeCommand(commandId, {\n                success: true,\n                exitCode: 0,\n                output: 'test',\n                duration: 1000,\n                outputFiles: []\n            });\n            \n            expect(statusTracker.getHistory()).toHaveLength(1);\n            \n            statusTracker.clearHistory();\n            expect(statusTracker.getHistory()).toHaveLength(0);\n        });\n    });\n\n    describe('Statistics', () => {\n        beforeEach(() => {\n            // Add some test data\n            const commands = [\n                { command: 'aiDebug', success: true, duration: 1000 },\n                { command: 'aiDebug', success: false, duration: 2000 },\n                { command: 'nxTest', success: true, duration: 3000 },\n                { command: 'nxTest', success: true, duration: 4000 }\n            ];\n            \n            commands.forEach((cmd, i) => {\n                const commandId = statusTracker.startCommand(cmd.command as any, `project-${i}`);\n                statusTracker.completeCommand(commandId, {\n                    success: cmd.success,\n                    exitCode: cmd.success ? 0 : 1,\n                    output: 'test',\n                    duration: cmd.duration,\n                    outputFiles: []\n                });\n            });\n        });\n\n        test('should calculate overall statistics', () => {\n            const stats = statusTracker.getCommandStats();\n            \n            expect(stats.total).toBe(4);\n            expect(stats.successful).toBe(3);\n            expect(stats.failed).toBe(1);\n            expect(stats.averageDuration).toBe(2500); // (1000+2000+3000+4000)/4\n            expect(stats.lastRun).toBeDefined();\n        });\n\n        test('should calculate command-specific statistics', () => {\n            const aiDebugStats = statusTracker.getCommandStats('aiDebug');\n            \n            expect(aiDebugStats.total).toBe(2);\n            expect(aiDebugStats.successful).toBe(1);\n            expect(aiDebugStats.failed).toBe(1);\n            expect(aiDebugStats.averageDuration).toBe(1500); // (1000+2000)/2\n        });\n    });\n\n    describe('Status Report', () => {\n        test('should generate comprehensive status report', () => {\n            // Start a running command\n            const runningId = statusTracker.startCommand('aiDebug', 'test-project');\n            statusTracker.updateProgress(runningId, 50, 'Processing...');\n            \n            // Complete some commands\n            const completedId = statusTracker.startCommand('nxTest', 'test-project');\n            statusTracker.completeCommand(completedId, {\n                success: true,\n                exitCode: 0,\n                output: 'Tests passed',\n                duration: 5000,\n                outputFiles: ['test-output.txt']\n            });\n            \n            const report = statusTracker.generateStatusReport();\n            \n            expect(report).toContain('STATUS REPORT');\n            expect(report).toContain('CURRENTLY RUNNING');\n            expect(report).toContain('STATISTICS');\n            expect(report).toContain('COMMAND BREAKDOWN');\n            expect(report).toContain('Processing...');\n            expect(report).toContain('50%');\n        });\n    });\n\n    describe('Action Button Conversion', () => {\n        test('should convert to action button format', () => {\n            // Start and complete some commands\n            const aiDebugId = statusTracker.startCommand('aiDebug', 'project1');\n            statusTracker.completeCommand(aiDebugId, {\n                success: true,\n                exitCode: 0,\n                output: 'Success',\n                duration: 2000,\n                outputFiles: []\n            });\n            \n            const nxTestId = statusTracker.startCommand('nxTest', 'project2');\n            statusTracker.updateProgress(nxTestId, 75);\n            \n            const buttons = statusTracker.toActionButtons();\n            \n            expect(buttons).toHaveProperty('aiDebug');\n            expect(buttons).toHaveProperty('nxTest');\n            expect(buttons).toHaveProperty('gitDiff');\n            expect(buttons).toHaveProperty('prepareToPush');\n            \n            expect(buttons.aiDebug.status).toBe('success');\n            expect(buttons.aiDebug.enabled).toBe(true);\n            expect(buttons.aiDebug.lastRun).toBeDefined();\n            \n            expect(buttons.nxTest.status).toBe('running');\n            expect(buttons.nxTest.enabled).toBe(false);\n            expect(buttons.nxTest.progress).toBe(75);\n        });\n    });\n\n    describe('Event Emission', () => {\n        test('should emit status change events', (done) => {\n            const commandId = statusTracker.startCommand('aiDebug', 'test-project');\n            \n            statusTracker.on('status_change', (event) => {\n                expect(event.type).toBe('progress_update');\n                expect(event.commandId).toBe(commandId);\n                expect(event.data.progress).toBe(25);\n                done();\n            });\n            \n            statusTracker.updateProgress(commandId, 25, 'Testing...');\n        });\n\n        test('should emit history updated events', (done) => {\n            const commandId = statusTracker.startCommand('nxTest', 'test-project');\n            \n            statusTracker.on('history_updated', (entry) => {\n                expect(entry.command).toBe('nxTest');\n                expect(entry.success).toBe(true);\n                done();\n            });\n            \n            statusTracker.completeCommand(commandId, {\n                success: true,\n                exitCode: 0,\n                output: 'Success',\n                duration: 1000,\n                outputFiles: []\n            });\n        });\n    });\n\n    describe('Edge Cases', () => {\n        test('should handle operations on non-existent commands gracefully', () => {\n            expect(() => {\n                statusTracker.updateProgress('non-existent', 50);\n                statusTracker.updateStatus('non-existent', 'success');\n                statusTracker.appendOutput('non-existent', 'output');\n                statusTracker.appendError('non-existent', 'error');\n                statusTracker.cancelCommand('non-existent');\n            }).not.toThrow();\n        });\n\n        test('should generate unique command IDs', () => {\n            const id1 = statusTracker.startCommand('aiDebug', 'project1');\n            const id2 = statusTracker.startCommand('aiDebug', 'project1');\n            const id3 = statusTracker.startCommand('aiDebug', 'project2');\n            \n            expect(id1).not.toBe(id2);\n            expect(id1).not.toBe(id3);\n            expect(id2).not.toBe(id3);\n        });\n\n        test('should handle commands without projects', () => {\n            const commandId = statusTracker.startCommand('gitDiff');\n            const status = statusTracker.getStatus(commandId);\n            \n            expect(status!.project).toBeUndefined();\n            expect(status!.command).toBe('gitDiff');\n        });\n    });\n});\n