42e63498643ed53d05568e01a5c98be3
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// Mock fs and path modules
jest.mock('fs', () => {
    const mockPromises = {
        copyFile: jest.fn(),
        writeFile: jest.fn(),
        readFile: jest.fn(),
        unlink: jest.fn(),
        stat: jest.fn(),
        mkdir: jest.fn()
    };
    return {
        existsSync: jest.fn(),
        mkdirSync: jest.fn(),
        readdirSync: jest.fn(),
        statSync: jest.fn(),
        watch: jest.fn(),
        writeFileSync: jest.fn(),
        readFileSync: jest.fn(),
        promises: mockPromises
    };
});
jest.mock('path');
// Mock vscode module
jest.mock('vscode', () => ({
    workspace: {
        workspaceFolders: [
            { uri: { fsPath: '/test/workspace' } }
        ],
        getConfiguration: jest.fn(() => ({
            get: jest.fn((key) => {
                if (key === 'outputDirectory') {
                    return '.github/instructions/ai_utilities_context';
                }
                return undefined;
            })
        })),
        onDidChangeConfiguration: jest.fn(),
        createFileSystemWatcher: jest.fn(() => ({
            onDidChange: jest.fn(),
            onDidCreate: jest.fn(),
            onDidDelete: jest.fn(),
            dispose: jest.fn()
        })),
        openTextDocument: jest.fn()
    },
    window: {
        showTextDocument: jest.fn(),
        showErrorMessage: jest.fn(),
        showInformationMessage: jest.fn(),
        showWarningMessage: jest.fn(),
        createOutputChannel: jest.fn(() => ({
            appendLine: jest.fn(),
            show: jest.fn()
        }))
    },
    env: {
        clipboard: {
            writeText: jest.fn()
        }
    },
    Uri: {
        file: jest.fn((path) => ({ fsPath: path }))
    },
    RelativePattern: jest.fn()
}));
const enhancedFileManager_1 = require("../enhancedFileManager");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const mockedFs = fs;
const mockedPath = path;
const mockFsPromises = mockedFs.promises;
describe('EnhancedFileManager', () => {
    let fileManager;
    const mockWorkspaceRoot = '/test/workspace';
    const mockOutputDir = '/test/workspace/.github/instructions/ai_utilities_context';
    beforeEach(() => {
        jest.clearAllMocks();
        // Setup path mocks
        mockedPath.join.mockImplementation((...segments) => segments.join('/'));
        mockedPath.basename.mockImplementation((p) => p.split('/').pop() || '');
        mockedPath.dirname.mockImplementation((p) => p.split('/').slice(0, -1).join('/'));
        // Setup basic fs mocks
        mockedFs.existsSync.mockReturnValue(true);
        mockedFs.mkdirSync.mockImplementation(() => undefined);
        mockedFs.writeFileSync.mockImplementation(() => undefined);
        mockedFs.readFileSync.mockReturnValue('mock file content');
        mockedFs.readdirSync.mockReturnValue([]);
        mockedFs.statSync.mockReturnValue({
            size: 1024,
            birthtime: new Date('2024-01-01'),
            mtime: new Date('2024-01-02'),
            isFile: () => true,
            isDirectory: () => false
        });
        // Setup fs.promises mocks
        mockFsPromises.writeFile.mockResolvedValue(undefined);
        mockFsPromises.readFile.mockResolvedValue('mock content');
        mockFsPromises.copyFile.mockResolvedValue(undefined);
        mockFsPromises.stat.mockResolvedValue({
            size: 1024,
            birthtime: new Date('2024-01-01'),
            mtime: new Date('2024-01-02')
        });
        mockFsPromises.mkdir.mockResolvedValue(undefined);
        fileManager = new enhancedFileManager_1.EnhancedFileManager();
    });
    describe('backup functionality', () => {
        describe('createBackup', () => {
            it('should create a backup of existing output files', async () => {
                const mockFiles = [
                    { type: 'jest-output', path: '/test/jest-output.txt', exists: true, modified: new Date() },
                    { type: 'diff', path: '/test/diff.txt', exists: true, modified: new Date() }
                ];
                mockedFs.existsSync.mockReturnValue(true);
                // Mock getAllOutputFiles
                jest.spyOn(fileManager, 'getAllOutputFiles').mockReturnValue(mockFiles);
                jest.spyOn(fileManager, 'ensureDirectoryExists').mockResolvedValue(undefined);
                const backupPath = await fileManager.createBackup('test-backup');
                expect(backupPath).toContain('backup-test-backup-');
                expect(mockFsPromises.copyFile).toHaveBeenCalledTimes(2);
                expect(mockFsPromises.writeFile).toHaveBeenCalled();
                // Verify the JSON content separately
                const writeCall = mockFsPromises.writeFile.mock.calls[0];
                const filePath = writeCall[0];
                const jsonContent = writeCall[1];
                const parsedJson = JSON.parse(jsonContent);
                expect(filePath).toContain('backup-metadata.json');
                expect(parsedJson.label).toBe('test-backup');
                expect(parsedJson.files).toBe(2);
            });
            it('should handle backup failures gracefully', async () => {
                const mockFiles = [
                    { type: 'jest-output', path: '/test/jest-output.txt', exists: true, modified: new Date() }
                ];
                jest.spyOn(fileManager, 'getAllOutputFiles').mockReturnValue(mockFiles);
                jest.spyOn(fileManager, 'ensureDirectoryExists').mockResolvedValue(undefined);
                mockFsPromises.copyFile.mockRejectedValue(new Error('Copy failed'));
                const backupPath = await fileManager.createBackup();
                expect(backupPath).toBeDefined();
                expect(mockFsPromises.writeFile).toHaveBeenCalled();
                // Verify the JSON content separately
                const writeCall = mockFsPromises.writeFile.mock.calls[0];
                const filePath = writeCall[0];
                const jsonContent = writeCall[1];
                const parsedJson = JSON.parse(jsonContent);
                expect(filePath).toContain('backup-metadata.json');
                expect(parsedJson.files).toBe(0);
                expect(parsedJson.label).toBe('manual');
            });
        });
        describe('restoreFromBackup', () => {
            it('should restore files from backup directory', async () => {
                const backupPath = '/test/backup-dir';
                mockedFs.existsSync.mockImplementation((path) => {
                    if (path === backupPath) {
                        return true;
                    }
                    if (path === `${backupPath}/backup-metadata.json`) {
                        return true;
                    }
                    return false;
                });
                mockedFs.readdirSync.mockReturnValue(['jest-output.txt', 'diff.txt', 'backup-metadata.json']);
                mockFsPromises.readFile.mockResolvedValue(JSON.stringify({
                    label: 'test-backup',
                    timestamp: new Date().toISOString(),
                    files: 2
                }));
                jest.spyOn(fileManager, 'ensureOutputDirectory').mockImplementation(() => { });
                await fileManager.restoreFromBackup(backupPath);
                expect(mockFsPromises.copyFile).toHaveBeenCalledTimes(2);
                expect(mockFsPromises.copyFile).toHaveBeenCalledWith('/test/backup-dir/jest-output.txt', expect.stringContaining('jest-output.txt'));
            });
            it('should throw error for non-existent backup directory', async () => {
                mockedFs.existsSync.mockReturnValue(false);
                await expect(fileManager.restoreFromBackup('/non-existent'))
                    .rejects.toThrow('Backup directory not found');
            });
        });
    });
    describe('enhanced file operations', () => {
        describe('saveOutputWithVersioning', () => {
            it('should save file with backup when requested', async () => {
                const content = 'test content';
                const type = 'jest-output';
                mockedFs.existsSync.mockReturnValue(true);
                jest.spyOn(fileManager, 'ensureOutputDirectory').mockImplementation(() => { });
                const result = await fileManager.saveOutputWithVersioning(type, content, { backup: true });
                expect(result).toContain('jest-output.txt');
                expect(mockFsPromises.copyFile).toHaveBeenCalled();
                expect(mockFsPromises.writeFile).toHaveBeenCalledWith(expect.stringContaining('jest-output.txt'), content, 'utf8');
            });
            it('should validate content when requested', async () => {
                const content = 'invalid test content';
                const type = 'jest-output';
                mockedFs.existsSync.mockReturnValue(false);
                jest.spyOn(fileManager, 'ensureOutputDirectory').mockImplementation(() => { });
                const consoleSpy = jest.spyOn(console, 'warn').mockImplementation(() => { });
                await fileManager.saveOutputWithVersioning(type, content, { validate: true });
                expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Jest output validation'));
                consoleSpy.mockRestore();
            });
        });
        describe('getFileMetadata', () => {
            it('should return comprehensive metadata for existing file', async () => {
                const type = 'jest-output';
                const mockStats = {
                    size: 1024,
                    birthtime: new Date('2024-01-01'),
                    mtime: new Date('2024-01-02')
                };
                mockedFs.existsSync.mockReturnValue(true);
                mockedFs.statSync.mockReturnValue(mockStats);
                mockFsPromises.readFile.mockResolvedValue('line1\nline2\nline3');
                const metadata = await fileManager.getFileMetadata(type);
                expect(metadata).toEqual({
                    path: expect.stringContaining('jest-output.txt'),
                    size: 1024,
                    sizeFormatted: '1 KB',
                    lines: 3,
                    created: mockStats.birthtime,
                    modified: mockStats.mtime,
                    exists: true,
                    type,
                    status: expect.stringMatching(/^(current|stale)$/)
                });
            });
            it('should return missing status for non-existent file', async () => {
                const type = 'jest-output';
                mockedFs.existsSync.mockReturnValue(false);
                const metadata = await fileManager.getFileMetadata(type);
                expect(metadata.exists).toBe(false);
                expect(metadata.status).toBe('missing');
                expect(metadata.size).toBe(0);
            });
            it('should return stale status for old files', async () => {
                const type = 'jest-output';
                const oldDate = new Date(Date.now() - 25 * 60 * 60 * 1000); // 25 hours ago
                const mockStats = {
                    size: 1024,
                    birthtime: oldDate,
                    mtime: oldDate
                };
                mockedFs.existsSync.mockReturnValue(true);
                mockedFs.statSync.mockReturnValue(mockStats);
                mockFsPromises.readFile.mockResolvedValue('content');
                const metadata = await fileManager.getFileMetadata(type);
                expect(metadata.status).toBe('stale');
            });
            it('should return error status when stat fails', async () => {
                const type = 'jest-output';
                mockedFs.existsSync.mockReturnValue(true);
                mockedFs.statSync.mockImplementation(() => {
                    throw new Error('Stat failed');
                });
                const metadata = await fileManager.getFileMetadata(type);
                expect(metadata.status).toBe('error');
                expect(metadata.exists).toBe(true);
            });
        });
        describe('getAllFileMetadata', () => {
            it('should return metadata for all output file types', async () => {
                jest.spyOn(fileManager, 'getFileMetadata').mockImplementation(async (type) => ({
                    path: `/test/${type}.txt`,
                    size: 1024,
                    sizeFormatted: '1 KB',
                    lines: 10,
                    created: new Date(),
                    modified: new Date(),
                    exists: true,
                    type,
                    status: 'current'
                }));
                const allMetadata = await fileManager.getAllFileMetadata();
                expect(allMetadata).toHaveLength(4);
                expect(allMetadata.map(m => m.type)).toEqual([
                    'ai-debug-context',
                    'jest-output',
                    'diff',
                    'pr-description'
                ]);
            });
        });
    });
    describe('file batch management', () => {
        describe('createFileBatch', () => {
            it('should create file batch with metadata', async () => {
                const mockMetadata = {
                    path: '/test/jest-output.txt',
                    size: 1024,
                    sizeFormatted: '1 KB',
                    lines: 10,
                    created: new Date(),
                    modified: new Date(),
                    exists: true,
                    type: 'jest-output',
                    status: 'current'
                };
                jest.spyOn(fileManager, 'getFileMetadata').mockResolvedValue(mockMetadata);
                const batch = await fileManager.createFileBatch('aiDebug', ['jest-output'], true);
                expect(batch.command).toBe('aiDebug');
                expect(batch.success).toBe(true);
                expect(batch.files).toHaveLength(1);
                expect(batch.id).toContain('aiDebug-');
            });
            it('should maintain file history with size limit', async () => {
                jest.spyOn(fileManager, 'getFileMetadata').mockResolvedValue({
                    path: '/test/test.txt',
                    size: 1024,
                    sizeFormatted: '1 KB',
                    lines: 10,
                    created: new Date(),
                    modified: new Date(),
                    exists: true,
                    type: 'jest-output',
                    status: 'current'
                });
                // Create multiple batches to test history limit
                for (let i = 0; i < 5; i++) {
                    await fileManager.createFileBatch(`command-${i}`, ['jest-output'], true);
                }
                const history = fileManager.getFileHistory();
                expect(history).toHaveLength(5);
                expect(history[0].command).toBe('command-4'); // Most recent first
            });
        });
    });
    describe('enhanced file watching', () => {
        describe('watchOutputFiles', () => {
            it('should set up file watcher with detailed events', () => {
                const vscode = require('vscode');
                const mockWatcher = {
                    onDidCreate: jest.fn(),
                    onDidChange: jest.fn(),
                    onDidDelete: jest.fn(),
                    dispose: jest.fn()
                };
                const callback = jest.fn();
                vscode.workspace.createFileSystemWatcher.mockReturnValue(mockWatcher);
                const disposable = fileManager.watchOutputFiles(callback);
                expect(vscode.workspace.createFileSystemWatcher).toHaveBeenCalled();
                expect(mockWatcher.onDidCreate).toHaveBeenCalled();
                expect(mockWatcher.onDidChange).toHaveBeenCalled();
                expect(mockWatcher.onDidDelete).toHaveBeenCalled();
                // Test dispose
                disposable.dispose();
                expect(mockWatcher.dispose).toHaveBeenCalled();
            });
            it('should call callback with proper event data', () => {
                const vscode = require('vscode');
                const mockWatcher = {
                    onDidCreate: jest.fn(),
                    onDidChange: jest.fn(),
                    onDidDelete: jest.fn(),
                    dispose: jest.fn()
                };
                const callback = jest.fn();
                vscode.workspace.createFileSystemWatcher.mockReturnValue(mockWatcher);
                fileManager.watchOutputFiles(callback);
                // Get the handler function for onDidChange
                const changeHandler = mockWatcher.onDidChange.mock.calls[0][0];
                // Simulate file change event
                const mockUri = { fsPath: '/test/jest-output.txt' };
                changeHandler(mockUri);
                expect(callback).toHaveBeenCalledWith({
                    type: 'modified',
                    file: 'jest-output',
                    path: '/test/jest-output.txt',
                    timestamp: expect.any(Date)
                });
            });
        });
    });
    describe('utility methods', () => {
        it('should format file sizes correctly', () => {
            // Access private method through type assertion
            const formatFileSize = fileManager.formatFileSize;
            expect(formatFileSize(512)).toBe('512 B');
            expect(formatFileSize(1024)).toBe('1 KB');
            expect(formatFileSize(1536)).toBe('1.5 KB');
            expect(formatFileSize(1048576)).toBe('1 MB');
            expect(formatFileSize(1073741824)).toBe('1 GB');
        });
        it('should get extension version from package.json', async () => {
            const packageContent = JSON.stringify({ version: '2.1.0' });
            mockFsPromises.readFile.mockResolvedValue(packageContent);
            const getExtensionVersion = fileManager.getExtensionVersion;
            const version = await getExtensionVersion();
            expect(version).toBe('2.1.0');
        });
        it('should fallback to default version when package.json not found', async () => {
            mockFsPromises.readFile.mockRejectedValue(new Error('File not found'));
            const getExtensionVersion = fileManager.getExtensionVersion;
            const version = await getExtensionVersion();
            expect(version).toBe('1.0.0');
        });
    });
    describe('backward compatibility', () => {
        it('should maintain all original FileManager methods', () => {
            expect(fileManager.ensureOutputDirectory).toBeDefined();
            expect(fileManager.saveOutput).toBeDefined();
            expect(fileManager.getFileContent).toBeDefined();
            expect(fileManager.openFile).toBeDefined();
            expect(fileManager.getFilePath).toBeDefined();
            expect(fileManager.fileExists).toBeDefined();
            expect(fileManager.getFileModTime).toBeDefined();
            expect(fileManager.getAllOutputFiles).toBeDefined();
            expect(fileManager.cleanupOldFiles).toBeDefined();
            expect(fileManager.copyToClipboard).toBeDefined();
        });
        it('should work with existing saveOutput method', async () => {
            const content = 'test content';
            const type = 'jest-output';
            mockedFs.existsSync.mockReturnValue(false);
            mockedFs.mkdirSync.mockImplementation(() => undefined);
            mockedFs.writeFileSync.mockImplementation(() => undefined);
            const result = await fileManager.saveOutput(type, content);
            expect(result).toContain('jest-output.txt');
            expect(mockedFs.writeFileSync).toHaveBeenCalledWith(expect.stringContaining('jest-output.txt'), content, 'utf8');
        });
    });
    describe('batch management', () => {
        it('should track active batches', async () => {
            const mockBatch = {
                id: 'test-batch-123',
                command: 'test',
                timestamp: new Date(),
                files: [],
                success: true
            };
            // Create a batch through the public API
            const batch = await fileManager.createFileBatch('test', ['jest-output'], true);
            expect(batch).toHaveProperty('id');
            expect(batch.command).toBe('test');
            expect(batch.success).toBe(true);
        });
        it('should cleanup completed batches', () => {
            // Test batch cleanup functionality by checking history limit
            const history = fileManager.getFileHistory();
            expect(Array.isArray(history)).toBe(true);
            // Since this is a private method without return value,
            // we just verify it doesn't throw
            expect(true).toBe(true);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy91dGlscy9fX3Rlc3RzX18vZW5oYW5jZWRGaWxlTWFuYWdlci50ZXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsMkJBQTJCO0FBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTtJQUNqQixNQUFNLFlBQVksR0FBRztRQUNqQixRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNuQixTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNwQixRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNuQixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtRQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0tBQ25CLENBQUM7SUFFRixPQUFPO1FBQ0gsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDckIsU0FBUyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDcEIsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDdEIsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDaEIsYUFBYSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDeEIsWUFBWSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDdkIsUUFBUSxFQUFFLFlBQVk7S0FDekIsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUVsQixxQkFBcUI7QUFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUN2QixTQUFTLEVBQUU7UUFD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Q0FBQztRQUVILEVBQUUsQ0FBQyxrQ0FBa0MsRUFBRSxHQUFHLEVBQUU7WUFDeEMsNkRBQTZEO1lBQzdELE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUM3QyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUxQyx1REFBdUQ7WUFDdkQsa0NBQWtDO1lBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ncmVnZHVubi9zcmMvdGVzdC9haV9kZWJ1Z19jb250ZXh0L3ZzY29kZS9zcmMvdXRpbHMvX190ZXN0c19fL2VuaGFuY2VkRmlsZU1hbmFnZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbmhhbmNlZEZpbGVNYW5hZ2VyLCBGaWxlTWV0YWRhdGEsIEZpbGVCYXRjaCB9IGZyb20gJy4uL2VuaGFuY2VkRmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgT3V0cHV0VHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbi8vIE1vY2sgZnMgYW5kIHBhdGggbW9kdWxlc1xuamVzdC5tb2NrKCdmcycsICgpID0+IHtcbiAgICBjb25zdCBtb2NrUHJvbWlzZXMgPSB7XG4gICAgICAgIGNvcHlGaWxlOiBqZXN0LmZuKCksXG4gICAgICAgIHdyaXRlRmlsZTogamVzdC5mbigpLFxuICAgICAgICByZWFkRmlsZTogamVzdC5mbigpLFxuICAgICAgICB1bmxpbms6IGplc3QuZm4oKSxcbiAgICAgICAgc3RhdDogamVzdC5mbigpLFxuICAgICAgICBta2RpcjogamVzdC5mbigpXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBleGlzdHNTeW5jOiBqZXN0LmZuKCksXG4gICAgICAgIG1rZGlyU3luYzogamVzdC5mbigpLFxuICAgICAgICByZWFkZGlyU3luYzogamVzdC5mbigpLFxuICAgICAgICBzdGF0U3luYzogamVzdC5mbigpLFxuICAgICAgICB3YXRjaDogamVzdC5mbigpLFxuICAgICAgICB3cml0ZUZpbGVTeW5jOiBqZXN0LmZuKCksXG4gICAgICAgIHJlYWRGaWxlU3luYzogamVzdC5mbigpLFxuICAgICAgICBwcm9taXNlczogbW9ja1Byb21pc2VzXG4gICAgfTtcbn0pO1xuamVzdC5tb2NrKCdwYXRoJyk7XG5cbi8vIE1vY2sgdnNjb2RlIG1vZHVsZVxuamVzdC5tb2NrKCd2c2NvZGUnLCAoKSA9PiAoe1xuICAgIHdvcmtzcGFjZToge1xuICAgICAgICB3b3Jrc3BhY2VGb2xkZXJzOiBbXG4gICAgICAgICAgICB7IHVyaTogeyBmc1BhdGg6ICcvdGVzdC93b3Jrc3BhY2UnIH0gfVxuICAgICAgICBdLFxuICAgICAgICBnZXRDb25maWd1cmF0aW9uOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgICAgICBnZXQ6IGplc3QuZm4oKGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ291dHB1dERpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuZ2l0aHViL2luc3RydWN0aW9ucy9haV91dGlsaXRpZXNfY29udGV4dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSksXG4gICAgICAgIG9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbjogamVzdC5mbigpLFxuICAgICAgICBjcmVhdGVGaWxlU3lzdGVtV2F0Y2hlcjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgb25EaWRDaGFuZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIG9uRGlkQ3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBvbkRpZERlbGV0ZTogamVzdC5mbigpLFxuICAgICAgICAgICAgZGlzcG9zZTogamVzdC5mbigpXG4gICAgICAgIH0pKSxcbiAgICAgICAgb3BlblRleHREb2N1bWVudDogamVzdC5mbigpXG4gICAgfSxcbiAgICB3aW5kb3c6IHtcbiAgICAgICAgc2hvd1RleHREb2N1bWVudDogamVzdC5mbigpLFxuICAgICAgICBzaG93RXJyb3JNZXNzYWdlOiBqZXN0LmZuKCksXG4gICAgICAgIHNob3dJbmZvcm1hdGlvbk1lc3NhZ2U6IGplc3QuZm4oKSxcbiAgICAgICAgc2hvd1dhcm5pbmdNZXNzYWdlOiBqZXN0LmZuKCksXG4gICAgICAgIGNyZWF0ZU91dHB1dENoYW5uZWw6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIGFwcGVuZExpbmU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNob3c6IGplc3QuZm4oKVxuICAgICAgICB9KSlcbiAgICB9LFxuICAgIGVudjoge1xuICAgICAgICBjbGlwYm9hcmQ6IHtcbiAgICAgICAgICAgIHdyaXRlVGV4dDogamVzdC5mbigpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFVyaToge1xuICAgICAgICBmaWxlOiBqZXN0LmZuKChwYXRoOiBzdHJpbmcpID0+ICh7IGZzUGF0aDogcGF0aCB9KSlcbiAgICB9LFxuICAgIFJlbGF0aXZlUGF0dGVybjogamVzdC5mbigpXG59KSk7XG5cbmNvbnN0IG1vY2tlZEZzID0gZnMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzPjtcbmNvbnN0IG1vY2tlZFBhdGggPSBwYXRoIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBwYXRoPjtcbmNvbnN0IG1vY2tGc1Byb21pc2VzID0gbW9ja2VkRnMucHJvbWlzZXMgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGZzLnByb21pc2VzPjtcblxuZGVzY3JpYmUoJ0VuaGFuY2VkRmlsZU1hbmFnZXInLCAoKSA9PiB7XG4gICAgbGV0IGZpbGVNYW5hZ2VyOiBFbmhhbmNlZEZpbGVNYW5hZ2VyO1xuICAgIGNvbnN0IG1vY2tXb3Jrc3BhY2VSb290ID0gJy90ZXN0L3dvcmtzcGFjZSc7XG4gICAgY29uc3QgbW9ja091dHB1dERpciA9ICcvdGVzdC93b3Jrc3BhY2UvLmdpdGh1Yi9pbnN0cnVjdGlvbnMvYWlfdXRpbGl0aWVzX2NvbnRleHQnO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgcGF0aCBtb2Nrc1xuICAgICAgICBtb2NrZWRQYXRoLmpvaW4ubW9ja0ltcGxlbWVudGF0aW9uKCguLi5zZWdtZW50cykgPT4gc2VnbWVudHMuam9pbignLycpKTtcbiAgICAgICAgbW9ja2VkUGF0aC5iYXNlbmFtZS5tb2NrSW1wbGVtZW50YXRpb24oKHApID0+IHAuc3BsaXQoJy8nKS5wb3AoKSB8fCAnJyk7XG4gICAgICAgIG1vY2tlZFBhdGguZGlybmFtZS5tb2NrSW1wbGVtZW50YXRpb24oKHApID0+IHAuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuam9pbignLycpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldHVwIGJhc2ljIGZzIG1vY2tzXG4gICAgICAgIG1vY2tlZEZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgICBtb2NrZWRGcy5ta2RpclN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICAgIG1vY2tlZEZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCk7XG4gICAgICAgIG1vY2tlZEZzLnJlYWRGaWxlU3luYy5tb2NrUmV0dXJuVmFsdWUoJ21vY2sgZmlsZSBjb250ZW50Jyk7XG4gICAgICAgIG1vY2tlZEZzLnJlYWRkaXJTeW5jLm1vY2tSZXR1cm5WYWx1ZShbXSk7XG4gICAgICAgIG1vY2tlZEZzLnN0YXRTeW5jLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaXplOiAxMDI0LFxuICAgICAgICAgICAgYmlydGh0aW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgICAgICAgbXRpbWU6IG5ldyBEYXRlKCcyMDI0LTAxLTAyJyksXG4gICAgICAgICAgICBpc0ZpbGU6ICgpID0+IHRydWUsXG4gICAgICAgICAgICBpc0RpcmVjdG9yeTogKCkgPT4gZmFsc2VcbiAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgZnMucHJvbWlzZXMgbW9ja3NcbiAgICAgICAgbW9ja0ZzUHJvbWlzZXMud3JpdGVGaWxlLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgICAgIG1vY2tGc1Byb21pc2VzLnJlYWRGaWxlLm1vY2tSZXNvbHZlZFZhbHVlKCdtb2NrIGNvbnRlbnQnKTtcbiAgICAgICAgbW9ja0ZzUHJvbWlzZXMuY29weUZpbGUubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgbW9ja0ZzUHJvbWlzZXMuc3RhdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICBzaXplOiAxMDI0LFxuICAgICAgICAgICAgYmlydGh0aW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgICAgICAgbXRpbWU6IG5ldyBEYXRlKCcyMDI0LTAxLTAyJylcbiAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICBtb2NrRnNQcm9taXNlcy5ta2Rpci5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgICBcbiAgICAgICAgZmlsZU1hbmFnZXIgPSBuZXcgRW5oYW5jZWRGaWxlTWFuYWdlcigpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2JhY2t1cCBmdW5jdGlvbmFsaXR5JywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnY3JlYXRlQmFja3VwJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgYSBiYWNrdXAgb2YgZXhpc3Rpbmcgb3V0cHV0IGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnamVzdC1vdXRwdXQnIGFzIE91dHB1dFR5cGUsIHBhdGg6ICcvdGVzdC9qZXN0LW91dHB1dC50eHQnLCBleGlzdHM6IHRydWUsIG1vZGlmaWVkOiBuZXcgRGF0ZSgpIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2RpZmYnIGFzIE91dHB1dFR5cGUsIHBhdGg6ICcvdGVzdC9kaWZmLnR4dCcsIGV4aXN0czogdHJ1ZSwgbW9kaWZpZWQ6IG5ldyBEYXRlKCkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBtb2NrZWRGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBNb2NrIGdldEFsbE91dHB1dEZpbGVzXG4gICAgICAgICAgICAgICAgamVzdC5zcHlPbihmaWxlTWFuYWdlciwgJ2dldEFsbE91dHB1dEZpbGVzJykubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlcyk7XG4gICAgICAgICAgICAgICAgamVzdC5zcHlPbihmaWxlTWFuYWdlciwgJ2Vuc3VyZURpcmVjdG9yeUV4aXN0cycpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrdXBQYXRoID0gYXdhaXQgZmlsZU1hbmFnZXIuY3JlYXRlQmFja3VwKCd0ZXN0LWJhY2t1cCcpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQ29udGFpbignYmFja3VwLXRlc3QtYmFja3VwLScpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrRnNQcm9taXNlcy5jb3B5RmlsZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrRnNQcm9taXNlcy53cml0ZUZpbGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIEpTT04gY29udGVudCBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVDYWxsID0gbW9ja0ZzUHJvbWlzZXMud3JpdGVGaWxlLm1vY2suY2FsbHNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSB3cml0ZUNhbGxbMF0gYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25Db250ZW50ID0gd3JpdGVDYWxsWzFdIGFzIHN0cmluZztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRKc29uID0gSlNPTi5wYXJzZShqc29uQ29udGVudCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZXhwZWN0KGZpbGVQYXRoKS50b0NvbnRhaW4oJ2JhY2t1cC1tZXRhZGF0YS5qc29uJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHBhcnNlZEpzb24ubGFiZWwpLnRvQmUoJ3Rlc3QtYmFja3VwJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHBhcnNlZEpzb24uZmlsZXMpLnRvQmUoMik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgYmFja3VwIGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW1xuICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdqZXN0LW91dHB1dCcgYXMgT3V0cHV0VHlwZSwgcGF0aDogJy90ZXN0L2plc3Qtb3V0cHV0LnR4dCcsIGV4aXN0czogdHJ1ZSwgbW9kaWZpZWQ6IG5ldyBEYXRlKCkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBqZXN0LnNweU9uKGZpbGVNYW5hZ2VyLCAnZ2V0QWxsT3V0cHV0RmlsZXMnKS5tb2NrUmV0dXJuVmFsdWUobW9ja0ZpbGVzKTtcbiAgICAgICAgICAgICAgICBqZXN0LnNweU9uKGZpbGVNYW5hZ2VyLCAnZW5zdXJlRGlyZWN0b3J5RXhpc3RzJykubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBtb2NrRnNQcm9taXNlcy5jb3B5RmlsZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0NvcHkgZmFpbGVkJykpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFja3VwUGF0aCA9IGF3YWl0IGZpbGVNYW5hZ2VyLmNyZWF0ZUJhY2t1cCgpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KGJhY2t1cFBhdGgpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG1vY2tGc1Byb21pc2VzLndyaXRlRmlsZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgSlNPTiBjb250ZW50IHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZUNhbGwgPSBtb2NrRnNQcm9taXNlcy53cml0ZUZpbGUubW9jay5jYWxsc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHdyaXRlQ2FsbFswXSBhcyBzdHJpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSB3cml0ZUNhbGxbMV0gYXMgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEpzb24gPSBKU09OLnBhcnNlKGpzb25Db250ZW50KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBleHBlY3QoZmlsZVBhdGgpLnRvQ29udGFpbignYmFja3VwLW1ldGFkYXRhLmpzb24nKTtcbiAgICAgICAgICAgICAgICBleHBlY3QocGFyc2VkSnNvbi5maWxlcykudG9CZSgwKTtcbiAgICAgICAgICAgICAgICBleHBlY3QocGFyc2VkSnNvbi5sYWJlbCkudG9CZSgnbWFudWFsJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3Jlc3RvcmVGcm9tQmFja3VwJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXN0b3JlIGZpbGVzIGZyb20gYmFja3VwIGRpcmVjdG9yeScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrdXBQYXRoID0gJy90ZXN0L2JhY2t1cC1kaXInO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG1vY2tlZEZzLmV4aXN0c1N5bmMubW9ja0ltcGxlbWVudGF0aW9uKChwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBiYWNrdXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gYCR7YmFja3VwUGF0aH0vYmFja3VwLW1ldGFkYXRhLmpzb25gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtb2NrZWRGcy5yZWFkZGlyU3luYy5tb2NrUmV0dXJuVmFsdWUoWydqZXN0LW91dHB1dC50eHQnLCAnZGlmZi50eHQnLCAnYmFja3VwLW1ldGFkYXRhLmpzb24nXSBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIG1vY2tGc1Byb21pc2VzLnJlYWRGaWxlLm1vY2tSZXNvbHZlZFZhbHVlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICd0ZXN0LWJhY2t1cCcsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBmaWxlczogMlxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBqZXN0LnNweU9uKGZpbGVNYW5hZ2VyLCAnZW5zdXJlT3V0cHV0RGlyZWN0b3J5JykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IGZpbGVNYW5hZ2VyLnJlc3RvcmVGcm9tQmFja3VwKGJhY2t1cFBhdGgpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KG1vY2tGc1Byb21pc2VzLmNvcHlGaWxlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG1vY2tGc1Byb21pc2VzLmNvcHlGaWxlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICAgICAgJy90ZXN0L2JhY2t1cC1kaXIvamVzdC1vdXRwdXQudHh0JyxcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2plc3Qtb3V0cHV0LnR4dCcpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBub24tZXhpc3RlbnQgYmFja3VwIGRpcmVjdG9yeScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBtb2NrZWRGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBleHBlY3QoZmlsZU1hbmFnZXIucmVzdG9yZUZyb21CYWNrdXAoJy9ub24tZXhpc3RlbnQnKSlcbiAgICAgICAgICAgICAgICAgICAgLnJlamVjdHMudG9UaHJvdygnQmFja3VwIGRpcmVjdG9yeSBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdlbmhhbmNlZCBmaWxlIG9wZXJhdGlvbnMnLCAoKSA9PiB7XG4gICAgICAgIGRlc2NyaWJlKCdzYXZlT3V0cHV0V2l0aFZlcnNpb25pbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnc2hvdWxkIHNhdmUgZmlsZSB3aXRoIGJhY2t1cCB3aGVuIHJlcXVlc3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gJ3Rlc3QgY29udGVudCc7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZTogT3V0cHV0VHlwZSA9ICdqZXN0LW91dHB1dCc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbW9ja2VkRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgamVzdC5zcHlPbihmaWxlTWFuYWdlciwgJ2Vuc3VyZU91dHB1dERpcmVjdG9yeScpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaWxlTWFuYWdlci5zYXZlT3V0cHV0V2l0aFZlcnNpb25pbmcodHlwZSwgY29udGVudCwgeyBiYWNrdXA6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ2plc3Qtb3V0cHV0LnR4dCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrRnNQcm9taXNlcy5jb3B5RmlsZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrRnNQcm9taXNlcy53cml0ZUZpbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnamVzdC1vdXRwdXQudHh0JyksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICd1dGY4J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBjb250ZW50IHdoZW4gcmVxdWVzdGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAnaW52YWxpZCB0ZXN0IGNvbnRlbnQnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGU6IE91dHB1dFR5cGUgPSAnamVzdC1vdXRwdXQnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG1vY2tlZEZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBqZXN0LnNweU9uKGZpbGVNYW5hZ2VyLCAnZW5zdXJlT3V0cHV0RGlyZWN0b3J5JykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnd2FybicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlTWFuYWdlci5zYXZlT3V0cHV0V2l0aFZlcnNpb25pbmcodHlwZSwgY29udGVudCwgeyB2YWxpZGF0ZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGV4cGVjdChjb25zb2xlU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0plc3Qgb3V0cHV0IHZhbGlkYXRpb24nKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZVNweS5tb2NrUmVzdG9yZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdnZXRGaWxlTWV0YWRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGZvciBleGlzdGluZyBmaWxlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGU6IE91dHB1dFR5cGUgPSAnamVzdC1vdXRwdXQnO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tTdGF0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTAyNCxcbiAgICAgICAgICAgICAgICAgICAgYmlydGh0aW1lOiBuZXcgRGF0ZSgnMjAyNC0wMS0wMScpLFxuICAgICAgICAgICAgICAgICAgICBtdGltZTogbmV3IERhdGUoJzIwMjQtMDEtMDInKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBtb2NrZWRGcy5leGlzdHNTeW5jLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBtb2NrZWRGcy5zdGF0U3luYy5tb2NrUmV0dXJuVmFsdWUobW9ja1N0YXRzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgbW9ja0ZzUHJvbWlzZXMucmVhZEZpbGUubW9ja1Jlc29sdmVkVmFsdWUoJ2xpbmUxXFxubGluZTJcXG5saW5lMycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmaWxlTWFuYWdlci5nZXRGaWxlTWV0YWRhdGEodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QobWV0YWRhdGEpLnRvRXF1YWwoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnamVzdC1vdXRwdXQudHh0JyksXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IDEwMjQsXG4gICAgICAgICAgICAgICAgICAgIHNpemVGb3JtYXR0ZWQ6ICcxIEtCJyxcbiAgICAgICAgICAgICAgICAgICAgbGluZXM6IDMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IG1vY2tTdGF0cy5iaXJ0aHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBtb2NrU3RhdHMubXRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleHBlY3Quc3RyaW5nTWF0Y2hpbmcoL14oY3VycmVudHxzdGFsZSkkLylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBtaXNzaW5nIHN0YXR1cyBmb3Igbm9uLWV4aXN0ZW50IGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZTogT3V0cHV0VHlwZSA9ICdqZXN0LW91dHB1dCc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbW9ja2VkRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmaWxlTWFuYWdlci5nZXRGaWxlTWV0YWRhdGEodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QobWV0YWRhdGEuZXhpc3RzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBleHBlY3QobWV0YWRhdGEuc3RhdHVzKS50b0JlKCdtaXNzaW5nJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KG1ldGFkYXRhLnNpemUpLnRvQmUoMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gc3RhbGUgc3RhdHVzIGZvciBvbGQgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZTogT3V0cHV0VHlwZSA9ICdqZXN0LW91dHB1dCc7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNSAqIDYwICogNjAgKiAxMDAwKTsgLy8gMjUgaG91cnMgYWdvXG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja1N0YXRzID0ge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiAxMDI0LFxuICAgICAgICAgICAgICAgICAgICBiaXJ0aHRpbWU6IG9sZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIG10aW1lOiBvbGREYXRlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vY2tlZEZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgICAgICAgICAgIG1vY2tlZEZzLnN0YXRTeW5jLm1vY2tSZXR1cm5WYWx1ZShtb2NrU3RhdHMgYXMgYW55KTtcbiAgICAgICAgICAgICAgICBtb2NrRnNQcm9taXNlcy5yZWFkRmlsZS5tb2NrUmVzb2x2ZWRWYWx1ZSgnY29udGVudCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmaWxlTWFuYWdlci5nZXRGaWxlTWV0YWRhdGEodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QobWV0YWRhdGEuc3RhdHVzKS50b0JlKCdzdGFsZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIHN0YXR1cyB3aGVuIHN0YXQgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZTogT3V0cHV0VHlwZSA9ICdqZXN0LW91dHB1dCc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbW9ja2VkRnMuZXhpc3RzU3luYy5tb2NrUmV0dXJuVmFsdWUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9ja2VkRnMuc3RhdFN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0IGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmaWxlTWFuYWdlci5nZXRGaWxlTWV0YWRhdGEodHlwZSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QobWV0YWRhdGEuc3RhdHVzKS50b0JlKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtZXRhZGF0YS5leGlzdHMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2dldEFsbEZpbGVNZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG1ldGFkYXRhIGZvciBhbGwgb3V0cHV0IGZpbGUgdHlwZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgamVzdC5zcHlPbihmaWxlTWFuYWdlciwgJ2dldEZpbGVNZXRhZGF0YScpLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodHlwZSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC90ZXN0LyR7dHlwZX0udHh0YCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTAyNCxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUZvcm1hdHRlZDogJzEgS0InLFxuICAgICAgICAgICAgICAgICAgICBsaW5lczogMTAsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICBleGlzdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ2N1cnJlbnQnXG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsTWV0YWRhdGEgPSBhd2FpdCBmaWxlTWFuYWdlci5nZXRBbGxGaWxlTWV0YWRhdGEoKTtcblxuICAgICAgICAgICAgICAgIGV4cGVjdChhbGxNZXRhZGF0YSkudG9IYXZlTGVuZ3RoKDQpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChhbGxNZXRhZGF0YS5tYXAobSA9PiBtLnR5cGUpKS50b0VxdWFsKFtcbiAgICAgICAgICAgICAgICAgICAgJ2FpLWRlYnVnLWNvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICAnamVzdC1vdXRwdXQnLFxuICAgICAgICAgICAgICAgICAgICAnZGlmZicsXG4gICAgICAgICAgICAgICAgICAgICdwci1kZXNjcmlwdGlvbidcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdmaWxlIGJhdGNoIG1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgICAgIGRlc2NyaWJlKCdjcmVhdGVGaWxlQmF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBmaWxlIGJhdGNoIHdpdGggbWV0YWRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja01ldGFkYXRhOiBGaWxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvdGVzdC9qZXN0LW91dHB1dC50eHQnLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAxMDI0LFxuICAgICAgICAgICAgICAgICAgICBzaXplRm9ybWF0dGVkOiAnMSBLQicsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2plc3Qtb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnY3VycmVudCdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgamVzdC5zcHlPbihmaWxlTWFuYWdlciwgJ2dldEZpbGVNZXRhZGF0YScpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tNZXRhZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGF3YWl0IGZpbGVNYW5hZ2VyLmNyZWF0ZUZpbGVCYXRjaCgnYWlEZWJ1ZycsIFsnamVzdC1vdXRwdXQnXSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2guY29tbWFuZCkudG9CZSgnYWlEZWJ1ZycpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5maWxlcykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5pZCkudG9Db250YWluKCdhaURlYnVnLScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gZmlsZSBoaXN0b3J5IHdpdGggc2l6ZSBsaW1pdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBqZXN0LnNweU9uKGZpbGVNYW5hZ2VyLCAnZ2V0RmlsZU1ldGFkYXRhJykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL3Rlc3QvdGVzdC50eHQnLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiAxMDI0LFxuICAgICAgICAgICAgICAgICAgICBzaXplRm9ybWF0dGVkOiAnMSBLQicsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2plc3Qtb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnY3VycmVudCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSBiYXRjaGVzIHRvIHRlc3QgaGlzdG9yeSBsaW1pdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZpbGVNYW5hZ2VyLmNyZWF0ZUZpbGVCYXRjaChgY29tbWFuZC0ke2l9YCwgWydqZXN0LW91dHB1dCddLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gZmlsZU1hbmFnZXIuZ2V0RmlsZUhpc3RvcnkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoaGlzdG9yeSkudG9IYXZlTGVuZ3RoKDUpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChoaXN0b3J5WzBdLmNvbW1hbmQpLnRvQmUoJ2NvbW1hbmQtNCcpOyAvLyBNb3N0IHJlY2VudCBmaXJzdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2VuaGFuY2VkIGZpbGUgd2F0Y2hpbmcnLCAoKSA9PiB7XG4gICAgICAgIGRlc2NyaWJlKCd3YXRjaE91dHB1dEZpbGVzJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgdXAgZmlsZSB3YXRjaGVyIHdpdGggZGV0YWlsZWQgZXZlbnRzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IHJlcXVpcmUoJ3ZzY29kZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tXYXRjaGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBvbkRpZENyZWF0ZTogamVzdC5mbigpLFxuICAgICAgICAgICAgICAgICAgICBvbkRpZENoYW5nZTogamVzdC5mbigpLFxuICAgICAgICAgICAgICAgICAgICBvbkRpZERlbGV0ZTogamVzdC5mbigpLFxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlOiBqZXN0LmZuKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gamVzdC5mbigpO1xuXG4gICAgICAgICAgICAgICAgdnNjb2RlLndvcmtzcGFjZS5jcmVhdGVGaWxlU3lzdGVtV2F0Y2hlci5tb2NrUmV0dXJuVmFsdWUobW9ja1dhdGNoZXIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IGZpbGVNYW5hZ2VyLndhdGNoT3V0cHV0RmlsZXMoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KHZzY29kZS53b3Jrc3BhY2UuY3JlYXRlRmlsZVN5c3RlbVdhdGNoZXIpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QobW9ja1dhdGNoZXIub25EaWRDcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QobW9ja1dhdGNoZXIub25EaWRDaGFuZ2UpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QobW9ja1dhdGNoZXIub25EaWREZWxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZGlzcG9zZVxuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChtb2NrV2F0Y2hlci5kaXNwb3NlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBjYWxsIGNhbGxiYWNrIHdpdGggcHJvcGVyIGV2ZW50IGRhdGEnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdnNjb2RlID0gcmVxdWlyZSgndnNjb2RlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9ja1dhdGNoZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGlkQ3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICAgICAgICAgIG9uRGlkQ2hhbmdlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICAgICAgICAgIG9uRGlkRGVsZXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6IGplc3QuZm4oKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBqZXN0LmZuKCk7XG5cbiAgICAgICAgICAgICAgICB2c2NvZGUud29ya3NwYWNlLmNyZWF0ZUZpbGVTeXN0ZW1XYXRjaGVyLm1vY2tSZXR1cm5WYWx1ZShtb2NrV2F0Y2hlcik7XG5cbiAgICAgICAgICAgICAgICBmaWxlTWFuYWdlci53YXRjaE91dHB1dEZpbGVzKGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaGFuZGxlciBmdW5jdGlvbiBmb3Igb25EaWRDaGFuZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VIYW5kbGVyID0gbW9ja1dhdGNoZXIub25EaWRDaGFuZ2UubW9jay5jYWxsc1swXVswXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZSBmaWxlIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG1vY2tVcmkgPSB7IGZzUGF0aDogJy90ZXN0L2plc3Qtb3V0cHV0LnR4dCcgfTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VIYW5kbGVyKG1vY2tVcmkpO1xuXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNhbGxiYWNrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb2RpZmllZCcsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6ICdqZXN0LW91dHB1dCcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvdGVzdC9qZXN0LW91dHB1dC50eHQnLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGV4cGVjdC5hbnkoRGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd1dGlsaXR5IG1ldGhvZHMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgZm9ybWF0IGZpbGUgc2l6ZXMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQWNjZXNzIHByaXZhdGUgbWV0aG9kIHRocm91Z2ggdHlwZSBhc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdEZpbGVTaXplID0gKGZpbGVNYW5hZ2VyIGFzIGFueSkuZm9ybWF0RmlsZVNpemU7XG5cbiAgICAgICAgICAgIGV4cGVjdChmb3JtYXRGaWxlU2l6ZSg1MTIpKS50b0JlKCc1MTIgQicpO1xuICAgICAgICAgICAgZXhwZWN0KGZvcm1hdEZpbGVTaXplKDEwMjQpKS50b0JlKCcxIEtCJyk7XG4gICAgICAgICAgICBleHBlY3QoZm9ybWF0RmlsZVNpemUoMTUzNikpLnRvQmUoJzEuNSBLQicpO1xuICAgICAgICAgICAgZXhwZWN0KGZvcm1hdEZpbGVTaXplKDEwNDg1NzYpKS50b0JlKCcxIE1CJyk7XG4gICAgICAgICAgICBleHBlY3QoZm9ybWF0RmlsZVNpemUoMTA3Mzc0MTgyNCkpLnRvQmUoJzEgR0InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBnZXQgZXh0ZW5zaW9uIHZlcnNpb24gZnJvbSBwYWNrYWdlLmpzb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogJzIuMS4wJyB9KTtcbiAgICAgICAgICAgIG1vY2tGc1Byb21pc2VzLnJlYWRGaWxlLm1vY2tSZXNvbHZlZFZhbHVlKHBhY2thZ2VDb250ZW50KTtcblxuICAgICAgICAgICAgY29uc3QgZ2V0RXh0ZW5zaW9uVmVyc2lvbiA9IChmaWxlTWFuYWdlciBhcyBhbnkpLmdldEV4dGVuc2lvblZlcnNpb247XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0RXh0ZW5zaW9uVmVyc2lvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QodmVyc2lvbikudG9CZSgnMi4xLjAnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBmYWxsYmFjayB0byBkZWZhdWx0IHZlcnNpb24gd2hlbiBwYWNrYWdlLmpzb24gbm90IGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbW9ja0ZzUHJvbWlzZXMucmVhZEZpbGUubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdGaWxlIG5vdCBmb3VuZCcpKTtcblxuICAgICAgICAgICAgY29uc3QgZ2V0RXh0ZW5zaW9uVmVyc2lvbiA9IChmaWxlTWFuYWdlciBhcyBhbnkpLmdldEV4dGVuc2lvblZlcnNpb247XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0RXh0ZW5zaW9uVmVyc2lvbigpO1xuXG4gICAgICAgICAgICBleHBlY3QodmVyc2lvbikudG9CZSgnMS4wLjAnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYmFja3dhcmQgY29tcGF0aWJpbGl0eScsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBtYWludGFpbiBhbGwgb3JpZ2luYWwgRmlsZU1hbmFnZXIgbWV0aG9kcycsICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5lbnN1cmVPdXRwdXREaXJlY3RvcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoZmlsZU1hbmFnZXIuc2F2ZU91dHB1dCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5nZXRGaWxlQ29udGVudCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5vcGVuRmlsZSkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5nZXRGaWxlUGF0aCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5maWxlRXhpc3RzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVNYW5hZ2VyLmdldEZpbGVNb2RUaW1lKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVNYW5hZ2VyLmdldEFsbE91dHB1dEZpbGVzKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVNYW5hZ2VyLmNsZWFudXBPbGRGaWxlcykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlTWFuYWdlci5jb3B5VG9DbGlwYm9hcmQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgd29yayB3aXRoIGV4aXN0aW5nIHNhdmVPdXRwdXQgbWV0aG9kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9ICd0ZXN0IGNvbnRlbnQnO1xuICAgICAgICAgICAgY29uc3QgdHlwZTogT3V0cHV0VHlwZSA9ICdqZXN0LW91dHB1dCc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tlZEZzLmV4aXN0c1N5bmMubW9ja1JldHVyblZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIG1vY2tlZEZzLm1rZGlyU3luYy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIG1vY2tlZEZzLndyaXRlRmlsZVN5bmMubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbGVNYW5hZ2VyLnNhdmVPdXRwdXQodHlwZSwgY29udGVudCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignamVzdC1vdXRwdXQudHh0Jyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja2VkRnMud3JpdGVGaWxlU3luYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2plc3Qtb3V0cHV0LnR4dCcpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgJ3V0ZjgnXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdiYXRjaCBtYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHRyYWNrIGFjdGl2ZSBiYXRjaGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0JhdGNoOiBGaWxlQmF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgaWQ6ICd0ZXN0LWJhdGNoLTEyMycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBmaWxlczogW10sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmF0Y2ggdGhyb3VnaCB0aGUgcHVibGljIEFQSVxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCBmaWxlTWFuYWdlci5jcmVhdGVGaWxlQmF0Y2goJ3Rlc3QnLCBbJ2plc3Qtb3V0cHV0J10sIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoYmF0Y2gpLnRvSGF2ZVByb3BlcnR5KCdpZCcpO1xuICAgICAgICAgICAgZXhwZWN0KGJhdGNoLmNvbW1hbmQpLnRvQmUoJ3Rlc3QnKTtcbiAgICAgICAgICAgIGV4cGVjdChiYXRjaC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNsZWFudXAgY29tcGxldGVkIGJhdGNoZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBUZXN0IGJhdGNoIGNsZWFudXAgZnVuY3Rpb25hbGl0eSBieSBjaGVja2luZyBoaXN0b3J5IGxpbWl0XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5ID0gZmlsZU1hbmFnZXIuZ2V0RmlsZUhpc3RvcnkoKTtcbiAgICAgICAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KGhpc3RvcnkpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcHJpdmF0ZSBtZXRob2Qgd2l0aG91dCByZXR1cm4gdmFsdWUsXG4gICAgICAgICAgICAvLyB3ZSBqdXN0IHZlcmlmeSBpdCBkb2Vzbid0IHRocm93XG4gICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcbiJdLCJ2ZXJzaW9uIjozfQ==