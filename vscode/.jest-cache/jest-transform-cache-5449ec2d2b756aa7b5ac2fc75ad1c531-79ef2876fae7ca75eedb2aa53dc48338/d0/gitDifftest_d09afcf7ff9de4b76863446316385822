3f6dec3ba877a1d3f79f45ecd349b380
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Mock VSCode API
jest.mock('vscode', () => ({
    workspace: {
        workspaceFolders: [{ uri: { fsPath: '/test/workspace' } }],
        getConfiguration: jest.fn(() => ({
            get: jest.fn(() => '.github/instructions/ai_utilities_context')
        }))
    },
    window: {
        createOutputChannel: jest.fn(() => ({
            appendLine: jest.fn(),
            show: jest.fn()
        }))
    }
}));
// Mock FileManager
jest.mock('../../utils/fileManager');
// Mock child_process
jest.mock('child_process', () => ({
    spawn: jest.fn()
}));
const gitDiff_1 = require("../gitDiff");
const fileManager_1 = require("../../utils/fileManager");
const MockedFileManager = fileManager_1.FileManager;
describe('GitDiffCommand', () => {
    let gitDiffCommand;
    let mockFileManager;
    let mockSpawn;
    beforeEach(() => {
        jest.clearAllMocks();
        // Setup FileManager mock
        mockFileManager = {
            getOutputFilePath: jest.fn().mockReturnValue('/test/diff.txt'),
            ensureDirectoryExists: jest.fn(),
            deleteFile: jest.fn(),
            writeFile: jest.fn(),
            getFileStats: jest.fn().mockResolvedValue({
                size: 5120,
                created: new Date(),
                modified: new Date(),
                accessed: new Date()
            })
        };
        mockSpawn = require('child_process').spawn;
        MockedFileManager.mockImplementation(() => mockFileManager);
        gitDiffCommand = new gitDiff_1.GitDiffCommand();
    });
    describe('run', () => {
        it('should execute git diff and create AI-optimized output', async () => {
            // Arrange
            const options = {};
            const mockDiffOutput = `diff --git a/file1.ts b/file1.ts
index 123..456 100644
--- a/file1.ts
+++ b/file1.ts
@@ -1,3 +1,4 @@
 export class TestClass {
+  newMethod() {}
 }`;
            // Mock the executeGitCommand method directly
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand
                .mockResolvedValueOnce({ success: false, exitCode: 1, output: '', duration: 0 }) // diff --quiet (has changes)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: mockDiffOutput, duration: 0 }); // diff
            // Act
            const result = await gitDiffCommand.run(options);
            // Assert
            expect(result.success).toBe(true);
            expect(result.exitCode).toBe(0);
            expect(mockFileManager.writeFile).toHaveBeenCalled();
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        }, 5000);
        it('should detect smart diff when no changes in working directory', async () => {
            // Arrange
            const options = {};
            // Mock the executeGitCommand method directly
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }) // diff --quiet (no unstaged)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }) // diff --cached --quiet (no staged)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }) // rev-parse --verify HEAD~1 (has commits)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }); // diff HEAD~1..HEAD
            // Act
            await gitDiffCommand.run(options);
            // Assert
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', '--quiet']);
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', '--cached', '--quiet']);
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['rev-parse', '--verify', 'HEAD~1']);
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', 'HEAD~1..HEAD']);
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        });
        it('should use staged changes when no unstaged changes', async () => {
            // Arrange
            const options = {};
            // Mock the executeGitCommand method directly
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }) // diff --quiet (no unstaged)
                .mockResolvedValueOnce({ success: false, exitCode: 1, output: '', duration: 0 }) // diff --cached --quiet (has staged)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: 'staged changes', duration: 0 }); // diff --cached
            // Act
            await gitDiffCommand.run(options);
            // Assert
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', '--quiet']);
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', '--cached', '--quiet']);
            expect(mockExecuteGitCommand).toHaveBeenCalledWith(['diff', '--cached']);
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        }, 5000);
        it('should handle git command errors', async () => {
            // Arrange
            const options = {};
            // Mock the executeGitCommand method to return an error
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand.mockResolvedValueOnce({
                success: false,
                exitCode: 1,
                output: '',
                error: 'Git not found',
                duration: 0
            });
            // Act
            const result = await gitDiffCommand.run(options);
            // Assert
            expect(result.success).toBe(false);
            expect(result.error).toBe('Git not found');
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        }, 5000);
        it('should skip diff when noDiff option is true', async () => {
            // Arrange
            const options = { noDiff: true };
            // Act
            const result = await gitDiffCommand.run(options);
            // Assert
            expect(mockSpawn).not.toHaveBeenCalled();
        });
        it('should create no changes output when diff is empty', async () => {
            // Arrange
            const options = {};
            // Mock the executeGitCommand method directly
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand
                .mockResolvedValueOnce({ success: false, exitCode: 1, output: '', duration: 0 }) // diff --quiet (has changes)
                .mockResolvedValueOnce({ success: true, exitCode: 0, output: '', duration: 0 }); // diff (empty output)
            // Act
            const result = await gitDiffCommand.run(options);
            // Assert
            expect(result.success).toBe(true);
            expect(mockFileManager.writeFile).toHaveBeenCalledWith(expect.any(String), expect.stringContaining('No changes detected'));
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        });
    });
    describe('analyzeDiffChanges', () => {
        it('should analyze different types of file changes', () => {
            // Arrange
            const diffOutput = `diff --git a/new-file.ts b/new-file.ts
new file mode 100644
index 000..123
--- /dev/null
+++ b/new-file.ts
diff --git a/modified-file.ts b/modified-file.ts
index 123..456 100644
--- a/modified-file.ts
+++ b/modified-file.ts
diff --git a/deleted-file.ts b/deleted-file.ts
deleted file mode 100644
index 123..000
--- a/deleted-file.ts
+++ /dev/null
diff --git a/old-name.ts b/new-name.ts
similarity index 100%
rename from old-name.ts
rename to new-name.ts`;
            // Act
            const result = gitDiffCommand.analyzeDiffChanges(diffOutput);
            // Assert
            expect(result.newFiles).toContain('new-file.ts');
            expect(result.modifiedFiles).toContain('modified-file.ts');
            expect(result.deletedFiles).toContain('deleted-file.ts');
            expect(result.renamedFiles).toContain('old-name.ts → new-name.ts');
            expect(result.totalChanges).toBe(4);
        });
        it('should handle empty diff output', () => {
            // Arrange
            const diffOutput = '';
            // Act
            const result = gitDiffCommand.analyzeDiffChanges(diffOutput);
            // Assert
            expect(result.newFiles).toEqual([]);
            expect(result.modifiedFiles).toEqual([]);
            expect(result.deletedFiles).toEqual([]);
            expect(result.renamedFiles).toEqual([]);
            expect(result.totalChanges).toBe(0);
        });
    });
    describe('analyzeFileTypes', () => {
        it('should categorize different file types', () => {
            // Arrange
            const diffOutput = `diff --git a/component.ts b/component.ts
diff --git a/component.spec.ts b/component.spec.ts
diff --git a/template.html b/template.html
diff --git a/styles.css b/styles.css
diff --git a/config.json b/config.json
diff --git a/readme.md b/readme.md`;
            // Act
            const result = gitDiffCommand.analyzeFileTypes(diffOutput);
            // Assert
            expect(result).toContain('TypeScript files: 1');
            expect(result).toContain('Test files: 1');
            expect(result).toContain('Templates: 1');
            expect(result).toContain('Styles: 1');
            expect(result).toContain('Config/JSON: 1');
            expect(result).toContain('Other: 1');
        });
        it('should provide AI insights based on file types', () => {
            // Arrange
            const diffOutput = `diff --git a/component.spec.ts b/component.spec.ts
diff --git a/service.ts b/service.ts
diff --git a/other.ts b/other.ts
diff --git a/config.json b/config.json`;
            // Act
            const result = gitDiffCommand.analyzeFileTypes(diffOutput);
            // Assert
            expect(result).toContain('🧪 Test files modified');
            expect(result).toContain('⚠️  More source files than test files changed');
            expect(result).toContain('⚙️  Configuration changes detected');
        });
    });
    describe('addFileSeparators', () => {
        it('should add file separators to diff output', () => {
            // Arrange
            const diffOutput = `diff --git a/file1.ts b/file1.ts
index 123..456
--- a/file1.ts
+++ b/file1.ts
@@ -1 +1,2 @@
 line1
+line2
diff --git a/file2.ts b/file2.ts
index 456..789
--- a/file2.ts
+++ b/file2.ts`;
            // Act
            const result = gitDiffCommand.addFileSeparators(diffOutput);
            // Assert
            expect(result).toContain('📁 FILE: file1.ts');
            expect(result).toContain('📁 FILE: file2.ts');
            expect(result).toContain('─'.repeat(40));
        });
    });
    describe('countChangedFiles', () => {
        it('should count changed files from processed output', () => {
            // Arrange
            const output = `📁 FILE: file1.ts
Some content
📁 FILE: file2.ts
More content
📁 FILE: file3.ts
Even more content`;
            // Act
            const result = gitDiffCommand.countChangedFiles(output);
            // Assert
            expect(result).toBe(3);
        });
        it('should return 0 for output without file markers', () => {
            // Arrange
            const output = 'Some content without file markers';
            // Act
            const result = gitDiffCommand.countChangedFiles(output);
            // Assert
            expect(result).toBe(0);
        });
    });
    describe('createNoChangesOutput', () => {
        it('should create informative output for no changes', () => {
            // Act
            const result = gitDiffCommand.createNoChangesOutput();
            // Assert
            expect(result).toContain('No changes detected');
            expect(result).toContain('Working directory: Clean');
            expect(result).toContain('Staged changes: None');
            expect(result).toContain('AI ANALYSIS CONTEXT');
        });
    });
    describe('getCurrentBranch', () => {
        it('should return current branch name', async () => {
            // Mock the executeGitCommand method directly
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand.mockResolvedValueOnce({
                success: true,
                exitCode: 0,
                output: 'main\n',
                duration: 0
            });
            // Act
            const result = await gitDiffCommand.getCurrentBranch();
            // Assert
            expect(result).toBe('main');
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        });
        it('should return "unknown" when git command fails', async () => {
            // Mock the executeGitCommand method to return an error
            const mockExecuteGitCommand = jest.spyOn(gitDiffCommand, 'executeGitCommand');
            mockExecuteGitCommand.mockResolvedValueOnce({
                success: false,
                exitCode: 1,
                output: '',
                error: 'Not a git repository',
                duration: 0
            });
            // Act
            const result = await gitDiffCommand.getCurrentBranch();
            // Assert
            expect(result).toBe('unknown');
            // Cleanup
            mockExecuteGitCommand.mockRestore();
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy9jb21tYW5kcy9fX3Rlc3RzX18vZ2l0RGlmZi50ZXN0LnRzIiwibWFwcGluZ3MiOiI7O0FBSUEsa0JBQWtCO0FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkIsU0FBUyxFQUFFO1FBQ1AsZ0JBQWdCLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxFQUFFLENBQUM7UUFDMUQsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzdCLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLDJDQUEyQyxDQUFDO1NBQ2xFLENBQUMsQ0FBQztLQUNOO0lBQ0QsTUFBTSxFQUFFO1FBQ0osbUJBQW1CLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ2hDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ3JCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ2xCLENBQUMsQ0FBQztLQUNOO0NBQ0osQ0FBQyxDQUFDLENBQUM7QUFFSixtQkFBbUI7QUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBR3JDLHFCQUFxQjtBQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzlCLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0NBQ25CLENBQUMsQ0FBQyxDQUFDO0FBM0JKLHdDQUE0QztBQUU1Qyx5REFBc0Q7QUFvQnRELE1BQU0saUJBQWlCLEdBQUcseUJBQW1ELENBQUM7QUFPOUUsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRTtJQUM1QixJQUFJLGNBQThCLENBQUM7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QUFPLGNBQXNCLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUVoRSxTQUFTO1lBQ1QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUU1QixVQUFVO1lBQ1YscUJBQXFCLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDeEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsZ0RBQWdELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDNUQsdURBQXVEO1lBQ3ZELE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFxQixFQUFFLG1CQUFtQixDQUFDLENBQUM7WUFDckYscUJBQXFCLENBQUMscUJBQXFCLENBQUM7Z0JBQ3hDLE9BQU8sRUFBRSxLQUFLO2dCQUNkLFFBQVEsRUFBRSxDQUFDO2dCQUNYLE1BQU0sRUFBRSxFQUFFO2dCQUNWLEtBQUssRUFBRSxzQkFBc0I7Z0JBQzdCLFFBQVEsRUFBRSxDQUFDO2FBQ2QsQ0FBQyxDQUFDO1lBRUgsTUFBTTtZQUNOLE1BQU0sTUFBTSxHQUFHLE1BQU8sY0FBc0IsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBRWhFLFNBQVM7WUFDVCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRS9CLFVBQVU7WUFDVixxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUN4QyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy9jb21tYW5kcy9fX3Rlc3RzX18vZ2l0RGlmZi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdpdERpZmZDb21tYW5kIH0gZnJvbSAnLi4vZ2l0RGlmZic7XG5pbXBvcnQgeyBDb21tYW5kT3B0aW9ucyB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEZpbGVNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZmlsZU1hbmFnZXInO1xuXG4vLyBNb2NrIFZTQ29kZSBBUElcbmplc3QubW9jaygndnNjb2RlJywgKCkgPT4gKHtcbiAgICB3b3Jrc3BhY2U6IHtcbiAgICAgICAgd29ya3NwYWNlRm9sZGVyczogW3sgdXJpOiB7IGZzUGF0aDogJy90ZXN0L3dvcmtzcGFjZScgfSB9XSxcbiAgICAgICAgZ2V0Q29uZmlndXJhdGlvbjogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICAgICAgZ2V0OiBqZXN0LmZuKCgpID0+ICcuZ2l0aHViL2luc3RydWN0aW9ucy9haV91dGlsaXRpZXNfY29udGV4dCcpXG4gICAgICAgIH0pKVxuICAgIH0sXG4gICAgd2luZG93OiB7XG4gICAgICAgIGNyZWF0ZU91dHB1dENoYW5uZWw6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgICAgICAgIGFwcGVuZExpbmU6IGplc3QuZm4oKSxcbiAgICAgICAgICAgIHNob3c6IGplc3QuZm4oKVxuICAgICAgICB9KSlcbiAgICB9XG59KSk7XG5cbi8vIE1vY2sgRmlsZU1hbmFnZXJcbmplc3QubW9jaygnLi4vLi4vdXRpbHMvZmlsZU1hbmFnZXInKTtcbmNvbnN0IE1vY2tlZEZpbGVNYW5hZ2VyID0gRmlsZU1hbmFnZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgRmlsZU1hbmFnZXI+O1xuXG4vLyBNb2NrIGNoaWxkX3Byb2Nlc3Ncbmplc3QubW9jaygnY2hpbGRfcHJvY2VzcycsICgpID0+ICh7XG4gICAgc3Bhd246IGplc3QuZm4oKVxufSkpO1xuXG5kZXNjcmliZSgnR2l0RGlmZkNvbW1hbmQnLCAoKSA9PiB7XG4gICAgbGV0IGdpdERpZmZDb21tYW5kOiBHaXREaWZmQ29tbWFuZDtcbiAgICBsZXQgbW9ja0ZpbGVNYW5hZ2VyOiBqZXN0Lk1vY2tlZDxGaWxlTWFuYWdlcj47XG4gICAgbGV0IG1vY2tTcGF3bjogamVzdC5Nb2NrZWRGdW5jdGlvbjxhbnk+O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgRmlsZU1hbmFnZXIgbW9ja1xuICAgICAgICBtb2NrRmlsZU1hbmFnZXIgPSB7XG4gICAgICAgICAgICBnZXRPdXRwdXRGaWxlUGF0aDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSgnL3Rlc3QvZGlmZi50eHQnKSxcbiAgICAgICAgICAgIGVuc3VyZURpcmVjdG9yeUV4aXN0czogamVzdC5mbigpLFxuICAgICAgICAgICAgZGVsZXRlRmlsZTogamVzdC5mbigpLFxuICAgICAgICAgICAgd3JpdGVGaWxlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBnZXRGaWxlU3RhdHM6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgc2l6ZTogNTEyMCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGFjY2Vzc2VkOiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGFzIGFueTtcblxuICAgICAgICBtb2NrU3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5cbiAgICAgICAgTW9ja2VkRmlsZU1hbmFnZXIubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tGaWxlTWFuYWdlcik7XG4gICAgICAgIFxuICAgICAgICBnaXREaWZmQ29tbWFuZCA9IG5ldyBHaXREaWZmQ29tbWFuZCgpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3J1bicsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBleGVjdXRlIGdpdCBkaWZmIGFuZCBjcmVhdGUgQUktb3B0aW1pemVkIG91dHB1dCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IENvbW1hbmRPcHRpb25zID0ge307XG4gICAgICAgICAgICBjb25zdCBtb2NrRGlmZk91dHB1dCA9IGBkaWZmIC0tZ2l0IGEvZmlsZTEudHMgYi9maWxlMS50c1xuaW5kZXggMTIzLi40NTYgMTAwNjQ0XG4tLS0gYS9maWxlMS50c1xuKysrIGIvZmlsZTEudHNcbkBAIC0xLDMgKzEsNCBAQFxuIGV4cG9ydCBjbGFzcyBUZXN0Q2xhc3Mge1xuKyAgbmV3TWV0aG9kKCkge31cbiB9YDtcblxuICAgICAgICAgICAgLy8gTW9jayB0aGUgZXhlY3V0ZUdpdENvbW1hbmQgbWV0aG9kIGRpcmVjdGx5XG4gICAgICAgICAgICBjb25zdCBtb2NrRXhlY3V0ZUdpdENvbW1hbmQgPSBqZXN0LnNweU9uKGdpdERpZmZDb21tYW5kIGFzIGFueSwgJ2V4ZWN1dGVHaXRDb21tYW5kJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tFeGVjdXRlR2l0Q29tbWFuZFxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiBmYWxzZSwgZXhpdENvZGU6IDEsIG91dHB1dDogJycsIGR1cmF0aW9uOiAwIH0pIC8vIGRpZmYgLS1xdWlldCAoaGFzIGNoYW5nZXMpXG4gICAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGV4aXRDb2RlOiAwLCBvdXRwdXQ6IG1vY2tEaWZmT3V0cHV0LCBkdXJhdGlvbjogMCB9KTsgLy8gZGlmZlxuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdpdERpZmZDb21tYW5kLnJ1bihvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmV4aXRDb2RlKS50b0JlKDApO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tGaWxlTWFuYWdlci53cml0ZUZpbGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0sIDUwMDApO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZGV0ZWN0IHNtYXJ0IGRpZmYgd2hlbiBubyBjaGFuZ2VzIGluIHdvcmtpbmcgZGlyZWN0b3J5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogQ29tbWFuZE9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgLy8gTW9jayB0aGUgZXhlY3V0ZUdpdENvbW1hbmQgbWV0aG9kIGRpcmVjdGx5XG4gICAgICAgICAgICBjb25zdCBtb2NrRXhlY3V0ZUdpdENvbW1hbmQgPSBqZXN0LnNweU9uKGdpdERpZmZDb21tYW5kIGFzIGFueSwgJ2V4ZWN1dGVHaXRDb21tYW5kJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tFeGVjdXRlR2l0Q29tbWFuZFxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiB0cnVlLCBleGl0Q29kZTogMCwgb3V0cHV0OiAnJywgZHVyYXRpb246IDAgfSkgLy8gZGlmZiAtLXF1aWV0IChubyB1bnN0YWdlZClcbiAgICAgICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgZXhpdENvZGU6IDAsIG91dHB1dDogJycsIGR1cmF0aW9uOiAwIH0pIC8vIGRpZmYgLS1jYWNoZWQgLS1xdWlldCAobm8gc3RhZ2VkKVxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiB0cnVlLCBleGl0Q29kZTogMCwgb3V0cHV0OiAnJywgZHVyYXRpb246IDAgfSkgLy8gcmV2LXBhcnNlIC0tdmVyaWZ5IEhFQUR+MSAoaGFzIGNvbW1pdHMpXG4gICAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGV4aXRDb2RlOiAwLCBvdXRwdXQ6ICcnLCBkdXJhdGlvbjogMCB9KTsgLy8gZGlmZiBIRUFEfjEuLkhFQURcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBhd2FpdCBnaXREaWZmQ29tbWFuZC5ydW4ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KG1vY2tFeGVjdXRlR2l0Q29tbWFuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoWydkaWZmJywgJy0tcXVpZXQnXSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0V4ZWN1dGVHaXRDb21tYW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbJ2RpZmYnLCAnLS1jYWNoZWQnLCAnLS1xdWlldCddKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRXhlY3V0ZUdpdENvbW1hbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFsncmV2LXBhcnNlJywgJy0tdmVyaWZ5JywgJ0hFQUR+MSddKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRXhlY3V0ZUdpdENvbW1hbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFsnZGlmZicsICdIRUFEfjEuLkhFQUQnXSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgICAgIG1vY2tFeGVjdXRlR2l0Q29tbWFuZC5tb2NrUmVzdG9yZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHVzZSBzdGFnZWQgY2hhbmdlcyB3aGVuIG5vIHVuc3RhZ2VkIGNoYW5nZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBDb21tYW5kT3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBNb2NrIHRoZSBleGVjdXRlR2l0Q29tbWFuZCBtZXRob2QgZGlyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IG1vY2tFeGVjdXRlR2l0Q29tbWFuZCA9IGplc3Quc3B5T24oZ2l0RGlmZkNvbW1hbmQgYXMgYW55LCAnZXhlY3V0ZUdpdENvbW1hbmQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kXG4gICAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGV4aXRDb2RlOiAwLCBvdXRwdXQ6ICcnLCBkdXJhdGlvbjogMCB9KSAvLyBkaWZmIC0tcXVpZXQgKG5vIHVuc3RhZ2VkKVxuICAgICAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiBmYWxzZSwgZXhpdENvZGU6IDEsIG91dHB1dDogJycsIGR1cmF0aW9uOiAwIH0pIC8vIGRpZmYgLS1jYWNoZWQgLS1xdWlldCAoaGFzIHN0YWdlZClcbiAgICAgICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgZXhpdENvZGU6IDAsIG91dHB1dDogJ3N0YWdlZCBjaGFuZ2VzJywgZHVyYXRpb246IDAgfSk7IC8vIGRpZmYgLS1jYWNoZWRcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBhd2FpdCBnaXREaWZmQ29tbWFuZC5ydW4ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KG1vY2tFeGVjdXRlR2l0Q29tbWFuZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoWydkaWZmJywgJy0tcXVpZXQnXSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0V4ZWN1dGVHaXRDb21tYW5kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbJ2RpZmYnLCAnLS1jYWNoZWQnLCAnLS1xdWlldCddKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRXhlY3V0ZUdpdENvbW1hbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFsnZGlmZicsICctLWNhY2hlZCddKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0sIDUwMDApO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGdpdCBjb21tYW5kIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IENvbW1hbmRPcHRpb25zID0ge307XG5cbiAgICAgICAgICAgIC8vIE1vY2sgdGhlIGV4ZWN1dGVHaXRDb21tYW5kIG1ldGhvZCB0byByZXR1cm4gYW4gZXJyb3JcbiAgICAgICAgICAgIGNvbnN0IG1vY2tFeGVjdXRlR2l0Q29tbWFuZCA9IGplc3Quc3B5T24oZ2l0RGlmZkNvbW1hbmQgYXMgYW55LCAnZXhlY3V0ZUdpdENvbW1hbmQnKTtcbiAgICAgICAgICAgIG1vY2tFeGVjdXRlR2l0Q29tbWFuZC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgICAgICAgICAgZXhpdENvZGU6IDEsIFxuICAgICAgICAgICAgICAgIG91dHB1dDogJycsIFxuICAgICAgICAgICAgICAgIGVycm9yOiAnR2l0IG5vdCBmb3VuZCcsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDAgXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnaXREaWZmQ29tbWFuZC5ydW4ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ0dpdCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0sIDUwMDApO1xuXG4gICAgICAgIGl0KCdzaG91bGQgc2tpcCBkaWZmIHdoZW4gbm9EaWZmIG9wdGlvbiBpcyB0cnVlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQXJyYW5nZVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uczogQ29tbWFuZE9wdGlvbnMgPSB7IG5vRGlmZjogdHJ1ZSB9O1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdpdERpZmZDb21tYW5kLnJ1bihvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gQXNzZXJ0XG4gICAgICAgICAgICBleHBlY3QobW9ja1NwYXduKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBubyBjaGFuZ2VzIG91dHB1dCB3aGVuIGRpZmYgaXMgZW1wdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zOiBDb21tYW5kT3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAvLyBNb2NrIHRoZSBleGVjdXRlR2l0Q29tbWFuZCBtZXRob2QgZGlyZWN0bHlcbiAgICAgICAgICAgIGNvbnN0IG1vY2tFeGVjdXRlR2l0Q29tbWFuZCA9IGplc3Quc3B5T24oZ2l0RGlmZkNvbW1hbmQgYXMgYW55LCAnZXhlY3V0ZUdpdENvbW1hbmQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kXG4gICAgICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IGZhbHNlLCBleGl0Q29kZTogMSwgb3V0cHV0OiAnJywgZHVyYXRpb246IDAgfSkgLy8gZGlmZiAtLXF1aWV0IChoYXMgY2hhbmdlcylcbiAgICAgICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgZXhpdENvZGU6IDAsIG91dHB1dDogJycsIGR1cmF0aW9uOiAwIH0pOyAvLyBkaWZmIChlbXB0eSBvdXRwdXQpXG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2l0RGlmZkNvbW1hbmQucnVuKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrRmlsZU1hbmFnZXIud3JpdGVGaWxlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ05vIGNoYW5nZXMgZGV0ZWN0ZWQnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2FuYWx5emVEaWZmQ2hhbmdlcycsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBhbmFseXplIGRpZmZlcmVudCB0eXBlcyBvZiBmaWxlIGNoYW5nZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBkaWZmT3V0cHV0ID0gYGRpZmYgLS1naXQgYS9uZXctZmlsZS50cyBiL25ldy1maWxlLnRzXG5uZXcgZmlsZSBtb2RlIDEwMDY0NFxuaW5kZXggMDAwLi4xMjNcbi0tLSAvZGV2L251bGxcbisrKyBiL25ldy1maWxlLnRzXG5kaWZmIC0tZ2l0IGEvbW9kaWZpZWQtZmlsZS50cyBiL21vZGlmaWVkLWZpbGUudHNcbmluZGV4IDEyMy4uNDU2IDEwMDY0NFxuLS0tIGEvbW9kaWZpZWQtZmlsZS50c1xuKysrIGIvbW9kaWZpZWQtZmlsZS50c1xuZGlmZiAtLWdpdCBhL2RlbGV0ZWQtZmlsZS50cyBiL2RlbGV0ZWQtZmlsZS50c1xuZGVsZXRlZCBmaWxlIG1vZGUgMTAwNjQ0XG5pbmRleCAxMjMuLjAwMFxuLS0tIGEvZGVsZXRlZC1maWxlLnRzXG4rKysgL2Rldi9udWxsXG5kaWZmIC0tZ2l0IGEvb2xkLW5hbWUudHMgYi9uZXctbmFtZS50c1xuc2ltaWxhcml0eSBpbmRleCAxMDAlXG5yZW5hbWUgZnJvbSBvbGQtbmFtZS50c1xucmVuYW1lIHRvIG5ldy1uYW1lLnRzYDtcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoZ2l0RGlmZkNvbW1hbmQgYXMgYW55KS5hbmFseXplRGlmZkNoYW5nZXMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5uZXdGaWxlcykudG9Db250YWluKCduZXctZmlsZS50cycpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5tb2RpZmllZEZpbGVzKS50b0NvbnRhaW4oJ21vZGlmaWVkLWZpbGUudHMnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGVsZXRlZEZpbGVzKS50b0NvbnRhaW4oJ2RlbGV0ZWQtZmlsZS50cycpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5yZW5hbWVkRmlsZXMpLnRvQ29udGFpbignb2xkLW5hbWUudHMg4oaSIG5ldy1uYW1lLnRzJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnRvdGFsQ2hhbmdlcykudG9CZSg0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgZGlmZiBvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBkaWZmT3V0cHV0ID0gJyc7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGdpdERpZmZDb21tYW5kIGFzIGFueSkuYW5hbHl6ZURpZmZDaGFuZ2VzKGRpZmZPdXRwdXQpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubmV3RmlsZXMpLnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5tb2RpZmllZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGVsZXRlZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQucmVuYW1lZEZpbGVzKS50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQudG90YWxDaGFuZ2VzKS50b0JlKDApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdhbmFseXplRmlsZVR5cGVzJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNhdGVnb3JpemUgZGlmZmVyZW50IGZpbGUgdHlwZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBkaWZmT3V0cHV0ID0gYGRpZmYgLS1naXQgYS9jb21wb25lbnQudHMgYi9jb21wb25lbnQudHNcbmRpZmYgLS1naXQgYS9jb21wb25lbnQuc3BlYy50cyBiL2NvbXBvbmVudC5zcGVjLnRzXG5kaWZmIC0tZ2l0IGEvdGVtcGxhdGUuaHRtbCBiL3RlbXBsYXRlLmh0bWxcbmRpZmYgLS1naXQgYS9zdHlsZXMuY3NzIGIvc3R5bGVzLmNzc1xuZGlmZiAtLWdpdCBhL2NvbmZpZy5qc29uIGIvY29uZmlnLmpzb25cbmRpZmYgLS1naXQgYS9yZWFkbWUubWQgYi9yZWFkbWUubWRgO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChnaXREaWZmQ29tbWFuZCBhcyBhbnkpLmFuYWx5emVGaWxlVHlwZXMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCdUeXBlU2NyaXB0IGZpbGVzOiAxJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ1Rlc3QgZmlsZXM6IDEnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignVGVtcGxhdGVzOiAxJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ1N0eWxlczogMScpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCdDb25maWcvSlNPTjogMScpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCdPdGhlcjogMScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHByb3ZpZGUgQUkgaW5zaWdodHMgYmFzZWQgb24gZmlsZSB0eXBlcycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGRpZmZPdXRwdXQgPSBgZGlmZiAtLWdpdCBhL2NvbXBvbmVudC5zcGVjLnRzIGIvY29tcG9uZW50LnNwZWMudHNcbmRpZmYgLS1naXQgYS9zZXJ2aWNlLnRzIGIvc2VydmljZS50c1xuZGlmZiAtLWdpdCBhL290aGVyLnRzIGIvb3RoZXIudHNcbmRpZmYgLS1naXQgYS9jb25maWcuanNvbiBiL2NvbmZpZy5qc29uYDtcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoZ2l0RGlmZkNvbW1hbmQgYXMgYW55KS5hbmFseXplRmlsZVR5cGVzKGRpZmZPdXRwdXQpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbign8J+nqiBUZXN0IGZpbGVzIG1vZGlmaWVkJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ+KaoO+4jyAgTW9yZSBzb3VyY2UgZmlsZXMgdGhhbiB0ZXN0IGZpbGVzIGNoYW5nZWQnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbign4pqZ77iPICBDb25maWd1cmF0aW9uIGNoYW5nZXMgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYWRkRmlsZVNlcGFyYXRvcnMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgYWRkIGZpbGUgc2VwYXJhdG9ycyB0byBkaWZmIG91dHB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGRpZmZPdXRwdXQgPSBgZGlmZiAtLWdpdCBhL2ZpbGUxLnRzIGIvZmlsZTEudHNcbmluZGV4IDEyMy4uNDU2XG4tLS0gYS9maWxlMS50c1xuKysrIGIvZmlsZTEudHNcbkBAIC0xICsxLDIgQEBcbiBsaW5lMVxuK2xpbmUyXG5kaWZmIC0tZ2l0IGEvZmlsZTIudHMgYi9maWxlMi50c1xuaW5kZXggNDU2Li43ODlcbi0tLSBhL2ZpbGUyLnRzXG4rKysgYi9maWxlMi50c2A7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGdpdERpZmZDb21tYW5kIGFzIGFueSkuYWRkRmlsZVNlcGFyYXRvcnMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCfwn5OBIEZJTEU6IGZpbGUxLnRzJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0NvbnRhaW4oJ/Cfk4EgRklMRTogZmlsZTIudHMnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbign4pSAJy5yZXBlYXQoNDApKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY291bnRDaGFuZ2VkRmlsZXMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgY291bnQgY2hhbmdlZCBmaWxlcyBmcm9tIHByb2Nlc3NlZCBvdXRwdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBcnJhbmdlXG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBg8J+TgSBGSUxFOiBmaWxlMS50c1xuU29tZSBjb250ZW50XG7wn5OBIEZJTEU6IGZpbGUyLnRzXG5Nb3JlIGNvbnRlbnRcbvCfk4EgRklMRTogZmlsZTMudHNcbkV2ZW4gbW9yZSBjb250ZW50YDtcblxuICAgICAgICAgICAgLy8gQWN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoZ2l0RGlmZkNvbW1hbmQgYXMgYW55KS5jb3VudENoYW5nZWRGaWxlcyhvdXRwdXQpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoMyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDAgZm9yIG91dHB1dCB3aXRob3V0IGZpbGUgbWFya2VycycsICgpID0+IHtcbiAgICAgICAgICAgIC8vIEFycmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9ICdTb21lIGNvbnRlbnQgd2l0aG91dCBmaWxlIG1hcmtlcnMnO1xuXG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChnaXREaWZmQ29tbWFuZCBhcyBhbnkpLmNvdW50Q2hhbmdlZEZpbGVzKG91dHB1dCk7XG5cbiAgICAgICAgICAgIC8vIEFzc2VydFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY3JlYXRlTm9DaGFuZ2VzT3V0cHV0JywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBpbmZvcm1hdGl2ZSBvdXRwdXQgZm9yIG5vIGNoYW5nZXMnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBBY3RcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChnaXREaWZmQ29tbWFuZCBhcyBhbnkpLmNyZWF0ZU5vQ2hhbmdlc091dHB1dCgpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignTm8gY2hhbmdlcyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9Db250YWluKCdXb3JraW5nIGRpcmVjdG9yeTogQ2xlYW4nKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignU3RhZ2VkIGNoYW5nZXM6IE5vbmUnKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQ29udGFpbignQUkgQU5BTFlTSVMgQ09OVEVYVCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZXRDdXJyZW50QnJhbmNoJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBjdXJyZW50IGJyYW5jaCBuYW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gTW9jayB0aGUgZXhlY3V0ZUdpdENvbW1hbmQgbWV0aG9kIGRpcmVjdGx5XG4gICAgICAgICAgICBjb25zdCBtb2NrRXhlY3V0ZUdpdENvbW1hbmQgPSBqZXN0LnNweU9uKGdpdERpZmZDb21tYW5kIGFzIGFueSwgJ2V4ZWN1dGVHaXRDb21tYW5kJyk7XG4gICAgICAgICAgICBtb2NrRXhlY3V0ZUdpdENvbW1hbmQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgXG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSwgXG4gICAgICAgICAgICAgICAgZXhpdENvZGU6IDAsIFxuICAgICAgICAgICAgICAgIG91dHB1dDogJ21haW5cXG4nLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwIFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGdpdERpZmZDb21tYW5kIGFzIGFueSkuZ2V0Q3VycmVudEJyYW5jaCgpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ21haW4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFwidW5rbm93blwiIHdoZW4gZ2l0IGNvbW1hbmQgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBNb2NrIHRoZSBleGVjdXRlR2l0Q29tbWFuZCBtZXRob2QgdG8gcmV0dXJuIGFuIGVycm9yXG4gICAgICAgICAgICBjb25zdCBtb2NrRXhlY3V0ZUdpdENvbW1hbmQgPSBqZXN0LnNweU9uKGdpdERpZmZDb21tYW5kIGFzIGFueSwgJ2V4ZWN1dGVHaXRDb21tYW5kJyk7XG4gICAgICAgICAgICBtb2NrRXhlY3V0ZUdpdENvbW1hbmQubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlOiAxLCBcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICcnLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnTm90IGEgZ2l0IHJlcG9zaXRvcnknLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwIFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEFjdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGdpdERpZmZDb21tYW5kIGFzIGFueSkuZ2V0Q3VycmVudEJyYW5jaCgpO1xuXG4gICAgICAgICAgICAvLyBBc3NlcnRcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3Vua25vd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICAgICAgbW9ja0V4ZWN1dGVHaXRDb21tYW5kLm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=