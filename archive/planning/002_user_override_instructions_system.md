# User Override Instructions System Design

## Overview

The **User Override Instructions** system provides the highest-priority instruction file that allows developers to easily customize, override, or supplement automatically generated Copilot instructions. This ensures developers maintain full control over AI recommendations while benefiting from automated instruction generation.

## File Structure and Priority

### Priority Hierarchy (Highest to Lowest)
1. **`.github/instructions/user-overrides.instructions.md`** (Priority: 1000) ‚¨ÖÔ∏è **NEW**
2. **`.github/instructions/project-specific.instructions.md`** (Priority: 200)
3. **`.github/instructions/angular.instructions.md`** (Priority: 100)
4. **`.github/instructions/typescript.instructions.md`** (Priority: 50)
5. **`.github/copilot-instructions.md`** (Priority: 10)

### User Override File Template

```yaml
---
applyTo: "**/*"
priority: 1000
userOverride: true
lastModified: "2025-01-15T10:30:00Z"
description: "User-customizable instructions that override all automated generations"
---

# User Override Instructions

> **üìù CUSTOMIZATION GUIDE**  
> This file takes precedence over ALL automatically generated instructions.  
> Add your personal coding preferences, project-specific rules, and overrides here.  
> 
> **üîÑ SAFE TO EDIT**: This file is never automatically modified by the AI Debug Context extension.

## Quick Override Examples

### Override Automated Recommendations
```typescript
// ‚ùå AI might suggest: Use signals for state management
// ‚úÖ My preference: Continue using RxJS observables for complex state
// Reason: Team expertise and existing patterns
```

### Custom Naming Conventions
```typescript
// ‚úÖ My project uses specific naming patterns:
// - Services: end with 'Service' (UserService, not UserManager)
// - Components: descriptive names (UserProfileComponent, not ProfileComponent) 
// - Interfaces: start with 'I' prefix (IUser, not User)
```

## üéØ Common Override Scenarios

### Framework Preferences
<!-- Add your framework-specific overrides here -->

### Testing Philosophy  
<!-- Add your testing approach overrides here -->

### Code Style Overrides
<!-- Add your style preference overrides here -->

### Architecture Decisions
<!-- Add your architectural choice overrides here -->

---

## üìã How to Use This File

### 1. **Add Immediate Overrides**
When Copilot suggests something you disagree with:
1. Copy the suggestion here with ‚ùå 
2. Add your preferred approach with ‚úÖ
3. Include a brief reason

### 2. **Document Team Decisions**
Record architectural and style decisions that differ from framework defaults.

### 3. **Create Positive Examples**
Show Copilot exactly how you want code to look in your project.

### 4. **Override Generated Rules**
If automatically generated instructions don't match your workflow, override them here.

---

## üîÑ Maintenance Notes

- **This file is NEVER automatically modified** by the extension
- **Changes take effect immediately** for new Copilot interactions
- **Higher priority** than all other instruction files
- **Safe to version control** and share with team members

---

## üìö Override Categories

### Language & Framework Overrides
<!-- Your language-specific preferences -->

### Testing & Quality Overrides  
<!-- Your testing philosophy and quality standards -->

### Project Architecture Overrides
<!-- Your architectural decisions and patterns -->

### Team Workflow Overrides
<!-- Your team's specific processes and conventions -->

---

## üí° Tips for Effective Overrides

1. **Be Specific**: Include code examples showing exactly what you want
2. **Explain Why**: Brief reasons help Copilot understand context
3. **Use Examples**: Show both ‚ùå avoid and ‚úÖ prefer patterns
4. **Keep Updated**: Remove overrides that are no longer relevant
5. **Share with Team**: Consistent overrides improve team productivity

---

*Generated by AI Debug Context Extension - Safe to customize*
```

## Implementation Strategy

### 1. File Generation and Management

```typescript
class UserOverrideManager {
  private readonly OVERRIDE_FILE_PATH = '.github/instructions/user-overrides.instructions.md';
  
  async ensureOverrideFileExists(workspaceRoot: string): Promise<void> {
    const overridePath = path.join(workspaceRoot, this.OVERRIDE_FILE_PATH);
    
    if (!fs.existsSync(overridePath)) {
      await this.createOverrideFile(overridePath);
      this.showWelcomeMessage();
    }
  }
  
  private async createOverrideFile(filePath: string): Promise<void> {
    const template = this.generateOverrideTemplate();
    await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
    await fs.promises.writeFile(filePath, template, 'utf8');
  }
  
  private showWelcomeMessage(): void {
    vscode.window.showInformationMessage(
      'üìù User Override Instructions created! Customize your Copilot experience.',
      'Open Override File',
      'Learn More'
    ).then(selection => {
      if (selection === 'Open Override File') {
        this.openOverrideFile();
      } else if (selection === 'Learn More') {
        this.showOverrideDocumentation();
      }
    });
  }
}
```

### 2. Priority Integration System

```typescript
class InstructionPriorityManager {
  async loadAllInstructions(workspaceRoot: string): Promise<PrioritizedInstruction[]> {
    const instructionFiles = await this.findInstructionFiles(workspaceRoot);
    const instructions: PrioritizedInstruction[] = [];
    
    for (const file of instructionFiles) {
      const content = await fs.promises.readFile(file.path, 'utf8');
      const parsed = this.parseInstructionFile(content);
      
      instructions.push({
        ...parsed,
        filePath: file.path,
        priority: this.calculateEffectivePriority(parsed, file.path)
      });
    }
    
    // Sort by priority (highest first)
    return instructions.sort((a, b) => b.priority - a.priority);
  }
  
  private calculateEffectivePriority(
    instruction: ParsedInstruction, 
    filePath: string
  ): number {
    // User overrides always get highest priority
    if (filePath.includes('user-overrides.instructions.md')) {
      return 1000;
    }
    
    // Use frontmatter priority or calculate based on specificity
    return instruction.frontmatter.priority ?? this.calculateImplicitPriority(filePath);
  }
}
```

### 3. Interactive Override Creation

```typescript
class InteractiveOverrideCreator {
  async promptForOverride(context: OverrideContext): Promise<void> {
    const suggestion = await vscode.window.showInformationMessage(
      'ü§ñ Copilot suggestion differs from your usual patterns. Create an override?',
      'Create Override',
      'Ignore',
      'Always Ask'
    );
    
    if (suggestion === 'Create Override') {
      await this.launchOverrideWizard(context);
    }
  }
  
  private async launchOverrideWizard(context: OverrideContext): Promise<void> {
    const overrideType = await vscode.window.showQuickPick([
      { label: 'üéØ Specific Rule Override', description: 'Override a specific recommendation' },
      { label: 'üìù Style Preference', description: 'Add a coding style preference' },
      { label: 'üèóÔ∏è Architecture Decision', description: 'Document an architectural choice' },
      { label: '‚úçÔ∏è Custom Pattern', description: 'Add a custom code pattern' }
    ], { placeHolder: 'What type of override would you like to create?' });
    
    if (overrideType) {
      await this.createOverrideEntry(overrideType.label, context);
    }
  }
  
  private async createOverrideEntry(type: string, context: OverrideContext): Promise<void> {
    const template = this.generateOverrideTemplate(type, context);
    
    // Open user-overrides.instructions.md with the new entry
    const document = await vscode.workspace.openTextDocument(
      vscode.Uri.file(context.overrideFilePath)
    );
    
    const editor = await vscode.window.showTextDocument(document);
    
    // Insert template at appropriate location
    await this.insertOverrideTemplate(editor, template);
  }
}
```

### 4. Override Template Generation

```typescript
class OverrideTemplateGenerator {
  generateSpecificRuleOverride(context: CopilotSuggestion): string {
    return `
### Override: ${context.ruleName}

\`\`\`typescript
// ‚ùå Copilot suggested: ${context.suggestion}
// ‚úÖ My preference: ${context.userPreference}
// Reason: ${context.reason}
\`\`\`

**When**: ${context.whenToApply}
**Why**: ${context.justification}

---
`;
  }
  
  generateStylePreference(context: StyleContext): string {
    return `
### Style Preference: ${context.styleName}

\`\`\`typescript
// ‚úÖ My project style:
${context.preferredPattern}

// ‚ùå Avoid:
${context.avoidPattern}
\`\`\`

**Applies to**: ${context.filePatterns.join(', ')}
**Team decision**: ${context.teamDecision}

---
`;
  }
  
  generateArchitecturalDecision(context: ArchitectureContext): string {
    return `
### Architecture Decision: ${context.decisionName}

**Decision**: ${context.decision}
**Status**: ${context.status}
**Date**: ${new Date().toISOString().split('T')[0]}

\`\`\`typescript
// ‚úÖ Our approach:
${context.implementationExample}
\`\`\`

**Rationale**: ${context.rationale}
**Consequences**: ${context.consequences}

---
`;
  }
}
```

## User Experience Flow

### 1. Initial Setup
```typescript
// When extension activates for the first time
async function onFirstActivation(workspaceRoot: string) {
  const overrideManager = new UserOverrideManager();
  await overrideManager.ensureOverrideFileExists(workspaceRoot);
  
  // Show quick start guide
  vscode.window.showInformationMessage(
    'üéâ AI Debug Context is ready! Your personal override file has been created.',
    'View Override File',
    'Quick Tour'
  );
}
```

### 2. During Development
```typescript
// When Copilot makes suggestions that might conflict with user preferences
class CopilotIntegrationMonitor {
  async onCopilotSuggestion(suggestion: CopilotSuggestion) {
    const conflicts = await this.detectPotentialConflicts(suggestion);
    
    if (conflicts.length > 0) {
      this.suggestOverrideCreation(conflicts);
    }
  }
  
  private async detectPotentialConflicts(
    suggestion: CopilotSuggestion
  ): Promise<Conflict[]> {
    // Analyze suggestion against existing user overrides
    // Look for patterns that might conflict with user preferences
    // Suggest creating overrides for common disagreements
  }
}
```

### 3. Override Management Commands

```typescript
// VSCode commands for override management
const commands = [
  {
    command: 'aiDebugContext.openUserOverrides',
    title: 'AI Debug: Open User Override Instructions'
  },
  {
    command: 'aiDebugContext.createQuickOverride', 
    title: 'AI Debug: Create Quick Override'
  },
  {
    command: 'aiDebugContext.validateOverrides',
    title: 'AI Debug: Validate Override Instructions'
  }
];
```

## Override Examples for Common Scenarios

### Framework Preference Overrides

```markdown
### Override: Angular State Management

```typescript
// ‚ùå Generated instruction suggests: Use signals for all component state
// ‚úÖ My preference: Use RxJS observables for complex state, signals for simple values
// Reason: Team has expertise in RxJS and existing complex state patterns

// ‚úÖ Preferred pattern:
@Component({...})
export class UserComponent {
  // Simple state - use signals
  loading = signal(false);
  
  // Complex state - use observables
  userProfile$ = this.userService.getProfile().pipe(
    shareReplay(1),
    catchError(this.handleError)
  );
}
```

**When**: Working with component state management
**Why**: Team expertise and existing codebase patterns
```

### Testing Philosophy Overrides

```markdown
### Override: Test Structure

```typescript
// ‚ùå Generated instruction suggests: Use describe blocks for all test organization
// ‚úÖ My preference: Flat test structure with descriptive test names

// ‚úÖ Preferred pattern:
it('should calculate user discount when user has premium membership and order exceeds minimum', () => {
  // Test implementation
});

it('should throw error when user discount calculation fails due to invalid membership', () => {
  // Test implementation  
});

// ‚ùå Avoid nested describe blocks:
describe('UserService', () => {
  describe('calculateDiscount', () => {
    describe('when user has premium membership', () => {
      it('should apply discount', () => {});
    });
  });
});
```

**Applies to**: `**/*.spec.ts`, `**/*.test.ts`
**Team decision**: Flat structure improves test readability and reduces nesting complexity
```

### Architecture Decision Overrides

```markdown
### Architecture Decision: Error Handling Strategy

**Decision**: Use custom error classes with specific error codes rather than generic Error objects
**Status**: Approved
**Date**: 2025-01-15

```typescript
// ‚úÖ Our approach:
export class UserNotFoundError extends Error {
  constructor(userId: string) {
    super(`User with ID ${userId} not found`);
    this.name = 'UserNotFoundError';
    this.code = 'USER_NOT_FOUND';
  }
}

// Service usage:
async getUser(id: string): Promise<User> {
  const user = await this.repository.findById(id);
  if (!user) {
    throw new UserNotFoundError(id);
  }
  return user;
}
```

**Rationale**: Specific error types enable better error handling and monitoring
**Consequences**: Requires custom error classes but improves debugging and error tracking
```

## Integration with Phase 3.5.0

### 1. Override File Creation
- **Generated automatically** when extension first runs
- **Never modified** by automated generation
- **Includes helpful templates** and examples

### 2. Priority System Integration
```typescript
class InstructionGenerator {
  async generateInstructions(workspaceRoot: string): Promise<void> {
    // 1. Always ensure user override file exists
    await this.userOverrideManager.ensureOverrideFileExists(workspaceRoot);
    
    // 2. Generate automated instructions
    const generatedInstructions = await this.generateFrameworkInstructions();
    
    // 3. Load user overrides for conflict detection
    const userOverrides = await this.loadUserOverrides(workspaceRoot);
    
    // 4. Apply conflict resolution and warnings
    await this.resolveInstructionConflicts(generatedInstructions, userOverrides);
  }
}
```

### 3. User Education and Onboarding
```typescript
class UserOnboarding {
  async showOverrideIntroduction(): Promise<void> {
    const panel = vscode.window.createWebviewPanel(
      'overrideIntro',
      'Customize Your Copilot Instructions',
      vscode.ViewColumn.One,
      { enableScripts: true }
    );
    
    panel.webview.html = this.getOverrideIntroHTML();
  }
  
  private getOverrideIntroHTML(): string {
    return `
      <h1>üéØ Take Control of Your Copilot Instructions</h1>
      <p>Your personal override file lets you:</p>
      <ul>
        <li>Override any automated recommendation</li>
        <li>Add project-specific coding standards</li>
        <li>Document architectural decisions</li>
        <li>Customize Copilot to match your workflow</li>
      </ul>
    `;
  }
}
```

## Benefits of This Approach

### 1. **Developer Autonomy**
- Complete control over Copilot behavior
- Easy to add personal preferences
- No risk of automated modifications

### 2. **Conflict Resolution**
- Clear priority system prevents confusion
- User always wins over automated generation
- Transparent hierarchy

### 3. **Team Collaboration**
- Shareable via version control
- Documents team decisions
- Consistent overrides across team

### 4. **Learning and Adaptation**
- Extension can learn from override patterns
- Future generations can consider user preferences
- Continuous improvement of automated suggestions

This user override system ensures that Phase 3.5.0 respects developer preferences while providing the benefits of automated instruction generation, creating a perfect balance between automation and customization.

## Related Documentation

- [Phase 3.5.0 Implementation Plan](../planning/001_phase_3_5_0_final_determination.md) - Complete implementation strategy
- [Current Implementation Status](../implementation/current_status.md) - Project progress and next steps
