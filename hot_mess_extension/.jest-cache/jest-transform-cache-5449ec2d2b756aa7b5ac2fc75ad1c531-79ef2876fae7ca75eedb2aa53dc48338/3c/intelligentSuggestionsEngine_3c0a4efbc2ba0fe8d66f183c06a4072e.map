{"file":"/Users/gregdunn/src/test/ai_debug_context/vscode/src/services/ai-insights/engines/intelligentSuggestionsEngine.ts","mappings":";;;AAYA;;;GAGG;AACH,MAAa,4BAA4B;IAMjB;IALZ,eAAe,GAAgC,IAAI,GAAG,EAAE,CAAC;IACzD,iBAAiB,GAAkC,IAAI,GAAG,EAAE,CAAC;IAC7D,cAAc,GAA0B,EAAE,CAAC;IAClC,cAAc,GAAG,IAAI,CAAC;IAEvC,YAAoB,OAAgC;QAAhC,YAAO,GAAP,OAAO,CAAyB;QAChD,IAAI,CAAC,yBAAyB,EAAE,CAAC;QACjC,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAClC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,8BAA8B,CAAC,OAAyB;QAC1D,MAAM,WAAW,GAAwB,EAAE,CAAC;QAE5C,IAAI,CAAC;YACD,uCAAuC;YACvC,MAAM,gBAAgB,GAAG,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC,CAAC;YAChE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,gBAAgB,CAAC,CAAC;YACnE,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,qBAAqB,CAAC,OAAO,CAAC,CAAC;YAE9D,4BAA4B;YAC5B,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;YAEpE,kDAAkD;YAClD,KAAK,MAAM,UAAU,IAAI,eAAe,EAAE,CAAC;gBACvC,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,6BAA6B,CAC/D,UAAU,EACV,QAAQ,EACR,WAAW,CACd,CAAC;gBACF,WAAW,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACzC,CAAC;YAED,kCAAkC;YAClC,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,+BAA+B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACzF,WAAW,CAAC,IAAI,CAAC,GAAG,kBAAkB,CAAC,CAAC;YAExC,wDAAwD;YACxD,MAAM,oBAAoB,GAAG,MAAM,IAAI,CAAC,4BAA4B,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAC3F,WAAW,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,CAAC;YAE1C,mCAAmC;YACnC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACtB,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;gBACzD,MAAM,MAAM,GAAG,IAAI,CAAC,wBAAwB,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;gBACzD,OAAO,MAAM,GAAG,MAAM,CAAC;YAC3B,CAAC,CAAC,CAAC;YAEH,8BAA8B;YAC9B,IAAI,CAAC,wBAAwB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;YAEpD,OAAO,CAAC,GAAG,CAAC,aAAa,WAAW,CAAC,MAAM,0BAA0B,CAAC,CAAC;YACvE,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,2BAA2B;QAE/D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,OAAO,CAAC,KAAK,CAAC,2CAA2C,EAAE,KAAK,CAAC,CAAC;YAClE,OAAO,EAAE,CAAC;QACd,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,wBAAwB,CAAC,UAA8B;QACzD,MAAM,QAAQ,GAAqB,EAAE,CAAC;QAEtC,IAAI,CAAC;YACD,yCAAyC;YACzC,MAAM,aAAa,GAAG,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;YAEhE,KAAK,MAAM,CAAC,gBAAgB,EAAE,eAAe,CAAC,IAAI,aAAa,CAAC,OAAO,EAAE,EAAE,CAAC;gBACxE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,EAAE,eAAe,CAAC,CAAC;gBAC7E,IAAI,OAAO,CAAC,UAAU,GAAG,GAAG,EAAE,CAAC;oBAC3B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;oBACvB,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;gBAClD,CAAC;YACL,CAAC;YAED,4BAA4B;YAC5B,MAAM,IAAI,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC;YAE/C,OAAO,CAAC,GAAG,CAAC,YAAY,UAAU,CAAC,MAAM,sBAAsB,QAAQ,CAAC,MAAM,WAAW,CAAC,CAAC;YAC3F,OAAO,QAAQ,CAAC;QAEpB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,OAAO,CAAC,KAAK,CAAC,qCAAqC,EAAE,KAAK,CAAC,CAAC;YAC5D,OAAO,EAAE,CAAC;QACd,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,qBAAqB,CAAC,OAAyB;QACjD,MAAM,WAAW,GAAG,IAAI,GAAG,EAA6B,CAAC;QAEzD,IAAI,CAAC;YACD,MAAM,QAAQ,GAAG,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,eAAe,CAAC,CAAC;YAEnE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;gBAC7B,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,2BAA2B,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBAC5E,WAAW,CAAC,GAAG,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;YACzC,CAAC;YAED,OAAO,WAAW,CAAC;QAEvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,OAAO,CAAC,KAAK,CAAC,mCAAmC,EAAE,KAAK,CAAC,CAAC;YAC1D,OAAO,IAAI,GAAG,EAAE,CAAC;QACrB,CAAC;IACL,CAAC;IAED,iCAAiC;IAEzB,yBAAyB;QAC7B,kCAAkC;QAClC,MAAM,cAAc,GAAqB;YACrC;gBACI,EAAE,EAAE,0BAA0B;gBAC9B,IAAI,EAAE,0BAA0B;gBAChC,WAAW,EAAE,qCAAqC;gBAClD,gBAAgB,EAAE,iBAAiB;gBACnC,eAAe,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,QAAQ,CAAC;gBAChD,WAAW,EAAE,IAAI;gBACjB,UAAU,EAAE,GAAG;gBACf,UAAU,EAAE;oBACR,UAAU,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE;oBAC7B,SAAS,EAAE,EAAE,qBAAqB,EAAE,IAAI,EAAE;iBAC7C;gBACD,QAAQ,EAAE;oBACN,oBAAoB,EAAE,IAAI;oBAC1B,iBAAiB,EAAE,IAAI;oBACvB,YAAY,EAAE,IAAI;iBACrB;gBACD,WAAW,EAAE,IAAI,IAAI,EAAE;gBACvB,UAAU,EAAE,CAAC;aAChB;YACD;gBACI,EAAE,EAAE,uBAAuB;gBAC3B,IAAI,EAAE,uBAAuB;gBAC7B,WAAW,EAAE,+CAA+C;gBAC5D,gBAAgB,EAAE,mCAAmC;gBACrD,eAAe,EAAE,CAAC,QAAQ,EAAE,SAAS,EAAE,eAAe,CAAC;gBACvD,WAAW,EAAE,IAAI;gBACjB,UAAU,EAAE,IAAI;gBAChB,UAAU,EAAE;oBACR,UAAU,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE;oBAC7B,SAAS,EAAE,EAAE,qBAAqB,EAAE,IAAI,EAAE;iBAC7C;gBACD,QAAQ,EAAE;oBACN,oBAAoB,EAAE,IAAI;oBAC1B,iBAAiB,EAAE,IAAI;oBACvB,YAAY,EAAE,IAAI;iBACrB;gBACD,WAAW,EAAE,IAAI,IAAI,EAAE;gBACvB,UAAU,EAAE,CAAC;aAChB;SACJ,CAAC;QAEF,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;YAC7B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,sBAAsB;QAChC,IAAI,CAAC;YACD,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAS,sBAAsB,CAAC,CAAC;YACpF,IAAI,cAAc,EAAE,CAAC;gBACjB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAqB,CAAC;gBAChE,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBACvB,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;gBAClD,CAAC,CAAC,CAAC;gBACH,OAAO,CAAC,GAAG,CAAC,UAAU,QAAQ,CAAC,MAAM,sBAAsB,CAAC,CAAC;YACjE,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,OAAO,CAAC,KAAK,CAAC,oCAAoC,EAAE,KAAK,CAAC,CAAC;QAC/D,CAAC;IACL,CAAC;IAEO,wBAAwB,CAAC,OAAyB;QACtD,MAAM,KAAK,GAAG;YACV,WAAW,OAAO,CAAC,OAAO,EAAE;YAC5B,SAAS,OAAO,CAAC,YAAY,CAAC,MAAM,EAAE;YACtC,SAAS,OAAO,CAAC,UAAU,CAAC,OAAO,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,EAAE;YACnE,OAAO,OAAO,CAAC,SAAS,CAAC,qBAAqB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,EAAE;YACpE,UAAU,OAAO,CAAC,SAAS,CAAC,MAAM,EAAE;YACpC,UAAU,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE;SAC5C,CAAC;QAEF,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,oBAAoB,CAAC,gBAAwB;QACvD,MAAM,OAAO,GAAqB,EAAE,CAAC;QAErC,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,EAAE,CAAC;YAClD,MAAM,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,gBAAgB,EAAE,OAAO,CAAC,gBAAgB,CAAC,CAAC;YAC/F,IAAI,UAAU,GAAG,GAAG,EAAE,CAAC;gBACnB,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,OAAO,EAAE,UAAU,EAAE,OAAO,CAAC,UAAU,GAAG,UAAU,EAAE,CAAC,CAAC;YAC9E,CAAC;QACL,CAAC;QAED,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC;IAC/D,CAAC;IAEO,0BAA0B,CAAC,UAAkB,EAAE,UAAkB;QACrE,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACrC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAErC,IAAI,OAAO,GAAG,CAAC,CAAC;QAChB,IAAI,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAEnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YAC9D,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC;gBACrD,OAAO,EAAE,CAAC;YACd,CAAC;QACL,CAAC;QAED,OAAO,OAAO,GAAG,KAAK,CAAC;IAC3B,CAAC;IAEO,KAAK,CAAC,uBAAuB,CAAC,OAAyB;QAC3D,MAAM,WAAW,GAAwB,EAAE,CAAC;QAE5C,2BAA2B;QAC3B,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC;YACjC,WAAW,CAAC,IAAI,CAAC;gBACb,OAAO,EAAE,QAAQ;gBACjB,MAAM,EAAE,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,oBAAoB;gBACzD,UAAU,EAAE,GAAG;gBACf,eAAe,EAAE,MAAM;gBACvB,OAAO,EAAE;oBACL,OAAO,EAAE,eAAe;oBACxB,YAAY,EAAE,OAAO,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;oBAC/D,eAAe,EAAE,CAAC,0BAA0B,CAAC;iBAChD;gBACD,OAAO,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE;aAC9B,CAAC,CAAC;QACP,CAAC;QAED,0BAA0B;QAC1B,IAAI,OAAO,CAAC,SAAS,CAAC,qBAAqB,EAAE,CAAC;YAC1C,WAAW,CAAC,IAAI,CAAC;gBACb,OAAO,EAAE,SAAS;gBAClB,MAAM,EAAE,4BAA4B;gBACpC,UAAU,EAAE,GAAG;gBACf,eAAe,EAAE,QAAQ;gBACzB,OAAO,EAAE;oBACL,OAAO,EAAE,qBAAqB;oBAC9B,YAAY,EAAE,OAAO,CAAC,SAAS,CAAC,YAAY;oBAC5C,eAAe,EAAE,CAAC,uBAAuB,CAAC;iBAC7C;aACJ,CAAC,CAAC;QACP,CAAC;QAED,0BAA0B;QAC1B,IAAI,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,SAAS;YAC/D,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,GAAG,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC;YAC9D,WAAW,CAAC,IAAI,CAAC;gBACb,OAAO,EAAE,SAAS;gBAClB,MAAM,EAAE,gDAAgD;gBACxD,UAAU,EAAE,GAAG;gBACf,eAAe,EAAE,QAAQ;gBACzB,OAAO,EAAE;oBACL,OAAO,EAAE,qBAAqB;oBAC9B,YAAY,EAAE,OAAO,CAAC,YAAY;oBAClC,eAAe,EAAE,CAAC,0BAA0B,CAAC;iBAChD;gBACD,OAAO,EAAE,EAAE,KAAK,EAAE,aAAa,EAAE;aACpC,CAAC,CAAC;QACP,CAAC;QAED,OAAO,WAAW,CAAC;IACvB,CAAC;IAEO,KAAK,CAAC,6BAA6B,CACvC,UAA6B,EAC7B,QAA0B,EAC1B,WAA2C;QAE3C,MAAM,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CACzC,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC,OAAO,CAAC,CACjD,CAAC;QAEF,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9B,MAAM,WAAW,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC;YACxC,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAC5B,UAAU,CAAC,UAAU,GAAG,GAAG,EAC3B,UAAU,CAAC,UAAU,GAAG,CAAC,WAAW,CAAC,WAAW,GAAG,GAAG,CAAC,CAC1D,CAAC;YACF,UAAU,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QAC5D,CAAC;QAED,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QACvD,IAAI,UAAU,EAAE,CAAC;YACb,UAAU,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAC5B,UAAU,CAAC,UAAU,GAAG,UAAU,CAAC,WAAW,EAC9C,IAAI,CACP,CAAC;QACN,CAAC;QAED,OAAO,UAAU,CAAC;IACtB,CAAC;IAEO,KAAK,CAAC,+BAA+B,CACzC,QAA0B,EAC1B,OAAyB;QAEzB,MAAM,WAAW,GAAwB,EAAE,CAAC;QAE5C,KAAK,MAAM,OAAO,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;YACzC,IAAI,OAAO,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrC,MAAM,WAAW,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;gBAC/C,WAAW,CAAC,IAAI,CAAC;oBACb,OAAO,EAAE,WAAkB;oBAC3B,MAAM,EAAE,kBAAkB,OAAO,CAAC,WAAW,EAAE;oBAC/C,UAAU,EAAE,OAAO,CAAC,UAAU,GAAG,GAAG;oBACpC,eAAe,EAAE,OAAO,CAAC,WAAW,GAAG,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ;oBAC9D,OAAO,EAAE;wBACL,OAAO,EAAE,eAAe;wBACxB,YAAY,EAAE,OAAO,CAAC,YAAY;wBAClC,eAAe,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC;qBAChC;iBACJ,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED,OAAO,WAAW,CAAC;IACvB,CAAC;IAEO,KAAK,CAAC,4BAA4B,CACtC,OAAyB,EACzB,WAA2C;QAE3C,MAAM,WAAW,GAAwB,EAAE,CAAC;QAE5C,+DAA+D;QAC/D,MAAM,WAAW,GAAG,OAAO,CAAC,cAAc;aACrC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,KAAK,QAAQ,CAAC;aACtC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtE,IAAI,CAAC,WAAW;YACZ,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,CAAC,SAAS;YACrE,WAAW,CAAC,IAAI,CAAC;gBACb,OAAO,EAAE,QAAQ;gBACjB,MAAM,EAAE,6CAA6C;gBACrD,UAAU,EAAE,GAAG;gBACf,eAAe,EAAE,QAAQ;gBACzB,OAAO,EAAE;oBACL,OAAO,EAAE,mBAAmB;oBAC5B,YAAY,EAAE,OAAO,CAAC,YAAY;oBAClC,eAAe,EAAE,CAAC,yBAAyB,CAAC;iBAC/C;aACJ,CAAC,CAAC;QACP,CAAC;QAED,OAAO,WAAW,CAAC;IACvB,CAAC;IAEO,wBAAwB,CAAC,UAA6B,EAAE,OAAyB;QACrF,IAAI,KAAK,GAAG,UAAU,CAAC,UAAU,CAAC;QAElC,8BAA8B;QAC9B,MAAM,gBAAgB,GAAG;YACrB,MAAM,EAAE,GAAG;YACX,QAAQ,EAAE,GAAG;YACb,KAAK,EAAE,GAAG;SACb,CAAC;QACF,KAAK,IAAI,gBAAgB,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;QAEtD,yCAAyC;QACzC,IAAI,UAAU,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC7C,KAAK,IAAI,GAAG,CAAC;QACjB,CAAC;QAED,IAAI,UAAU,CAAC,OAAO,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAChD,KAAK,IAAI,GAAG,CAAC;QACjB,CAAC;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEO,wBAAwB,CAAC,UAA8B;QAC3D,MAAM,MAAM,GAAG,IAAI,GAAG,EAA8B,CAAC;QAErD,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE,CAAC;YACjC,4CAA4C;YAC5C,MAAM,SAAS,GAAG,GAAG,SAAS,CAAC,OAAO,IAAI,SAAS,CAAC,MAAM,EAAE,CAAC;YAE7D,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC;gBACzB,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YAC9B,CAAC;YACD,MAAM,CAAC,GAAG,CAAC,SAAS,CAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC3C,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,KAAK,CAAC,cAAc,CACxB,gBAAwB,EACxB,UAA8B;QAE9B,MAAM,oBAAoB,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,WAAW,CAAC,CAAC;QAC9E,MAAM,WAAW,GAAG,oBAAoB,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;QAEpE,OAAO;YACH,EAAE,EAAE,WAAW,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;YACtE,IAAI,EAAE,yBAAyB,gBAAgB,EAAE;YACjD,WAAW,EAAE,0BAA0B,UAAU,CAAC,MAAM,aAAa;YACrE,gBAAgB;YAChB,eAAe,EAAE,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC;YAC9C,WAAW;YACX,UAAU,EAAE,IAAI,CAAC,GAAG,CAAC,WAAW,GAAG,GAAG,EAAE,IAAI,CAAC;YAC7C,UAAU,EAAE,EAAE;YACd,QAAQ,EAAE;gBACN,oBAAoB,EAAE,WAAW;gBACjC,iBAAiB,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,WAAW,GAAG,GAAG,CAAC;gBACrD,YAAY,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;aACjC;YACD,WAAW,EAAE,IAAI,IAAI,EAAE;YACvB,UAAU,EAAE,UAAU,CAAC,MAAM;SAChC,CAAC;IACN,CAAC;IAEO,KAAK,CAAC,uBAAuB,CAAC,UAA8B;QAChE,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE,CAAC;YACjC,MAAM,YAAY,GAAG,GAAG,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,OAAO,EAAE,CAAC;YAEhE,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC;gBAC5C,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,EAAE;oBACrC,OAAO,EAAE,SAAS,CAAC,MAAM;oBACzB,OAAO,EAAE,SAAS,CAAC,OAAO;oBAC1B,YAAY,EAAE,CAAC;oBACf,UAAU,EAAE,CAAC;oBACb,WAAW,EAAE,IAAI,IAAI,EAAE;iBAC1B,CAAC,CAAC;YACP,CAAC;YAED,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAE,CAAC;YAC5D,SAAS,CAAC,UAAU,EAAE,CAAC;YACvB,IAAI,SAAS,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC;gBACnC,SAAS,CAAC,YAAY,EAAE,CAAC;YAC7B,CAAC;YACD,SAAS,CAAC,WAAW,GAAG,IAAI,IAAI,EAAE,CAAC;QACvC,CAAC;IACL,CAAC;IAEO,KAAK,CAAC,2BAA2B,CACrC,OAAe,EACf,OAAyB;QAEzB,MAAM,YAAY,GAAG,GAAG,OAAO,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;QACrD,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAE3D,IAAI,eAAe,GAAG,GAAG,CAAC,CAAC,sBAAsB;QAEjD,IAAI,SAAS,IAAI,SAAS,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC;YACxC,eAAe,GAAG,SAAS,CAAC,YAAY,GAAG,SAAS,CAAC,UAAU,CAAC;QACpE,CAAC;QAED,sCAAsC;QACtC,IAAI,mBAAmB,GAAG,eAAe,CAAC;QAE1C,sDAAsD;QACtD,IAAI,OAAO,KAAK,QAAQ,IAAI,OAAO,CAAC,UAAU,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC;YACzD,mBAAmB,IAAI,GAAG,CAAC;QAC/B,CAAC;QAED,+CAA+C;QAC/C,IAAI,OAAO,KAAK,eAAe,IAAI,OAAO,CAAC,SAAS,CAAC,qBAAqB,EAAE,CAAC;YACzE,mBAAmB,IAAI,GAAG,CAAC;QAC/B,CAAC;QAED,OAAO;YACH,WAAW,EAAE,mBAAmB;YAChC,OAAO,EAAE;gBACL,4BAA4B,CAAC,eAAe,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG;gBACjE,6BAA6B;aAChC;YACD,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,UAAU,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;SACvE,CAAC;IACN,CAAC;IAEO,wBAAwB,CAAC,OAAyB,EAAE,WAAgC;QACxF,MAAM,KAAK,GAAwB;YAC/B,gBAAgB,EAAE,IAAI,CAAC,wBAAwB,CAAC,OAAO,CAAC;YACxD,SAAS,EAAE,IAAI,IAAI,EAAE;YACrB,WAAW,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC;YACrF,OAAO,EAAE;gBACL,OAAO,EAAE,OAAO,CAAC,OAAO;gBACxB,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,SAAS,EAAE,OAAO,CAAC,SAAS;gBAC5B,SAAS,EAAE,OAAO,CAAC,YAAY,CAAC,MAAM;aACzC;SACJ,CAAC;QAEF,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEhC,qBAAqB;QACrB,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YACnD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1E,CAAC;IACL,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,YAAY;QACd,IAAI,CAAC;YACD,MAAM,QAAQ,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;YAC3D,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,MAAM,CACjC,sBAAsB,EACtB,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAC3B,CAAC;YACF,OAAO,CAAC,GAAG,CAAC,SAAS,QAAQ,CAAC,MAAM,sBAAsB,CAAC,CAAC;QAChE,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,OAAO,CAAC,KAAK,CAAC,wBAAwB,EAAE,KAAK,CAAC,CAAC;QACnD,CAAC;IACL,CAAC;IAED,OAAO;QACH,IAAI,CAAC,YAAY,EAAE,CAAC;QACpB,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QAC7B,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;IAC7B,CAAC;CACJ;AAlhBD,oEAkhBC","names":[],"sources":["/Users/gregdunn/src/test/ai_debug_context/vscode/src/services/ai-insights/engines/intelligentSuggestionsEngine.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport { \n    CommandSuggestion, \n    ExecutionContext, \n    CommandExecution,\n    AnalysisData,\n    PredictionResult,\n    TestResult,\n    GitStatus,\n    ErrorPattern\n} from '../../../types';\n\n/**\n * Enhanced Intelligent Command Suggestions Engine for Phase 4.2\n * Provides context-aware, pattern-based command recommendations with ML-like insights\n */\nexport class IntelligentSuggestionsEngine {\n    private patternDatabase: Map<string, CommandPattern> = new Map();\n    private successPredictors: Map<string, SuccessPredictor> = new Map();\n    private contextHistory: ContextHistoryEntry[] = [];\n    private readonly maxHistorySize = 1000;\n\n    constructor(private context: vscode.ExtensionContext) {\n        this.initializePatternDatabase();\n        this.loadHistoricalPatterns();\n    }\n\n    /**\n     * Generate intelligent command suggestions based on current context\n     * Enhanced with pattern recognition and success prediction\n     */\n    async generateIntelligentSuggestions(context: ExecutionContext): Promise<CommandSuggestion[]> {\n        const suggestions: CommandSuggestion[] = [];\n        \n        try {\n            // Phase 4.2: Enhanced context analysis\n            const contextSignature = this.generateContextSignature(context);\n            const patterns = await this.findMatchingPatterns(contextSignature);\n            const predictions = await this.predictCommandSuccess(context);\n            \n            // Generate base suggestions\n            const baseSuggestions = await this.generateBaseSuggestions(context);\n            \n            // Enhance suggestions with pattern-based insights\n            for (const suggestion of baseSuggestions) {\n                const enhancedSuggestion = await this.enhanceSuggestionWithPatterns(\n                    suggestion, \n                    patterns, \n                    predictions\n                );\n                suggestions.push(enhancedSuggestion);\n            }\n            \n            // Add pattern-derived suggestions\n            const patternSuggestions = await this.generatePatternBasedSuggestions(patterns, context);\n            suggestions.push(...patternSuggestions);\n            \n            // Add proactive suggestions based on failure prediction\n            const proactiveSuggestions = await this.generateProactiveSuggestions(context, predictions);\n            suggestions.push(...proactiveSuggestions);\n            \n            // Sort by confidence and relevance\n            suggestions.sort((a, b) => {\n                const scoreA = this.calculateSuggestionScore(a, context);\n                const scoreB = this.calculateSuggestionScore(b, context);\n                return scoreB - scoreA;\n            });\n            \n            // Record context for learning\n            this.recordContextForLearning(context, suggestions);\n            \n            console.log(`Generated ${suggestions.length} intelligent suggestions`);\n            return suggestions.slice(0, 8); // Return top 8 suggestions\n            \n        } catch (error) {\n            console.error('Error generating intelligent suggestions:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Analyze command execution patterns to improve future suggestions\n     */\n    async analyzeExecutionPatterns(executions: CommandExecution[]): Promise<CommandPattern[]> {\n        const patterns: CommandPattern[] = [];\n        \n        try {\n            // Group executions by context similarity\n            const contextGroups = this.groupExecutionsByContext(executions);\n            \n            for (const [contextSignature, groupExecutions] of contextGroups.entries()) {\n                const pattern = await this.extractPattern(contextSignature, groupExecutions);\n                if (pattern.confidence > 0.5) {\n                    patterns.push(pattern);\n                    this.patternDatabase.set(pattern.id, pattern);\n                }\n            }\n            \n            // Update success predictors\n            await this.updateSuccessPredictors(executions);\n            \n            console.log(`Analyzed ${executions.length} executions, found ${patterns.length} patterns`);\n            return patterns;\n            \n        } catch (error) {\n            console.error('Error analyzing execution patterns:', error);\n            return [];\n        }\n    }\n\n    /**\n     * Predict likelihood of command success based on current context\n     */\n    async predictCommandSuccess(context: ExecutionContext): Promise<Map<string, SuccessPrediction>> {\n        const predictions = new Map<string, SuccessPrediction>();\n        \n        try {\n            const commands = ['aiDebug', 'nxTest', 'gitDiff', 'prepareToPush'];\n            \n            for (const command of commands) {\n                const prediction = await this.calculateSuccessProbability(command, context);\n                predictions.set(command, prediction);\n            }\n            \n            return predictions;\n            \n        } catch (error) {\n            console.error('Error predicting command success:', error);\n            return new Map();\n        }\n    }\n\n    // Private implementation methods\n\n    private initializePatternDatabase(): void {\n        // Initialize with common patterns\n        const commonPatterns: CommandPattern[] = [\n            {\n                id: 'test-failure-debug-cycle',\n                name: 'Test Failure Debug Cycle',\n                description: 'Pattern for debugging failing tests',\n                contextSignature: 'failing-tests-*',\n                commandSequence: ['nxTest', 'aiDebug', 'nxTest'],\n                successRate: 0.85,\n                confidence: 0.9,\n                conditions: {\n                    testStatus: { failing: '>0' },\n                    gitStatus: { hasUncommittedChanges: true }\n                },\n                outcomes: {\n                    successfulResolution: 0.85,\n                    partialResolution: 0.12,\n                    noResolution: 0.03\n                },\n                lastUpdated: new Date(),\n                usageCount: 0\n            },\n            {\n                id: 'pre-commit-validation',\n                name: 'Pre-commit Validation',\n                description: 'Complete validation before committing changes',\n                contextSignature: 'uncommitted-changes-passing-tests',\n                commandSequence: ['nxTest', 'aiDebug', 'prepareToPush'],\n                successRate: 0.92,\n                confidence: 0.95,\n                conditions: {\n                    testStatus: { failing: '=0' },\n                    gitStatus: { hasUncommittedChanges: true }\n                },\n                outcomes: {\n                    successfulResolution: 0.92,\n                    partialResolution: 0.06,\n                    noResolution: 0.02\n                },\n                lastUpdated: new Date(),\n                usageCount: 0\n            }\n        ];\n\n        commonPatterns.forEach(pattern => {\n            this.patternDatabase.set(pattern.id, pattern);\n        });\n    }\n\n    private async loadHistoricalPatterns(): Promise<void> {\n        try {\n            const historicalData = this.context.globalState.get<string>('ai-insights-patterns');\n            if (historicalData) {\n                const patterns = JSON.parse(historicalData) as CommandPattern[];\n                patterns.forEach(pattern => {\n                    this.patternDatabase.set(pattern.id, pattern);\n                });\n                console.log(`Loaded ${patterns.length} historical patterns`);\n            }\n        } catch (error) {\n            console.error('Error loading historical patterns:', error);\n        }\n    }\n\n    private generateContextSignature(context: ExecutionContext): string {\n        const parts = [\n            `project:${context.project}`,\n            `files:${context.currentFiles.length}`,\n            `tests:${context.testStatus.failing}/${context.testStatus.passing}`,\n            `git:${context.gitStatus.hasUncommittedChanges ? 'dirty' : 'clean'}`,\n            `branch:${context.gitStatus.branch}`,\n            `recent:${context.recentCommands.length}`\n        ];\n        \n        return parts.join('|');\n    }\n\n    private async findMatchingPatterns(contextSignature: string): Promise<CommandPattern[]> {\n        const matches: CommandPattern[] = [];\n        \n        for (const pattern of this.patternDatabase.values()) {\n            const similarity = this.calculateContextSimilarity(contextSignature, pattern.contextSignature);\n            if (similarity > 0.6) {\n                matches.push({ ...pattern, confidence: pattern.confidence * similarity });\n            }\n        }\n        \n        return matches.sort((a, b) => b.confidence - a.confidence);\n    }\n\n    private calculateContextSimilarity(signature1: string, signature2: string): number {\n        const parts1 = signature1.split('|');\n        const parts2 = signature2.split('|');\n        \n        let matches = 0;\n        let total = Math.max(parts1.length, parts2.length);\n        \n        for (let i = 0; i < Math.min(parts1.length, parts2.length); i++) {\n            if (parts1[i] === parts2[i] || parts2[i].includes('*')) {\n                matches++;\n            }\n        }\n        \n        return matches / total;\n    }\n\n    private async generateBaseSuggestions(context: ExecutionContext): Promise<CommandSuggestion[]> {\n        const suggestions: CommandSuggestion[] = [];\n        \n        // Test-related suggestions\n        if (context.testStatus.failing > 0) {\n            suggestions.push({\n                command: 'nxTest',\n                reason: `${context.testStatus.failing} tests are failing`,\n                confidence: 0.9,\n                estimatedImpact: 'high',\n                context: {\n                    trigger: 'test-failures',\n                    relatedFiles: context.testStatus.failingTests.map(t => t.suite),\n                    similarPatterns: ['test-failure-debug-cycle']\n                },\n                options: { focus: 'tests' }\n            });\n        }\n        \n        // Git-related suggestions\n        if (context.gitStatus.hasUncommittedChanges) {\n            suggestions.push({\n                command: 'gitDiff',\n                reason: 'Review uncommitted changes',\n                confidence: 0.8,\n                estimatedImpact: 'medium',\n                context: {\n                    trigger: 'uncommitted-changes',\n                    relatedFiles: context.gitStatus.changedFiles,\n                    similarPatterns: ['change-review-pattern']\n                }\n            });\n        }\n        \n        // Performance suggestions\n        if (context.recentCommands.some(cmd => cmd.endTime && cmd.startTime && \n            (cmd.endTime.getTime() - cmd.startTime.getTime()) > 300000)) {\n            suggestions.push({\n                command: 'aiDebug',\n                reason: 'Recent commands were slow, analyze performance',\n                confidence: 0.7,\n                estimatedImpact: 'medium',\n                context: {\n                    trigger: 'performance-concern',\n                    relatedFiles: context.currentFiles,\n                    similarPatterns: ['performance-optimization']\n                },\n                options: { focus: 'performance' }\n            });\n        }\n        \n        return suggestions;\n    }\n\n    private async enhanceSuggestionWithPatterns(\n        suggestion: CommandSuggestion, \n        patterns: CommandPattern[], \n        predictions: Map<string, SuccessPrediction>\n    ): Promise<CommandSuggestion> {\n        const relevantPatterns = patterns.filter(p => \n            p.commandSequence.includes(suggestion.command)\n        );\n        \n        if (relevantPatterns.length > 0) {\n            const bestPattern = relevantPatterns[0];\n            suggestion.confidence = Math.min(\n                suggestion.confidence * 1.2, \n                suggestion.confidence + (bestPattern.successRate * 0.3)\n            );\n            suggestion.context.similarPatterns.push(bestPattern.id);\n        }\n        \n        const prediction = predictions.get(suggestion.command);\n        if (prediction) {\n            suggestion.confidence = Math.min(\n                suggestion.confidence * prediction.probability,\n                0.95\n            );\n        }\n        \n        return suggestion;\n    }\n\n    private async generatePatternBasedSuggestions(\n        patterns: CommandPattern[], \n        context: ExecutionContext\n    ): Promise<CommandSuggestion[]> {\n        const suggestions: CommandSuggestion[] = [];\n        \n        for (const pattern of patterns.slice(0, 3)) {\n            if (pattern.commandSequence.length > 0) {\n                const nextCommand = pattern.commandSequence[0];\n                suggestions.push({\n                    command: nextCommand as any,\n                    reason: `Pattern-based: ${pattern.description}`,\n                    confidence: pattern.confidence * 0.8,\n                    estimatedImpact: pattern.successRate > 0.8 ? 'high' : 'medium',\n                    context: {\n                        trigger: 'pattern-match',\n                        relatedFiles: context.currentFiles,\n                        similarPatterns: [pattern.id]\n                    }\n                });\n            }\n        }\n        \n        return suggestions;\n    }\n\n    private async generateProactiveSuggestions(\n        context: ExecutionContext, \n        predictions: Map<string, SuccessPrediction>\n    ): Promise<CommandSuggestion[]> {\n        const suggestions: CommandSuggestion[] = [];\n        \n        // Proactive test suggestion if tests haven't been run recently\n        const lastTestRun = context.recentCommands\n            .filter(cmd => cmd.action === 'nxTest')\n            .sort((a, b) => b.startTime.getTime() - a.startTime.getTime())[0];\n        \n        if (!lastTestRun || \n            (Date.now() - lastTestRun.startTime.getTime()) > 3600000) { // 1 hour\n            suggestions.push({\n                command: 'nxTest',\n                reason: 'Proactive: Tests haven\\'t been run recently',\n                confidence: 0.6,\n                estimatedImpact: 'medium',\n                context: {\n                    trigger: 'proactive-testing',\n                    relatedFiles: context.currentFiles,\n                    similarPatterns: ['regular-testing-pattern']\n                }\n            });\n        }\n        \n        return suggestions;\n    }\n\n    private calculateSuggestionScore(suggestion: CommandSuggestion, context: ExecutionContext): number {\n        let score = suggestion.confidence;\n        \n        // Boost score based on impact\n        const impactMultiplier = {\n            'high': 1.3,\n            'medium': 1.1,\n            'low': 0.9\n        };\n        score *= impactMultiplier[suggestion.estimatedImpact];\n        \n        // Boost score based on context relevance\n        if (suggestion.context.relatedFiles.length > 0) {\n            score *= 1.1;\n        }\n        \n        if (suggestion.context.similarPatterns.length > 0) {\n            score *= 1.2;\n        }\n        \n        return score;\n    }\n\n    private groupExecutionsByContext(executions: CommandExecution[]): Map<string, CommandExecution[]> {\n        const groups = new Map<string, CommandExecution[]>();\n        \n        for (const execution of executions) {\n            // Simplified context signature for grouping\n            const signature = `${execution.project}-${execution.action}`;\n            \n            if (!groups.has(signature)) {\n                groups.set(signature, []);\n            }\n            groups.get(signature)!.push(execution);\n        }\n        \n        return groups;\n    }\n\n    private async extractPattern(\n        contextSignature: string, \n        executions: CommandExecution[]\n    ): Promise<CommandPattern> {\n        const successfulExecutions = executions.filter(e => e.status === 'completed');\n        const successRate = successfulExecutions.length / executions.length;\n        \n        return {\n            id: `pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n            name: `Extracted Pattern for ${contextSignature}`,\n            description: `Pattern extracted from ${executions.length} executions`,\n            contextSignature,\n            commandSequence: executions.map(e => e.action),\n            successRate,\n            confidence: Math.min(successRate + 0.1, 0.95),\n            conditions: {},\n            outcomes: {\n                successfulResolution: successRate,\n                partialResolution: Math.max(0, 1 - successRate - 0.1),\n                noResolution: Math.max(0, 0.1)\n            },\n            lastUpdated: new Date(),\n            usageCount: executions.length\n        };\n    }\n\n    private async updateSuccessPredictors(executions: CommandExecution[]): Promise<void> {\n        for (const execution of executions) {\n            const predictorKey = `${execution.action}-${execution.project}`;\n            \n            if (!this.successPredictors.has(predictorKey)) {\n                this.successPredictors.set(predictorKey, {\n                    command: execution.action,\n                    project: execution.project,\n                    successCount: 0,\n                    totalCount: 0,\n                    lastUpdated: new Date()\n                });\n            }\n            \n            const predictor = this.successPredictors.get(predictorKey)!;\n            predictor.totalCount++;\n            if (execution.status === 'completed') {\n                predictor.successCount++;\n            }\n            predictor.lastUpdated = new Date();\n        }\n    }\n\n    private async calculateSuccessProbability(\n        command: string, \n        context: ExecutionContext\n    ): Promise<SuccessPrediction> {\n        const predictorKey = `${command}-${context.project}`;\n        const predictor = this.successPredictors.get(predictorKey);\n        \n        let baseProbability = 0.7; // Default probability\n        \n        if (predictor && predictor.totalCount > 0) {\n            baseProbability = predictor.successCount / predictor.totalCount;\n        }\n        \n        // Adjust probability based on context\n        let adjustedProbability = baseProbability;\n        \n        // Test failures reduce success probability for nxTest\n        if (command === 'nxTest' && context.testStatus.failing > 0) {\n            adjustedProbability *= 0.6;\n        }\n        \n        // Uncommitted changes can affect prepareToPush\n        if (command === 'prepareToPush' && context.gitStatus.hasUncommittedChanges) {\n            adjustedProbability *= 0.8;\n        }\n        \n        return {\n            probability: adjustedProbability,\n            factors: [\n                `Historical success rate: ${(baseProbability * 100).toFixed(1)}%`,\n                `Context adjustments applied`\n            ],\n            confidence: predictor ? Math.min(predictor.totalCount / 10, 1) : 0.5\n        };\n    }\n\n    private recordContextForLearning(context: ExecutionContext, suggestions: CommandSuggestion[]): void {\n        const entry: ContextHistoryEntry = {\n            contextSignature: this.generateContextSignature(context),\n            timestamp: new Date(),\n            suggestions: suggestions.map(s => ({ command: s.command, confidence: s.confidence })),\n            context: {\n                project: context.project,\n                testStatus: context.testStatus,\n                gitStatus: context.gitStatus,\n                fileCount: context.currentFiles.length\n            }\n        };\n        \n        this.contextHistory.push(entry);\n        \n        // Limit history size\n        if (this.contextHistory.length > this.maxHistorySize) {\n            this.contextHistory = this.contextHistory.slice(-this.maxHistorySize);\n        }\n    }\n\n    /**\n     * Save patterns to persistent storage\n     */\n    async savePatterns(): Promise<void> {\n        try {\n            const patterns = Array.from(this.patternDatabase.values());\n            await this.context.globalState.update(\n                'ai-insights-patterns', \n                JSON.stringify(patterns)\n            );\n            console.log(`Saved ${patterns.length} patterns to storage`);\n        } catch (error) {\n            console.error('Error saving patterns:', error);\n        }\n    }\n\n    dispose(): void {\n        this.savePatterns();\n        this.patternDatabase.clear();\n        this.successPredictors.clear();\n        this.contextHistory = [];\n    }\n}\n\n// Supporting interfaces for Phase 4.2\n\ninterface CommandPattern {\n    id: string;\n    name: string;\n    description: string;\n    contextSignature: string;\n    commandSequence: string[];\n    successRate: number;\n    confidence: number;\n    conditions: Record<string, any>;\n    outcomes: {\n        successfulResolution: number;\n        partialResolution: number;\n        noResolution: number;\n    };\n    lastUpdated: Date;\n    usageCount: number;\n}\n\ninterface SuccessPredictor {\n    command: string;\n    project: string;\n    successCount: number;\n    totalCount: number;\n    lastUpdated: Date;\n}\n\ninterface SuccessPrediction {\n    probability: number;\n    factors: string[];\n    confidence: number;\n}\n\ninterface ContextHistoryEntry {\n    contextSignature: string;\n    timestamp: Date;\n    suggestions: { command: string; confidence: number }[];\n    context: {\n        project: string;\n        testStatus: any;\n        gitStatus: any;\n        fileCount: number;\n    };\n}\n"],"version":3}