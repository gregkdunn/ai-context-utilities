{"file":"/Users/gregdunn/src/test/ai_debug_context/vscode/src/utils/commandCoordinator.ts","mappings":"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","names":[],"sources":["/Users/gregdunn/src/test/ai_debug_context/vscode/src/utils/commandCoordinator.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport * as vscode from 'vscode';\nimport { StatusTracker, CommandStatus } from './statusTracker';\nexport type { CommandStatus };\nimport { StreamingCommandRunner } from './streamingRunner';\nimport { CommandResult, CommandOptions, StreamingMessage } from '../types';\n\n/**\n * Coordinates command execution with real-time status tracking and streaming\n */\nexport class CommandCoordinator extends EventEmitter {\n    private activeCommands = new Map<string, StreamingCommandRunner>();\n    private commandQueue: Array<{\n        id: string;\n        command: string;\n        args: string[];\n        options: any;\n        resolve: (result: CommandResult) => void;\n        reject: (error: Error) => void;\n    }> = [];\n    private maxConcurrentCommands = 3;\n\n    constructor(\n        private statusTracker: StatusTracker,\n        private context: vscode.ExtensionContext\n    ) {\n        super();\n        \n        // Listen to status tracker events\n        this.statusTracker.on('status_change', (event) => {\n            this.emit('status_update', event);\n        });\n    }\n\n    /**\n     * Execute a command with full status tracking and streaming\n     */\n    async executeCommand(\n        command: 'aiDebug' | 'nxTest' | 'gitDiff' | 'prepareToPush',\n        args: string[],\n        options: {\n            project?: string;\n            cwd?: string;\n            commandOptions?: CommandOptions;\n            priority?: 'low' | 'normal' | 'high';\n        } = {}\n    ): Promise<CommandResult> {\n        // Check if we're at the concurrent limit\n        if (this.activeCommands.size >= this.maxConcurrentCommands) {\n            if (options.priority === 'high') {\n                // Cancel lowest priority command for high priority\n                this.cancelLowestPriorityCommand();\n            } else {\n                // Queue the command\n                return this.queueCommand(command, args, options);\n            }\n        }\n\n        const commandId = this.statusTracker.startCommand(\n            command, \n            options.project, \n            options.commandOptions\n        );\n\n        try {\n            return await this.executeCommandInternal(commandId, command, args, options);\n        } catch (error) {\n            this.statusTracker.updateStatus({ message: error instanceof Error ? error.message : 'Unknown error' });\n            throw error;\n        }\n    }\n\n    /**\n     * Cancel a specific command\n     */\n    cancelCommand(commandId: string): boolean {\n        const runner = this.activeCommands.get(commandId);\n        if (runner && runner.isRunning) {\n            runner.cancel();\n            this.statusTracker.cancelCommand(commandId);\n            this.activeCommands.delete(commandId);\n            this.processQueue(); // Process next queued command\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Cancel all running commands\n     */\n    cancelAllCommands(): void {\n        for (const [commandId, runner] of this.activeCommands) {\n            if (runner.isRunning) {\n                runner.cancel();\n                this.statusTracker.cancelCommand(commandId);\n            }\n        }\n        this.activeCommands.clear();\n        this.commandQueue = [];\n    }\n\n    /**\n     * Get current execution status\n     */\n    getExecutionStatus(): {\n        active: number;\n        queued: number;\n        maxConcurrent: number;\n        commands: CommandStatus[];\n    } {\n        return {\n            active: this.activeCommands.size,\n            queued: this.commandQueue.length,\n            maxConcurrent: this.maxConcurrentCommands,\n            commands: this.statusTracker.getAllStatuses()\n        };\n    }\n\n    /**\n     * Set maximum concurrent commands\n     */\n    setMaxConcurrentCommands(max: number): void {\n        this.maxConcurrentCommands = Math.max(1, Math.min(10, max));\n        \n        // If we're over the limit, queue doesn't need immediate action\n        // as commands will naturally complete and be processed\n    }\n\n    /**\n     * Get streaming output for a command\n     */\n    getCommandOutput(commandId: string): string {\n        const runner = this.activeCommands.get(commandId);\n        return runner?.getCurrentOutput() || '';\n    }\n\n    /**\n     * Clear output for a command\n     */\n    clearCommandOutput(commandId: string): void {\n        const runner = this.activeCommands.get(commandId);\n        if (runner) {\n            runner.clearOutput();\n        }\n    }\n\n    /**\n     * Get detailed execution metrics\n     */\n    getExecutionMetrics(): {\n        totalCommands: number;\n        successRate: number;\n        averageExecutionTime: number;\n        concurrentPeak: number;\n        queueTimeAverage: number;\n    } {\n        const history = this.statusTracker.getHistory();\n        const stats = this.statusTracker.getCommandStats();\n        \n        return {\n            totalCommands: stats.total,\n            successRate: stats.total > 0 ? (stats.successful / stats.total) * 100 : 0,\n            averageExecutionTime: stats.averageDuration,\n            concurrentPeak: this.maxConcurrentCommands, // Could track actual peak\n            queueTimeAverage: 0 // Would need to track queue times\n        };\n    }\n\n    /**\n     * Create execution health report\n     */\n    createHealthReport(): string {\n        const status = this.getExecutionStatus();\n        const metrics = this.getExecutionMetrics();\n        const now = new Date();\n        \n        return `\n=================================================================\nüè• COMMAND EXECUTION HEALTH REPORT\n=================================================================\n\nüìä Generated: ${now.toISOString()}\nüîß System Status: ${status.active > 0 ? 'ACTIVE' : 'IDLE'}\n\n=================================================================\nüìà CURRENT STATUS\n=================================================================\n\nüîÑ Active Commands: ${status.active}/${status.maxConcurrent}\n‚è≥ Queued Commands: ${status.queued}\nüìä Total Executed: ${metrics.totalCommands}\n‚úÖ Success Rate: ${metrics.successRate.toFixed(1)}%\n‚è±Ô∏è  Avg Execution: ${(metrics.averageExecutionTime / 1000).toFixed(1)}s\n\n=================================================================\nüöÄ ACTIVE COMMANDS\n=================================================================\n\n${this.formatActiveCommands(status.commands)}\n\n=================================================================\n‚ö° PERFORMANCE METRICS\n=================================================================\n\n‚Ä¢ Concurrent Limit: ${status.maxConcurrent} commands\n‚Ä¢ Queue Processing: ${status.queued > 0 ? 'PROCESSING' : 'IDLE'}\n‚Ä¢ Memory Usage: ${this.getMemoryUsage()}\n‚Ä¢ Uptime: ${this.getUptime()}\n\n=================================================================\nüí° RECOMMENDATIONS\n=================================================================\n\n${this.generateRecommendations(status, metrics)}\n\n=================================================================\n`;\n    }\n\n    // Private methods\n    private async executeCommandInternal(\n        commandId: string,\n        command: string,\n        args: string[],\n        options: any\n    ): Promise<CommandResult> {\n        const outputChannel = vscode.window.createOutputChannel('AI Debug Utilities');\n        const runner = new StreamingCommandRunner(outputChannel);\n        this.activeCommands.set(commandId, runner);\n\n        // Set up streaming event handlers\n        runner.on('output', (output: string) => {\n            this.statusTracker.appendOutput(commandId, output);\n            this.emitStreamingMessage(commandId, 'output', { text: output });\n        });\n\n        runner.on('error', (error: string) => {\n            this.statusTracker.appendError(commandId, error);\n            this.emitStreamingMessage(commandId, 'error', { text: error });\n        });\n\n        runner.on('progress', (progress: number) => {\n            this.statusTracker.updateProgress(commandId, progress);\n            this.emitStreamingMessage(commandId, 'progress', { progress });\n        });\n\n        runner.on('status', (status: string) => {\n            this.statusTracker.updateStatus({ message: status });\n            this.emitStreamingMessage(commandId, 'status', { status });\n        });\n\n        try {\n            // Execute based on command type with appropriate streaming\n            let result: CommandResult;\n            \n            switch (command) {\n                case 'nxTest':\n                    result = await runner.executeTestCommand(\n                        'npx',\n                        ['nx', 'test', ...args],\n                        options.cwd || process.cwd()\n                    );\n                    break;\n                    \n                case 'gitDiff':\n                    result = await runner.executeGitCommand(\n                        ['diff', ...args],\n                        options.cwd || process.cwd()\n                    );\n                    break;\n                    \n                case 'prepareToPush':\n                    result = await runner.executeLintCommand(\n                        'npx',\n                        ['nx', 'lint', ...args],\n                        options.cwd || process.cwd()\n                    );\n                    break;\n                    \n                default:\n                    // Generic command execution\n                    result = await runner.executeWithStreaming(\n                        command,\n                        args,\n                        {\n                            cwd: options.cwd\n                        }\n                    );\n            }\n\n            // Complete the command\n            this.statusTracker.completeCommand(commandId, result);\n            this.emitStreamingMessage(commandId, 'complete', { result });\n            \n            return result;\n\n        } finally {\n            // Clean up\n            this.activeCommands.delete(commandId);\n            runner.removeAllListeners();\n            \n            // Process next queued command\n            this.processQueue();\n        }\n    }\n\n    private async queueCommand(\n        command: string,\n        args: string[],\n        options: any\n    ): Promise<CommandResult> {\n        return new Promise((resolve, reject) => {\n            const commandId = `queued-${Date.now()}`;\n            \n            this.commandQueue.push({\n                id: commandId,\n                command,\n                args,\n                options,\n                resolve,\n                reject\n            });\n\n            // Emit queue status update\n            this.emit('queue_update', {\n                queued: this.commandQueue.length,\n                position: this.commandQueue.length\n            });\n        });\n    }\n\n    private processQueue(): void {\n        if (this.commandQueue.length === 0 || this.activeCommands.size >= this.maxConcurrentCommands) {\n            return;\n        }\n\n        const next = this.commandQueue.shift();\n        if (!next) {\n            return;\n        }\n\n        // Execute the queued command\n        this.executeCommand(\n            next.command as any,\n            next.args,\n            next.options\n        ).then(next.resolve).catch(next.reject);\n\n        // Update queue status\n        this.emit('queue_update', {\n            queued: this.commandQueue.length,\n            processed: true\n        });\n    }\n\n    private cancelLowestPriorityCommand(): void {\n        // Find running command with lowest priority (most recent for now)\n        const commandIds = Array.from(this.activeCommands.keys());\n        if (commandIds.length > 0) {\n            const commandToCancel = commandIds[commandIds.length - 1]; // Most recent\n            this.cancelCommand(commandToCancel);\n        }\n    }\n\n    private emitStreamingMessage(commandId: string, type: StreamingMessage['type'], data: any): void {\n        const message: StreamingMessage = {\n            type,\n            data: {\n                ...data,\n                actionId: commandId\n            },\n            timestamp: new Date()\n        };\n        \n        this.emit('streaming_message', message);\n    }\n\n    private formatActiveCommands(commands: CommandStatus[]): string {\n        const active = commands.filter(c => c.status === 'running');\n        \n        if (active.length === 0) {\n            return '‚úÖ No commands currently active';\n        }\n        \n        return active.map(cmd => {\n            const elapsed = cmd.startTime ? Date.now() - cmd.startTime.getTime() : 0;\n            const elapsedSeconds = Math.round(elapsed / 1000);\n            \n            return `üîÑ ${cmd.command || cmd.action}${cmd.project ? ` (${cmd.project})` : ''}\n   Progress: ${cmd.progress}% | Elapsed: ${elapsedSeconds}s\n   Status: ${cmd.message || cmd.output}\n   ID: ${cmd.id.substring(0, 8)}...`;\n        }).join('\\n\\n');\n    }\n\n    private getMemoryUsage(): string {\n        const usage = process.memoryUsage();\n        return `${Math.round(usage.heapUsed / 1024 / 1024)}MB`;\n    }\n\n    private getUptime(): string {\n        const uptimeMs = process.uptime() * 1000;\n        const hours = Math.floor(uptimeMs / (1000 * 60 * 60));\n        const minutes = Math.floor((uptimeMs % (1000 * 60 * 60)) / (1000 * 60));\n        return `${hours}h ${minutes}m`;\n    }\n\n    private generateRecommendations(status: any, metrics: any): string {\n        const recommendations: string[] = [];\n        \n        if (status.queued > 5) {\n            recommendations.push('‚ö†Ô∏è  High queue backlog - consider increasing concurrent limit');\n        }\n        \n        if (metrics.successRate < 80) {\n            recommendations.push('üîß Low success rate - check command configurations');\n        }\n        \n        if (metrics.averageExecutionTime > 60000) {\n            recommendations.push('‚è∞ Long execution times - consider optimizing commands');\n        }\n        \n        if (status.active === status.maxConcurrent) {\n            recommendations.push('üìà At concurrent limit - monitor for bottlenecks');\n        }\n        \n        if (recommendations.length === 0) {\n            recommendations.push('‚úÖ System running optimally');\n        }\n        \n        return recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\\n');\n    }\n\n    /**\n     * Dispose of resources\n     */\n    dispose(): void {\n        this.cancelAllCommands();\n        this.removeAllListeners();\n    }\n}"],"version":3}