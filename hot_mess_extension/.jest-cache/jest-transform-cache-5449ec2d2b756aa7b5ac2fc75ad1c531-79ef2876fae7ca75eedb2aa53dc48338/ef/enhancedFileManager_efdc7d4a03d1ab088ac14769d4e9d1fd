a0ee6ee8e7296715b9deeb19a22ff28d
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileManager = exports.EnhancedFileManager = void 0;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
class EnhancedFileManager {
    workspaceRoot;
    outputDirectory;
    watchers = new Map();
    fileHistory = [];
    maxHistoryItems = 50;
    constructor() {
        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
        this.outputDirectory = '';
        this.updateOutputDirectory();
        // Listen for configuration changes
        vscode.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration('aiDebugUtilities.outputDirectory')) {
                this.updateOutputDirectory();
                this.recreateWatchers();
            }
        });
    }
    /**
     * Update output directory from configuration
     */
    updateOutputDirectory() {
        const config = vscode.workspace.getConfiguration('aiDebugUtilities');
        const configDir = config.get('outputDirectory') || '.github/instructions/ai_utilities_context';
        this.outputDirectory = path.join(this.workspaceRoot, configDir);
    }
    /**
     * Get the output directory path
     */
    getOutputDirectory() {
        return this.outputDirectory;
    }
    /**
     * Create a backup of the current output directory
     */
    async createBackup(label) {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupLabel = label || 'manual';
        const backupDir = path.join(this.outputDirectory, '..', 'backups', `backup-${backupLabel}-${timestamp}`);
        await this.ensureDirectoryExists(backupDir);
        const files = this.getAllOutputFiles();
        let backedUpCount = 0;
        for (const file of files) {
            if (file.exists) {
                const backupPath = path.join(backupDir, path.basename(file.path));
                try {
                    await fs.promises.copyFile(file.path, backupPath);
                    backedUpCount++;
                }
                catch (error) {
                    console.warn(`Failed to backup ${file.path}:`, error);
                }
            }
        }
        // Create backup metadata
        const metadata = {
            timestamp: new Date(),
            label: backupLabel,
            files: backedUpCount,
            originalPath: this.outputDirectory,
            version: await this.getExtensionVersion()
        };
        await fs.promises.writeFile(path.join(backupDir, 'backup-metadata.json'), JSON.stringify(metadata, null, 2));
        vscode.window.showInformationMessage(`Backup created with ${backedUpCount} files: ${path.basename(backupDir)}`);
        return backupDir;
    }
    /**
     * Restore from a backup directory
     */
    async restoreFromBackup(backupPath) {
        if (!fs.existsSync(backupPath)) {
            throw new Error(`Backup directory not found: ${backupPath}`);
        }
        // Read backup metadata if available
        const metadataPath = path.join(backupPath, 'backup-metadata.json');
        let metadata = null;
        if (fs.existsSync(metadataPath)) {
            try {
                metadata = JSON.parse(await fs.promises.readFile(metadataPath, 'utf8'));
            }
            catch (error) {
                console.warn('Failed to read backup metadata:', error);
            }
        }
        await this.ensureOutputDirectory();
        // Find all files in backup directory (excluding metadata)
        const backupFiles = fs.readdirSync(backupPath)
            .filter(file => file !== 'backup-metadata.json' && file.endsWith('.txt'));
        let restoredCount = 0;
        for (const file of backupFiles) {
            const sourcePath = path.join(backupPath, file);
            const targetPath = path.join(this.outputDirectory, file);
            try {
                await fs.promises.copyFile(sourcePath, targetPath);
                restoredCount++;
            }
            catch (error) {
                console.error(`Failed to restore ${file}:`, error);
            }
        }
        const backupInfo = metadata
            ? ` from ${metadata.label} (${new Date(metadata.timestamp).toLocaleDateString()})`
            : '';
        vscode.window.showInformationMessage(`Restored ${restoredCount} files${backupInfo}`);
    }
    /**
     * Enhanced file saving with versioning and validation
     */
    async saveOutputWithVersioning(type, content, options) {
        this.ensureOutputDirectory();
        const fileName = this.getFileName(type);
        const filePath = path.join(this.outputDirectory, fileName);
        // Create backup if existing file and backup requested
        if (options?.backup && fs.existsSync(filePath)) {
            const backupPath = `${filePath}.backup.${Date.now()}`;
            await fs.promises.copyFile(filePath, backupPath);
        }
        // Validate content if requested
        if (options?.validate) {
            await this.validateFileContent(type, content);
        }
        try {
            await fs.promises.writeFile(filePath, content, 'utf8');
            // Add to file history
            this.addToHistory(type, 'saved', filePath);
            return filePath;
        }
        catch (error) {
            throw new Error(`Failed to save ${type} output: ${error}`);
        }
    }
    /**
     * Validate file content based on type
     */
    async validateFileContent(type, content) {
        switch (type) {
            case 'jest-output':
                if (!content.includes('Test') && !content.includes('PASS') && !content.includes('FAIL')) {
                    console.warn('Jest output validation: Content may not be valid test output');
                }
                break;
            case 'diff':
                if (content.trim() && !content.includes('diff --git') && !content.includes('@@')) {
                    console.warn('Diff validation: Content may not be valid diff output');
                }
                break;
            case 'ai-debug-context':
                if (!content.includes('AI DEBUG CONTEXT') && content.length < 100) {
                    console.warn('AI context validation: Content seems too short or invalid');
                }
                break;
            case 'pr-description':
                if (!content.includes('PR DESCRIPTION') && content.length < 50) {
                    console.warn('PR description validation: Content seems incomplete');
                }
                break;
        }
    }
    /**
     * Get comprehensive file metadata
     */
    async getFileMetadata(type) {
        const filePath = this.getFilePath(type);
        const exists = fs.existsSync(filePath);
        if (!exists) {
            return {
                path: filePath,
                size: 0,
                sizeFormatted: '0 B',
                lines: 0,
                created: new Date(0),
                modified: new Date(0),
                exists: false,
                type,
                status: 'missing'
            };
        }
        try {
            const stats = fs.statSync(filePath);
            const content = await fs.promises.readFile(filePath, 'utf8');
            const lines = content.split('\n').length;
            // Determine status
            const age = Date.now() - stats.mtime.getTime();
            const isStale = age > (24 * 60 * 60 * 1000); // 24 hours
            return {
                path: filePath,
                size: stats.size,
                sizeFormatted: this.formatFileSize(stats.size),
                lines,
                created: stats.birthtime,
                modified: stats.mtime,
                exists: true,
                type,
                status: isStale ? 'stale' : 'current'
            };
        }
        catch (error) {
            return {
                path: filePath,
                size: 0,
                sizeFormatted: '0 B',
                lines: 0,
                created: new Date(0),
                modified: new Date(0),
                exists: true,
                type,
                status: 'error'
            };
        }
    }
    /**
     * Get metadata for all output files
     */
    async getAllFileMetadata() {
        const types = ['ai-debug-context', 'jest-output', 'diff', 'pr-description'];
        return Promise.all(types.map(type => this.getFileMetadata(type)));
    }
    /**
     * Create file batch record for command execution
     */
    async createFileBatch(command, types, success) {
        const batch = {
            id: `${command}-${Date.now()}`,
            timestamp: new Date(),
            files: await Promise.all(types.map(type => this.getFileMetadata(type))),
            command,
            success
        };
        this.fileHistory.unshift(batch);
        // Limit history size
        if (this.fileHistory.length > this.maxHistoryItems) {
            this.fileHistory = this.fileHistory.slice(0, this.maxHistoryItems);
        }
        return batch;
    }
    /**
     * Get file history
     */
    getFileHistory() {
        return [...this.fileHistory];
    }
    /**
     * Enhanced file watching with detailed events
     */
    watchOutputFiles(callback) {
        const watchId = `output-files-${Date.now()}`;
        const pattern = new vscode.RelativePattern(this.outputDirectory, '*.txt');
        const watcher = vscode.workspace.createFileSystemWatcher(pattern);
        const handleFileEvent = (type) => (uri) => {
            const fileName = path.basename(uri.fsPath);
            const outputType = this.getTypeFromFileName(fileName);
            if (outputType) {
                const event = {
                    type,
                    file: outputType,
                    path: uri.fsPath,
                    timestamp: new Date()
                };
                callback(event);
            }
        };
        watcher.onDidCreate(handleFileEvent('created'));
        watcher.onDidChange(handleFileEvent('modified'));
        watcher.onDidDelete(handleFileEvent('deleted'));
        this.watchers.set(watchId, watcher);
        return {
            dispose: () => {
                watcher.dispose();
                this.watchers.delete(watchId);
            }
        };
    }
    // Helper methods
    formatFileSize(bytes) {
        const units = ['B', 'KB', 'MB', 'GB'];
        let size = bytes;
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }
        return `${Math.round(size * 100) / 100} ${units[unitIndex]}`;
    }
    async getExtensionVersion() {
        try {
            const packagePath = path.join(__dirname, '..', '..', 'package.json');
            const packageContent = await fs.promises.readFile(packagePath, 'utf8');
            const packageJson = JSON.parse(packageContent);
            return packageJson.version || '1.0.0';
        }
        catch {
            return '1.0.0';
        }
    }
    addToHistory(type, action, filePath) {
        // Add to internal history tracking if needed
        console.log(`File ${action}: ${type} -> ${filePath}`);
    }
    recreateWatchers() {
        // Dispose existing watchers and recreate them with new output directory
        this.watchers.forEach(watcher => watcher.dispose());
        this.watchers.clear();
    }
    // Include all existing methods from the original FileManager
    ensureOutputDirectory() {
        if (!fs.existsSync(this.outputDirectory)) {
            fs.mkdirSync(this.outputDirectory, { recursive: true });
        }
    }
    async saveOutput(type, content) {
        this.ensureOutputDirectory();
        const fileName = this.getFileName(type);
        const filePath = path.join(this.outputDirectory, fileName);
        try {
            fs.writeFileSync(filePath, content, 'utf8');
            return filePath;
        }
        catch (error) {
            throw new Error(`Failed to save ${type} output: ${error}`);
        }
    }
    async getFileContent(type) {
        const fileName = this.getFileName(type);
        const filePath = path.join(this.outputDirectory, fileName);
        try {
            if (fs.existsSync(filePath)) {
                return fs.readFileSync(filePath, 'utf8');
            }
        }
        catch (error) {
            console.error(`Failed to read ${type} file:`, error);
        }
        return null;
    }
    async openFile(filePath) {
        try {
            const uri = vscode.Uri.file(filePath);
            const document = await vscode.workspace.openTextDocument(uri);
            await vscode.window.showTextDocument(document);
        }
        catch (error) {
            vscode.window.showErrorMessage(`Failed to open file: ${error}`);
        }
    }
    getFilePath(type) {
        const fileName = this.getFileName(type);
        return path.join(this.outputDirectory, fileName);
    }
    fileExists(type) {
        const filePath = this.getFilePath(type);
        return fs.existsSync(filePath);
    }
    getFileModTime(type) {
        const filePath = this.getFilePath(type);
        try {
            if (fs.existsSync(filePath)) {
                const stats = fs.statSync(filePath);
                return stats.mtime;
            }
        }
        catch (error) {
            console.error(`Failed to get file stats for ${type}:`, error);
        }
        return null;
    }
    getAllOutputFiles() {
        const types = ['ai-debug-context', 'jest-output', 'diff', 'pr-description'];
        return types.map(type => ({
            type,
            path: this.getFilePath(type),
            exists: this.fileExists(type),
            modified: this.getFileModTime(type) || undefined
        }));
    }
    async cleanupOldFiles(maxAge = 7 * 24 * 60 * 60 * 1000) {
        const now = Date.now();
        const files = this.getAllOutputFiles();
        for (const file of files) {
            if (file.exists && file.modified) {
                const age = now - file.modified.getTime();
                if (age > maxAge) {
                    try {
                        fs.unlinkSync(file.path);
                        console.log(`Cleaned up old file: ${file.path}`);
                    }
                    catch (error) {
                        console.error(`Failed to cleanup file ${file.path}:`, error);
                    }
                }
            }
        }
    }
    async copyToClipboard(type) {
        const content = await this.getFileContent(type);
        if (content) {
            await vscode.env.clipboard.writeText(content);
            vscode.window.showInformationMessage(`${type} content copied to clipboard`);
        }
        else {
            vscode.window.showWarningMessage(`No ${type} file found`);
        }
    }
    async initializeOutputFiles(types) {
        this.ensureOutputDirectory();
        const filePaths = {};
        for (const type of types) {
            const fileName = this.getFileNameFromType(type);
            filePaths[type] = path.join(this.outputDirectory, fileName);
        }
        return filePaths;
    }
    async getOutputFilePath(fileName) {
        this.ensureOutputDirectory();
        return path.join(this.outputDirectory, fileName);
    }
    async ensureDirectoryExists(dirPath) {
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, { recursive: true });
        }
    }
    async deleteFile(filePath) {
        try {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
        }
        catch (error) {
            // Ignore errors when deleting files
        }
    }
    async writeFile(filePath, content) {
        const dir = path.dirname(filePath);
        await this.ensureDirectoryExists(dir);
        fs.writeFileSync(filePath, content, 'utf8');
    }
    async readFile(filePath) {
        return fs.readFileSync(filePath, 'utf8');
    }
    async getFileStats(filePath) {
        try {
            const stats = fs.statSync(filePath);
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n').length;
            const sizeKB = Math.round(stats.size / 1024);
            return {
                size: `${sizeKB}KB`,
                lines
            };
        }
        catch (error) {
            return {
                size: '0KB',
                lines: 0
            };
        }
    }
    getFileNameFromType(type) {
        switch (type) {
            case 'ai-debug-context':
                return 'ai-debug-context.txt';
            case 'jest-output':
                return 'jest-output.txt';
            case 'diff':
                return 'diff.txt';
            case 'pr-description-prompt':
                return 'pr-description-prompt.txt';
            default:
                return `${type}.txt`;
        }
    }
    getFileName(type) {
        switch (type) {
            case 'ai-debug-context':
                return 'ai-debug-context.txt';
            case 'jest-output':
                return 'jest-output.txt';
            case 'diff':
                return 'diff.txt';
            case 'pr-description':
                return 'pr-description-prompt.txt';
            default:
                throw new Error(`Unknown output type: ${type}`);
        }
    }
    getTypeFromFileName(fileName) {
        switch (fileName) {
            case 'ai-debug-context.txt':
                return 'ai-debug-context';
            case 'jest-output.txt':
                return 'jest-output';
            case 'diff.txt':
                return 'diff';
            case 'pr-description-prompt.txt':
                return 'pr-description';
            default:
                return null;
        }
    }
}
exports.EnhancedFileManager = EnhancedFileManager;
// Export the original FileManager class name for backward compatibility
class FileManager extends EnhancedFileManager {
}
exports.FileManager = FileManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy91dGlscy9lbmhhbmNlZEZpbGVNYW5hZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUFpQztBQUNqQywyQ0FBNkI7QUFDN0IsdUNBQXlCO0FBOEJ6QixNQUFhLG1CQUFtQjtJQUNwQixhQUFhLENBQVM7SUFDdEIsZUFBZSxDQUFTO0lBQ3hCLFFBQVEsR0FBMEMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUM1RCxXQUFXLEdBQWdCLEVBQUUsQ0FBQztJQUM5QixlQUFlLEdBQUcsRUFBRSxDQUFDO0lBRTdCO1FBQ0ksSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDOUUsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFFN0IsbUNBQW1DO1FBQ25DLE1BQU0sQ0FBQyxTQUFTLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUM1QyxJQUFJLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxrQ0FBa0MsQ0FBQyxFQUFFLENBQUM7Z0JBQzdELElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO2dCQUM3QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUM1QixDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxxQkFBcUI7UUFDekIsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQVMsaUJBQWlCLENBQUMsSUFBSSwyQ0FBMkMsQ0FBQztR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QUN2QztnQkFDSSxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUM7UUFDN0IsQ0FBQztJQUNMLENBQUM7SUFFTyxXQUFXLENBQUMsSUFBZ0I7UUFDaEMsUUFBUSxJQUFJLEVBQUUsQ0FBQztZQUNYLEtBQUssa0JBQWtCO2dCQUNuQixPQUFPLHNCQUFzQixDQUFDO1lBQ2xDLEtBQUssYUFBYTtnQkFDZCxPQUFPLGlCQUFpQixDQUFDO1lBQzdCLEtBQUssTUFBTTtnQkFDUCxPQUFPLFVBQVUsQ0FBQztZQUN0QixLQUFLLGdCQUFnQjtnQkFDakIsT0FBTywyQkFBMkIsQ0FBQztZQUN2QztnQkFDSSxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELENBQUM7SUFDTCxDQUFDO0lBRU8sbUJBQW1CLENBQUMsUUFBZ0I7UUFDeEMsUUFBUSxRQUFRLEVBQUUsQ0FBQztZQUNmLEtBQUssc0JBQXNCO2dCQUN2QixPQUFPLGtCQUFrQixDQUFDO1lBQzlCLEtBQUssaUJBQWlCO2dCQUNsQixPQUFPLGFBQWEsQ0FBQztZQUN6QixLQUFLLFVBQVU7Z0JBQ1gsT0FBTyxNQUFNLENBQUM7WUFDbEIsS0FBSywyQkFBMkI7Z0JBQzVCLE9BQU8sZ0JBQWdCLENBQUM7WUFDNUI7Z0JBQ0ksT0FBTyxJQUFJLENBQUM7UUFDcEIsQ0FBQztJQUNMLENBQUM7Q0FDSjtBQXZrQkQsa0RBdWtCQztBQUVELHdFQUF3RTtBQUN4RSxNQUFhLFdBQVksU0FBUSxtQkFBbUI7Q0FFbkQ7QUFGRCxrQ0FFQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZ3JlZ2R1bm4vc3JjL3Rlc3QvYWlfZGVidWdfY29udGV4dC92c2NvZGUvc3JjL3V0aWxzL2VuaGFuY2VkRmlsZU1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdnNjb2RlIGZyb20gJ3ZzY29kZSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHsgT3V0cHV0VHlwZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBGaWxlTWV0YWRhdGEge1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBzaXplOiBudW1iZXI7XG4gICAgc2l6ZUZvcm1hdHRlZDogc3RyaW5nO1xuICAgIGxpbmVzOiBudW1iZXI7XG4gICAgY3JlYXRlZDogRGF0ZTtcbiAgICBtb2RpZmllZDogRGF0ZTtcbiAgICBleGlzdHM6IGJvb2xlYW47XG4gICAgdHlwZTogT3V0cHV0VHlwZTtcbiAgICBzdGF0dXM6ICdjdXJyZW50JyB8ICdzdGFsZScgfCAnbWlzc2luZycgfCAnZXJyb3InO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVCYXRjaCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IERhdGU7XG4gICAgZmlsZXM6IEZpbGVNZXRhZGF0YVtdO1xuICAgIGNvbW1hbmQ6IHN0cmluZztcbiAgICBzdWNjZXNzOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVXYXRjaEV2ZW50IHtcbiAgICB0eXBlOiAnY3JlYXRlZCcgfCAnbW9kaWZpZWQnIHwgJ2RlbGV0ZWQnO1xuICAgIGZpbGU6IE91dHB1dFR5cGU7XG4gICAgcGF0aDogc3RyaW5nO1xuICAgIHRpbWVzdGFtcDogRGF0ZTtcbn1cblxuZXhwb3J0IGNsYXNzIEVuaGFuY2VkRmlsZU1hbmFnZXIge1xuICAgIHByaXZhdGUgd29ya3NwYWNlUm9vdDogc3RyaW5nO1xuICAgIHByaXZhdGUgb3V0cHV0RGlyZWN0b3J5OiBzdHJpbmc7XG4gICAgcHJpdmF0ZSB3YXRjaGVyczogTWFwPHN0cmluZywgdnNjb2RlLkZpbGVTeXN0ZW1XYXRjaGVyPiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIGZpbGVIaXN0b3J5OiBGaWxlQmF0Y2hbXSA9IFtdO1xuICAgIHByaXZhdGUgbWF4SGlzdG9yeUl0ZW1zID0gNTA7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53b3Jrc3BhY2VSb290ID0gdnNjb2RlLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzPy5bMF0/LnVyaS5mc1BhdGggfHwgJyc7XG4gICAgICAgIHRoaXMub3V0cHV0RGlyZWN0b3J5ID0gJyc7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0cHV0RGlyZWN0b3J5KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBMaXN0ZW4gZm9yIGNvbmZpZ3VyYXRpb24gY2hhbmdlc1xuICAgICAgICB2c2NvZGUud29ya3NwYWNlLm9uRGlkQ2hhbmdlQ29uZmlndXJhdGlvbigoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuYWZmZWN0c0NvbmZpZ3VyYXRpb24oJ2FpRGVidWdVdGlsaXRpZXMub3V0cHV0RGlyZWN0b3J5JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU91dHB1dERpcmVjdG9yeSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVjcmVhdGVXYXRjaGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgb3V0cHV0IGRpcmVjdG9yeSBmcm9tIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZU91dHB1dERpcmVjdG9yeSgpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdnNjb2RlLndvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCdhaURlYnVnVXRpbGl0aWVzJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0RpciA9IGNvbmZpZy5nZXQ8c3RyaW5nPignb3V0cHV0RGlyZWN0b3J5JykgfHwgJy5naXRodWIvaW5zdHJ1Y3Rpb25zL2FpX3V0aWxpdGllc19jb250ZXh0JztcbiAgICAgICAgdGhpcy5vdXRwdXREaXJlY3RvcnkgPSBwYXRoLmpvaW4odGhpcy53b3Jrc3BhY2VSb290LCBjb25maWdEaXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3V0cHV0IGRpcmVjdG9yeSBwYXRoXG4gICAgICovXG4gICAgZ2V0T3V0cHV0RGlyZWN0b3J5KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dERpcmVjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBiYWNrdXAgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGRpcmVjdG9yeVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJhY2t1cChsYWJlbD86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOi5dL2csICctJyk7XG4gICAgICAgIGNvbnN0IGJhY2t1cExhYmVsID0gbGFiZWwgfHwgJ21hbnVhbCc7XG4gICAgICAgIGNvbnN0IGJhY2t1cERpciA9IHBhdGguam9pbihcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RGlyZWN0b3J5LCBcbiAgICAgICAgICAgICcuLicsIFxuICAgICAgICAgICAgJ2JhY2t1cHMnLCBcbiAgICAgICAgICAgIGBiYWNrdXAtJHtiYWNrdXBMYWJlbH0tJHt0aW1lc3RhbXB9YFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVEaXJlY3RvcnlFeGlzdHMoYmFja3VwRGlyKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRBbGxPdXRwdXRGaWxlcygpO1xuICAgICAgICBsZXQgYmFja2VkVXBDb3VudCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICAgIGlmIChmaWxlLmV4aXN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhY2t1cFBhdGggPSBwYXRoLmpvaW4oYmFja3VwRGlyLCBwYXRoLmJhc2VuYW1lKGZpbGUucGF0aCkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZzLnByb21pc2VzLmNvcHlGaWxlKGZpbGUucGF0aCwgYmFja3VwUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlZFVwQ291bnQrKztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBiYWNrdXAgJHtmaWxlLnBhdGh9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBiYWNrdXAgbWV0YWRhdGFcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBsYWJlbDogYmFja3VwTGFiZWwsXG4gICAgICAgICAgICBmaWxlczogYmFja2VkVXBDb3VudCxcbiAgICAgICAgICAgIG9yaWdpbmFsUGF0aDogdGhpcy5vdXRwdXREaXJlY3RvcnksXG4gICAgICAgICAgICB2ZXJzaW9uOiBhd2FpdCB0aGlzLmdldEV4dGVuc2lvblZlcnNpb24oKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKFxuICAgICAgICAgICAgcGF0aC5qb2luKGJhY2t1cERpciwgJ2JhY2t1cC1tZXRhZGF0YS5qc29uJyksXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgbnVsbCwgMilcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShcbiAgICAgICAgICAgIGBCYWNrdXAgY3JlYXRlZCB3aXRoICR7YmFja2VkVXBDb3VudH0gZmlsZXM6ICR7cGF0aC5iYXNlbmFtZShiYWNrdXBEaXIpfWBcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiYWNrdXBEaXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBmcm9tIGEgYmFja3VwIGRpcmVjdG9yeVxuICAgICAqL1xuICAgIGFzeW5jIHJlc3RvcmVGcm9tQmFja3VwKGJhY2t1cFBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoYmFja3VwUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFja3VwIGRpcmVjdG9yeSBub3QgZm91bmQ6ICR7YmFja3VwUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVhZCBiYWNrdXAgbWV0YWRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhUGF0aCA9IHBhdGguam9pbihiYWNrdXBQYXRoLCAnYmFja3VwLW1ldGFkYXRhLmpzb24nKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhOiBhbnkgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobWV0YWRhdGFQYXRoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUobWV0YWRhdGFQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVhZCBiYWNrdXAgbWV0YWRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLmVuc3VyZU91dHB1dERpcmVjdG9yeSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmluZCBhbGwgZmlsZXMgaW4gYmFja3VwIGRpcmVjdG9yeSAoZXhjbHVkaW5nIG1ldGFkYXRhKVxuICAgICAgICBjb25zdCBiYWNrdXBGaWxlcyA9IGZzLnJlYWRkaXJTeW5jKGJhY2t1cFBhdGgpXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGUgPT4gZmlsZSAhPT0gJ2JhY2t1cC1tZXRhZGF0YS5qc29uJyAmJiBmaWxlLmVuZHNXaXRoKCcudHh0JykpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHJlc3RvcmVkQ291bnQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGJhY2t1cEZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQYXRoID0gcGF0aC5qb2luKGJhY2t1cFBhdGgsIGZpbGUpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IHBhdGguam9pbih0aGlzLm91dHB1dERpcmVjdG9yeSwgZmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMuY29weUZpbGUoc291cmNlUGF0aCwgdGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgcmVzdG9yZWRDb3VudCsrO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmVzdG9yZSAke2ZpbGV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYmFja3VwSW5mbyA9IG1ldGFkYXRhIFxuICAgICAgICAgICAgPyBgIGZyb20gJHttZXRhZGF0YS5sYWJlbH0gKCR7bmV3IERhdGUobWV0YWRhdGEudGltZXN0YW1wKS50b0xvY2FsZURhdGVTdHJpbmcoKX0pYFxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgXG4gICAgICAgIHZzY29kZS53aW5kb3cuc2hvd0luZm9ybWF0aW9uTWVzc2FnZShcbiAgICAgICAgICAgIGBSZXN0b3JlZCAke3Jlc3RvcmVkQ291bnR9IGZpbGVzJHtiYWNrdXBJbmZvfWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlZCBmaWxlIHNhdmluZyB3aXRoIHZlcnNpb25pbmcgYW5kIHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBzYXZlT3V0cHV0V2l0aFZlcnNpb25pbmcodHlwZTogT3V0cHV0VHlwZSwgY29udGVudDogc3RyaW5nLCBvcHRpb25zPzoge1xuICAgICAgICBiYWNrdXA/OiBib29sZWFuO1xuICAgICAgICB2YWxpZGF0ZT86IGJvb2xlYW47XG4gICAgfSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHRoaXMuZW5zdXJlT3V0cHV0RGlyZWN0b3J5KCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUodHlwZSk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHRoaXMub3V0cHV0RGlyZWN0b3J5LCBmaWxlTmFtZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYmFja3VwIGlmIGV4aXN0aW5nIGZpbGUgYW5kIGJhY2t1cCByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKG9wdGlvbnM/LmJhY2t1cCAmJiBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgY29uc3QgYmFja3VwUGF0aCA9IGAke2ZpbGVQYXRofS5iYWNrdXAuJHtEYXRlLm5vdygpfWA7XG4gICAgICAgICAgICBhd2FpdCBmcy5wcm9taXNlcy5jb3B5RmlsZShmaWxlUGF0aCwgYmFja3VwUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIGNvbnRlbnQgaWYgcmVxdWVzdGVkXG4gICAgICAgIGlmIChvcHRpb25zPy52YWxpZGF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUZpbGVDb250ZW50KHR5cGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGZpbGVQYXRoLCBjb250ZW50LCAndXRmOCcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdG8gZmlsZSBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLmFkZFRvSGlzdG9yeSh0eXBlLCAnc2F2ZWQnLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNhdmUgJHt0eXBlfSBvdXRwdXQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBmaWxlIGNvbnRlbnQgYmFzZWQgb24gdHlwZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgdmFsaWRhdGVGaWxlQ29udGVudCh0eXBlOiBPdXRwdXRUeXBlLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqZXN0LW91dHB1dCc6XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZW50LmluY2x1ZGVzKCdUZXN0JykgJiYgIWNvbnRlbnQuaW5jbHVkZXMoJ1BBU1MnKSAmJiAhY29udGVudC5pbmNsdWRlcygnRkFJTCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignSmVzdCBvdXRwdXQgdmFsaWRhdGlvbjogQ29udGVudCBtYXkgbm90IGJlIHZhbGlkIHRlc3Qgb3V0cHV0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHJpbSgpICYmICFjb250ZW50LmluY2x1ZGVzKCdkaWZmIC0tZ2l0JykgJiYgIWNvbnRlbnQuaW5jbHVkZXMoJ0BAJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaWZmIHZhbGlkYXRpb246IENvbnRlbnQgbWF5IG5vdCBiZSB2YWxpZCBkaWZmIG91dHB1dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FpLWRlYnVnLWNvbnRleHQnOlxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5pbmNsdWRlcygnQUkgREVCVUcgQ09OVEVYVCcpICYmIGNvbnRlbnQubGVuZ3RoIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQUkgY29udGV4dCB2YWxpZGF0aW9uOiBDb250ZW50IHNlZW1zIHRvbyBzaG9ydCBvciBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHItZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgICAgIGlmICghY29udGVudC5pbmNsdWRlcygnUFIgREVTQ1JJUFRJT04nKSAmJiBjb250ZW50Lmxlbmd0aCA8IDUwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUFIgZGVzY3JpcHRpb24gdmFsaWRhdGlvbjogQ29udGVudCBzZWVtcyBpbmNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGNvbXByZWhlbnNpdmUgZmlsZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIGFzeW5jIGdldEZpbGVNZXRhZGF0YSh0eXBlOiBPdXRwdXRUeXBlKTogUHJvbWlzZTxGaWxlTWV0YWRhdGE+IHtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSB0aGlzLmdldEZpbGVQYXRoKHR5cGUpO1xuICAgICAgICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgICAgc2l6ZUZvcm1hdHRlZDogJzAgQicsXG4gICAgICAgICAgICAgICAgbGluZXM6IDAsXG4gICAgICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoMCksXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKDApLFxuICAgICAgICAgICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdtaXNzaW5nJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKS5sZW5ndGg7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERldGVybWluZSBzdGF0dXNcbiAgICAgICAgICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSBzdGF0cy5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBpc1N0YWxlID0gYWdlID4gKDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyAyNCBob3Vyc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIHNpemU6IHN0YXRzLnNpemUsXG4gICAgICAgICAgICAgICAgc2l6ZUZvcm1hdHRlZDogdGhpcy5mb3JtYXRGaWxlU2l6ZShzdGF0cy5zaXplKSxcbiAgICAgICAgICAgICAgICBsaW5lcyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiBzdGF0cy5iaXJ0aHRpbWUsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IHN0YXRzLm10aW1lLFxuICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogaXNTdGFsZSA/ICdzdGFsZScgOiAnY3VycmVudCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgICAgc2l6ZUZvcm1hdHRlZDogJzAgQicsXG4gICAgICAgICAgICAgICAgbGluZXM6IDAsXG4gICAgICAgICAgICAgICAgY3JlYXRlZDogbmV3IERhdGUoMCksXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKDApLFxuICAgICAgICAgICAgICAgIGV4aXN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBtZXRhZGF0YSBmb3IgYWxsIG91dHB1dCBmaWxlc1xuICAgICAqL1xuICAgIGFzeW5jIGdldEFsbEZpbGVNZXRhZGF0YSgpOiBQcm9taXNlPEZpbGVNZXRhZGF0YVtdPiB7XG4gICAgICAgIGNvbnN0IHR5cGVzOiBPdXRwdXRUeXBlW10gPSBbJ2FpLWRlYnVnLWNvbnRleHQnLCAnamVzdC1vdXRwdXQnLCAnZGlmZicsICdwci1kZXNjcmlwdGlvbiddO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodHlwZXMubWFwKHR5cGUgPT4gdGhpcy5nZXRGaWxlTWV0YWRhdGEodHlwZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmlsZSBiYXRjaCByZWNvcmQgZm9yIGNvbW1hbmQgZXhlY3V0aW9uXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRmlsZUJhdGNoKGNvbW1hbmQ6IHN0cmluZywgdHlwZXM6IE91dHB1dFR5cGVbXSwgc3VjY2VzczogYm9vbGVhbik6IFByb21pc2U8RmlsZUJhdGNoPiB7XG4gICAgICAgIGNvbnN0IGJhdGNoOiBGaWxlQmF0Y2ggPSB7XG4gICAgICAgICAgICBpZDogYCR7Y29tbWFuZH0tJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICBmaWxlczogYXdhaXQgUHJvbWlzZS5hbGwodHlwZXMubWFwKHR5cGUgPT4gdGhpcy5nZXRGaWxlTWV0YWRhdGEodHlwZSkpKSxcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBzdWNjZXNzXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmZpbGVIaXN0b3J5LnVuc2hpZnQoYmF0Y2gpO1xuICAgICAgICBcbiAgICAgICAgLy8gTGltaXQgaGlzdG9yeSBzaXplXG4gICAgICAgIGlmICh0aGlzLmZpbGVIaXN0b3J5Lmxlbmd0aCA+IHRoaXMubWF4SGlzdG9yeUl0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVIaXN0b3J5ID0gdGhpcy5maWxlSGlzdG9yeS5zbGljZSgwLCB0aGlzLm1heEhpc3RvcnlJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiYXRjaDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBoaXN0b3J5XG4gICAgICovXG4gICAgZ2V0RmlsZUhpc3RvcnkoKTogRmlsZUJhdGNoW10ge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuZmlsZUhpc3RvcnldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2VkIGZpbGUgd2F0Y2hpbmcgd2l0aCBkZXRhaWxlZCBldmVudHNcbiAgICAgKi9cbiAgICB3YXRjaE91dHB1dEZpbGVzKGNhbGxiYWNrOiAoZXZlbnQ6IEZpbGVXYXRjaEV2ZW50KSA9PiB2b2lkKTogdnNjb2RlLkRpc3Bvc2FibGUge1xuICAgICAgICBjb25zdCB3YXRjaElkID0gYG91dHB1dC1maWxlcy0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyB2c2NvZGUuUmVsYXRpdmVQYXR0ZXJuKHRoaXMub3V0cHV0RGlyZWN0b3J5LCAnKi50eHQnKTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IHZzY29kZS53b3Jrc3BhY2UuY3JlYXRlRmlsZVN5c3RlbVdhdGNoZXIocGF0dGVybik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBoYW5kbGVGaWxlRXZlbnQgPSAodHlwZTogJ2NyZWF0ZWQnIHwgJ21vZGlmaWVkJyB8ICdkZWxldGVkJykgPT4gXG4gICAgICAgICAgICAodXJpOiB2c2NvZGUuVXJpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHVyaS5mc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dFR5cGUgPSB0aGlzLmdldFR5cGVGcm9tRmlsZU5hbWUoZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50OiBGaWxlV2F0Y2hFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiBvdXRwdXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogdXJpLmZzUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB3YXRjaGVyLm9uRGlkQ3JlYXRlKGhhbmRsZUZpbGVFdmVudCgnY3JlYXRlZCcpKTtcbiAgICAgICAgd2F0Y2hlci5vbkRpZENoYW5nZShoYW5kbGVGaWxlRXZlbnQoJ21vZGlmaWVkJykpO1xuICAgICAgICB3YXRjaGVyLm9uRGlkRGVsZXRlKGhhbmRsZUZpbGVFdmVudCgnZGVsZXRlZCcpKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMud2F0Y2hlcnMuc2V0KHdhdGNoSWQsIHdhdGNoZXIpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoZXJzLmRlbGV0ZSh3YXRjaElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kc1xuICAgIHByaXZhdGUgZm9ybWF0RmlsZVNpemUoYnl0ZXM6IG51bWJlcik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHVuaXRzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJ107XG4gICAgICAgIGxldCBzaXplID0gYnl0ZXM7XG4gICAgICAgIGxldCB1bml0SW5kZXggPSAwO1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKHNpemUgPj0gMTAyNCAmJiB1bml0SW5kZXggPCB1bml0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzaXplIC89IDEwMjQ7XG4gICAgICAgICAgICB1bml0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGAke01hdGgucm91bmQoc2l6ZSAqIDEwMCkgLyAxMDB9ICR7dW5pdHNbdW5pdEluZGV4XX1gO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIGFzeW5jIGdldEV4dGVuc2lvblZlcnNpb24oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJy4uJywgJ3BhY2thZ2UuanNvbicpO1xuICAgICAgICAgICAgY29uc3QgcGFja2FnZUNvbnRlbnQgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZShwYWNrYWdlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gSlNPTi5wYXJzZShwYWNrYWdlQ29udGVudCk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2FnZUpzb24udmVyc2lvbiB8fCAnMS4wLjAnO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiAnMS4wLjAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgYWRkVG9IaXN0b3J5KHR5cGU6IE91dHB1dFR5cGUsIGFjdGlvbjogc3RyaW5nLCBmaWxlUGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIEFkZCB0byBpbnRlcm5hbCBoaXN0b3J5IHRyYWNraW5nIGlmIG5lZWRlZFxuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSAke2FjdGlvbn06ICR7dHlwZX0gLT4gJHtmaWxlUGF0aH1gKTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSByZWNyZWF0ZVdhdGNoZXJzKCk6IHZvaWQge1xuICAgICAgICAvLyBEaXNwb3NlIGV4aXN0aW5nIHdhdGNoZXJzIGFuZCByZWNyZWF0ZSB0aGVtIHdpdGggbmV3IG91dHB1dCBkaXJlY3RvcnlcbiAgICAgICAgdGhpcy53YXRjaGVycy5mb3JFYWNoKHdhdGNoZXIgPT4gd2F0Y2hlci5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLndhdGNoZXJzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gSW5jbHVkZSBhbGwgZXhpc3RpbmcgbWV0aG9kcyBmcm9tIHRoZSBvcmlnaW5hbCBGaWxlTWFuYWdlclxuICAgIGVuc3VyZU91dHB1dERpcmVjdG9yeSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHRoaXMub3V0cHV0RGlyZWN0b3J5KSkge1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKHRoaXMub3V0cHV0RGlyZWN0b3J5LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHNhdmVPdXRwdXQodHlwZTogT3V0cHV0VHlwZSwgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhpcy5lbnN1cmVPdXRwdXREaXJlY3RvcnkoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSh0eXBlKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5vdXRwdXREaXJlY3RvcnksIGZpbGVOYW1lKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBjb250ZW50LCAndXRmOCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2F2ZSAke3R5cGV9IG91dHB1dDogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldEZpbGVDb250ZW50KHR5cGU6IE91dHB1dFR5cGUpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKHR5cGUpO1xuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbih0aGlzLm91dHB1dERpcmVjdG9yeSwgZmlsZU5hbWUpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcmVhZCAke3R5cGV9IGZpbGU6YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBvcGVuRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSB2c2NvZGUuVXJpLmZpbGUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCB2c2NvZGUud29ya3NwYWNlLm9wZW5UZXh0RG9jdW1lbnQodXJpKTtcbiAgICAgICAgICAgIGF3YWl0IHZzY29kZS53aW5kb3cuc2hvd1RleHREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB2c2NvZGUud2luZG93LnNob3dFcnJvck1lc3NhZ2UoYEZhaWxlZCB0byBvcGVuIGZpbGU6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRGaWxlUGF0aCh0eXBlOiBPdXRwdXRUeXBlKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKHR5cGUpO1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMub3V0cHV0RGlyZWN0b3J5LCBmaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgZmlsZUV4aXN0cyh0eXBlOiBPdXRwdXRUeXBlKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5nZXRGaWxlUGF0aCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpO1xuICAgIH1cblxuICAgIGdldEZpbGVNb2RUaW1lKHR5cGU6IE91dHB1dFR5cGUpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5nZXRGaWxlUGF0aCh0eXBlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0cy5tdGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgZmlsZSBzdGF0cyBmb3IgJHt0eXBlfTpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0QWxsT3V0cHV0RmlsZXMoKTogQXJyYXk8eyB0eXBlOiBPdXRwdXRUeXBlOyBwYXRoOiBzdHJpbmc7IGV4aXN0czogYm9vbGVhbjsgbW9kaWZpZWQ/OiBEYXRlIH0+IHtcbiAgICAgICAgY29uc3QgdHlwZXM6IE91dHB1dFR5cGVbXSA9IFsnYWktZGVidWctY29udGV4dCcsICdqZXN0LW91dHB1dCcsICdkaWZmJywgJ3ByLWRlc2NyaXB0aW9uJ107XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHlwZXMubWFwKHR5cGUgPT4gKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLmdldEZpbGVQYXRoKHR5cGUpLFxuICAgICAgICAgICAgZXhpc3RzOiB0aGlzLmZpbGVFeGlzdHModHlwZSksXG4gICAgICAgICAgICBtb2RpZmllZDogdGhpcy5nZXRGaWxlTW9kVGltZSh0eXBlKSB8fCB1bmRlZmluZWRcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIGNsZWFudXBPbGRGaWxlcyhtYXhBZ2U6IG51bWJlciA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRBbGxPdXRwdXRGaWxlcygpO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmlsZS5leGlzdHMgJiYgZmlsZS5tb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IG5vdyAtIGZpbGUubW9kaWZpZWQuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhZ2UgPiBtYXhBZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDbGVhbmVkIHVwIG9sZCBmaWxlOiAke2ZpbGUucGF0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjbGVhbnVwIGZpbGUgJHtmaWxlLnBhdGh9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGNvcHlUb0NsaXBib2FyZCh0eXBlOiBPdXRwdXRUeXBlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmdldEZpbGVDb250ZW50KHR5cGUpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgYXdhaXQgdnNjb2RlLmVudi5jbGlwYm9hcmQud3JpdGVUZXh0KGNvbnRlbnQpO1xuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93SW5mb3JtYXRpb25NZXNzYWdlKGAke3R5cGV9IGNvbnRlbnQgY29waWVkIHRvIGNsaXBib2FyZGApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zaG93V2FybmluZ01lc3NhZ2UoYE5vICR7dHlwZX0gZmlsZSBmb3VuZGApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgaW5pdGlhbGl6ZU91dHB1dEZpbGVzKHR5cGVzOiBzdHJpbmdbXSk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICAgICAgICB0aGlzLmVuc3VyZU91dHB1dERpcmVjdG9yeSgpO1xuICAgICAgICBjb25zdCBmaWxlUGF0aHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICBmaWxlUGF0aHNbdHlwZV0gPSBwYXRoLmpvaW4odGhpcy5vdXRwdXREaXJlY3RvcnksIGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZpbGVQYXRocztcbiAgICB9XG5cbiAgICBhc3luYyBnZXRPdXRwdXRGaWxlUGF0aChmaWxlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgdGhpcy5lbnN1cmVPdXRwdXREaXJlY3RvcnkoKTtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbih0aGlzLm91dHB1dERpcmVjdG9yeSwgZmlsZU5hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIGVuc3VyZURpcmVjdG9yeUV4aXN0cyhkaXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpclBhdGgpKSB7XG4gICAgICAgICAgICBmcy5ta2RpclN5bmMoZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGVGaWxlKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyB3aGVuIGRlbGV0aW5nIGZpbGVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB3cml0ZUZpbGUoZmlsZVBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5RXhpc3RzKGRpcik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnQsICd1dGY4Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZEZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0RmlsZVN0YXRzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc2l6ZTogc3RyaW5nOyBsaW5lczogbnVtYmVyIH0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMoZmlsZVBhdGgpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJykubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZUtCID0gTWF0aC5yb3VuZChzdGF0cy5zaXplIC8gMTAyNCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogYCR7c2l6ZUtCfUtCYCxcbiAgICAgICAgICAgICAgICBsaW5lc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogJzBLQicsXG4gICAgICAgICAgICAgICAgbGluZXM6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZpbGVOYW1lRnJvbVR5cGUodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhaS1kZWJ1Zy1jb250ZXh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FpLWRlYnVnLWNvbnRleHQudHh0JztcbiAgICAgICAgICAgIGNhc2UgJ2plc3Qtb3V0cHV0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2plc3Qtb3V0cHV0LnR4dCc7XG4gICAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RpZmYudHh0JztcbiAgICAgICAgICAgIGNhc2UgJ3ByLWRlc2NyaXB0aW9uLXByb21wdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwci1kZXNjcmlwdGlvbi1wcm9tcHQudHh0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3R5cGV9LnR4dGA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZpbGVOYW1lKHR5cGU6IE91dHB1dFR5cGUpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FpLWRlYnVnLWNvbnRleHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYWktZGVidWctY29udGV4dC50eHQnO1xuICAgICAgICAgICAgY2FzZSAnamVzdC1vdXRwdXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnamVzdC1vdXRwdXQudHh0JztcbiAgICAgICAgICAgIGNhc2UgJ2RpZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZGlmZi50eHQnO1xuICAgICAgICAgICAgY2FzZSAncHItZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAncHItZGVzY3JpcHRpb24tcHJvbXB0LnR4dCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvdXRwdXQgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUeXBlRnJvbUZpbGVOYW1lKGZpbGVOYW1lOiBzdHJpbmcpOiBPdXRwdXRUeXBlIHwgbnVsbCB7XG4gICAgICAgIHN3aXRjaCAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FpLWRlYnVnLWNvbnRleHQudHh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FpLWRlYnVnLWNvbnRleHQnO1xuICAgICAgICAgICAgY2FzZSAnamVzdC1vdXRwdXQudHh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2plc3Qtb3V0cHV0JztcbiAgICAgICAgICAgIGNhc2UgJ2RpZmYudHh0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RpZmYnO1xuICAgICAgICAgICAgY2FzZSAncHItZGVzY3JpcHRpb24tcHJvbXB0LnR4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwci1kZXNjcmlwdGlvbic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIG9yaWdpbmFsIEZpbGVNYW5hZ2VyIGNsYXNzIG5hbWUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCBjbGFzcyBGaWxlTWFuYWdlciBleHRlbmRzIEVuaGFuY2VkRmlsZU1hbmFnZXIge1xuICAgIC8vIFRoaXMgbWFpbnRhaW5zIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2hpbGUgcHJvdmlkaW5nIGVuaGFuY2VkIGZlYXR1cmVzXG59Il0sInZlcnNpb24iOjN9