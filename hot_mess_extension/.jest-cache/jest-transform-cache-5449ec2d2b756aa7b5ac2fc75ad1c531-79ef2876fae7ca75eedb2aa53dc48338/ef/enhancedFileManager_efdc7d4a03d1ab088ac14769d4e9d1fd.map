{"file":"/Users/gregdunn/src/test/ai_debug_context/vscode/src/utils/enhancedFileManager.ts","mappings":"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","names":[],"sources":["/Users/gregdunn/src/test/ai_debug_context/vscode/src/utils/enhancedFileManager.ts"],"sourcesContent":["import * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { OutputType } from '../types';\n\nexport interface FileMetadata {\n    path: string;\n    size: number;\n    sizeFormatted: string;\n    lines: number;\n    created: Date;\n    modified: Date;\n    exists: boolean;\n    type: OutputType;\n    status: 'current' | 'stale' | 'missing' | 'error';\n}\n\nexport interface FileBatch {\n    id: string;\n    timestamp: Date;\n    files: FileMetadata[];\n    command: string;\n    success: boolean;\n}\n\nexport interface FileWatchEvent {\n    type: 'created' | 'modified' | 'deleted';\n    file: OutputType;\n    path: string;\n    timestamp: Date;\n}\n\nexport class EnhancedFileManager {\n    private workspaceRoot: string;\n    private outputDirectory: string;\n    private watchers: Map<string, vscode.FileSystemWatcher> = new Map();\n    private fileHistory: FileBatch[] = [];\n    private maxHistoryItems = 50;\n\n    constructor() {\n        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';\n        this.outputDirectory = '';\n        this.updateOutputDirectory();\n        \n        // Listen for configuration changes\n        vscode.workspace.onDidChangeConfiguration((e) => {\n            if (e.affectsConfiguration('aiDebugUtilities.outputDirectory')) {\n                this.updateOutputDirectory();\n                this.recreateWatchers();\n            }\n        });\n    }\n\n    /**\n     * Update output directory from configuration\n     */\n    private updateOutputDirectory() {\n        const config = vscode.workspace.getConfiguration('aiDebugUtilities');\n        const configDir = config.get<string>('outputDirectory') || '.github/instructions/ai_utilities_context';\n        this.outputDirectory = path.join(this.workspaceRoot, configDir);\n    }\n\n    /**\n     * Get the output directory path\n     */\n    getOutputDirectory(): string {\n        return this.outputDirectory;\n    }\n\n    /**\n     * Create a backup of the current output directory\n     */\n    async createBackup(label?: string): Promise<string> {\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const backupLabel = label || 'manual';\n        const backupDir = path.join(\n            this.outputDirectory, \n            '..', \n            'backups', \n            `backup-${backupLabel}-${timestamp}`\n        );\n        \n        await this.ensureDirectoryExists(backupDir);\n        \n        const files = this.getAllOutputFiles();\n        let backedUpCount = 0;\n        \n        for (const file of files) {\n            if (file.exists) {\n                const backupPath = path.join(backupDir, path.basename(file.path));\n                try {\n                    await fs.promises.copyFile(file.path, backupPath);\n                    backedUpCount++;\n                } catch (error) {\n                    console.warn(`Failed to backup ${file.path}:`, error);\n                }\n            }\n        }\n        \n        // Create backup metadata\n        const metadata = {\n            timestamp: new Date(),\n            label: backupLabel,\n            files: backedUpCount,\n            originalPath: this.outputDirectory,\n            version: await this.getExtensionVersion()\n        };\n        \n        await fs.promises.writeFile(\n            path.join(backupDir, 'backup-metadata.json'),\n            JSON.stringify(metadata, null, 2)\n        );\n        \n        vscode.window.showInformationMessage(\n            `Backup created with ${backedUpCount} files: ${path.basename(backupDir)}`\n        );\n        \n        return backupDir;\n    }\n\n    /**\n     * Restore from a backup directory\n     */\n    async restoreFromBackup(backupPath: string): Promise<void> {\n        if (!fs.existsSync(backupPath)) {\n            throw new Error(`Backup directory not found: ${backupPath}`);\n        }\n        \n        // Read backup metadata if available\n        const metadataPath = path.join(backupPath, 'backup-metadata.json');\n        let metadata: any = null;\n        \n        if (fs.existsSync(metadataPath)) {\n            try {\n                metadata = JSON.parse(await fs.promises.readFile(metadataPath, 'utf8'));\n            } catch (error) {\n                console.warn('Failed to read backup metadata:', error);\n            }\n        }\n        \n        await this.ensureOutputDirectory();\n        \n        // Find all files in backup directory (excluding metadata)\n        const backupFiles = fs.readdirSync(backupPath)\n            .filter(file => file !== 'backup-metadata.json' && file.endsWith('.txt'));\n        \n        let restoredCount = 0;\n        \n        for (const file of backupFiles) {\n            const sourcePath = path.join(backupPath, file);\n            const targetPath = path.join(this.outputDirectory, file);\n            \n            try {\n                await fs.promises.copyFile(sourcePath, targetPath);\n                restoredCount++;\n            } catch (error) {\n                console.error(`Failed to restore ${file}:`, error);\n            }\n        }\n        \n        const backupInfo = metadata \n            ? ` from ${metadata.label} (${new Date(metadata.timestamp).toLocaleDateString()})`\n            : '';\n        \n        vscode.window.showInformationMessage(\n            `Restored ${restoredCount} files${backupInfo}`\n        );\n    }\n\n    /**\n     * Enhanced file saving with versioning and validation\n     */\n    async saveOutputWithVersioning(type: OutputType, content: string, options?: {\n        backup?: boolean;\n        validate?: boolean;\n    }): Promise<string> {\n        this.ensureOutputDirectory();\n        \n        const fileName = this.getFileName(type);\n        const filePath = path.join(this.outputDirectory, fileName);\n        \n        // Create backup if existing file and backup requested\n        if (options?.backup && fs.existsSync(filePath)) {\n            const backupPath = `${filePath}.backup.${Date.now()}`;\n            await fs.promises.copyFile(filePath, backupPath);\n        }\n        \n        // Validate content if requested\n        if (options?.validate) {\n            await this.validateFileContent(type, content);\n        }\n        \n        try {\n            await fs.promises.writeFile(filePath, content, 'utf8');\n            \n            // Add to file history\n            this.addToHistory(type, 'saved', filePath);\n            \n            return filePath;\n        } catch (error) {\n            throw new Error(`Failed to save ${type} output: ${error}`);\n        }\n    }\n\n    /**\n     * Validate file content based on type\n     */\n    private async validateFileContent(type: OutputType, content: string): Promise<void> {\n        switch (type) {\n            case 'jest-output':\n                if (!content.includes('Test') && !content.includes('PASS') && !content.includes('FAIL')) {\n                    console.warn('Jest output validation: Content may not be valid test output');\n                }\n                break;\n            case 'diff':\n                if (content.trim() && !content.includes('diff --git') && !content.includes('@@')) {\n                    console.warn('Diff validation: Content may not be valid diff output');\n                }\n                break;\n            case 'ai-debug-context':\n                if (!content.includes('AI DEBUG CONTEXT') && content.length < 100) {\n                    console.warn('AI context validation: Content seems too short or invalid');\n                }\n                break;\n            case 'pr-description':\n                if (!content.includes('PR DESCRIPTION') && content.length < 50) {\n                    console.warn('PR description validation: Content seems incomplete');\n                }\n                break;\n        }\n    }\n\n    /**\n     * Get comprehensive file metadata\n     */\n    async getFileMetadata(type: OutputType): Promise<FileMetadata> {\n        const filePath = this.getFilePath(type);\n        const exists = fs.existsSync(filePath);\n        \n        if (!exists) {\n            return {\n                path: filePath,\n                size: 0,\n                sizeFormatted: '0 B',\n                lines: 0,\n                created: new Date(0),\n                modified: new Date(0),\n                exists: false,\n                type,\n                status: 'missing'\n            };\n        }\n        \n        try {\n            const stats = fs.statSync(filePath);\n            const content = await fs.promises.readFile(filePath, 'utf8');\n            const lines = content.split('\\n').length;\n            \n            // Determine status\n            const age = Date.now() - stats.mtime.getTime();\n            const isStale = age > (24 * 60 * 60 * 1000); // 24 hours\n            \n            return {\n                path: filePath,\n                size: stats.size,\n                sizeFormatted: this.formatFileSize(stats.size),\n                lines,\n                created: stats.birthtime,\n                modified: stats.mtime,\n                exists: true,\n                type,\n                status: isStale ? 'stale' : 'current'\n            };\n        } catch (error) {\n            return {\n                path: filePath,\n                size: 0,\n                sizeFormatted: '0 B',\n                lines: 0,\n                created: new Date(0),\n                modified: new Date(0),\n                exists: true,\n                type,\n                status: 'error'\n            };\n        }\n    }\n\n    /**\n     * Get metadata for all output files\n     */\n    async getAllFileMetadata(): Promise<FileMetadata[]> {\n        const types: OutputType[] = ['ai-debug-context', 'jest-output', 'diff', 'pr-description'];\n        return Promise.all(types.map(type => this.getFileMetadata(type)));\n    }\n\n    /**\n     * Create file batch record for command execution\n     */\n    async createFileBatch(command: string, types: OutputType[], success: boolean): Promise<FileBatch> {\n        const batch: FileBatch = {\n            id: `${command}-${Date.now()}`,\n            timestamp: new Date(),\n            files: await Promise.all(types.map(type => this.getFileMetadata(type))),\n            command,\n            success\n        };\n        \n        this.fileHistory.unshift(batch);\n        \n        // Limit history size\n        if (this.fileHistory.length > this.maxHistoryItems) {\n            this.fileHistory = this.fileHistory.slice(0, this.maxHistoryItems);\n        }\n        \n        return batch;\n    }\n\n    /**\n     * Get file history\n     */\n    getFileHistory(): FileBatch[] {\n        return [...this.fileHistory];\n    }\n\n    /**\n     * Enhanced file watching with detailed events\n     */\n    watchOutputFiles(callback: (event: FileWatchEvent) => void): vscode.Disposable {\n        const watchId = `output-files-${Date.now()}`;\n        const pattern = new vscode.RelativePattern(this.outputDirectory, '*.txt');\n        const watcher = vscode.workspace.createFileSystemWatcher(pattern);\n        \n        const handleFileEvent = (type: 'created' | 'modified' | 'deleted') => \n            (uri: vscode.Uri) => {\n                const fileName = path.basename(uri.fsPath);\n                const outputType = this.getTypeFromFileName(fileName);\n                \n                if (outputType) {\n                    const event: FileWatchEvent = {\n                        type,\n                        file: outputType,\n                        path: uri.fsPath,\n                        timestamp: new Date()\n                    };\n                    \n                    callback(event);\n                }\n            };\n        \n        watcher.onDidCreate(handleFileEvent('created'));\n        watcher.onDidChange(handleFileEvent('modified'));\n        watcher.onDidDelete(handleFileEvent('deleted'));\n        \n        this.watchers.set(watchId, watcher);\n        \n        return {\n            dispose: () => {\n                watcher.dispose();\n                this.watchers.delete(watchId);\n            }\n        };\n    }\n\n    // Helper methods\n    private formatFileSize(bytes: number): string {\n        const units = ['B', 'KB', 'MB', 'GB'];\n        let size = bytes;\n        let unitIndex = 0;\n        \n        while (size >= 1024 && unitIndex < units.length - 1) {\n            size /= 1024;\n            unitIndex++;\n        }\n        \n        return `${Math.round(size * 100) / 100} ${units[unitIndex]}`;\n    }\n    \n    private async getExtensionVersion(): Promise<string> {\n        try {\n            const packagePath = path.join(__dirname, '..', '..', 'package.json');\n            const packageContent = await fs.promises.readFile(packagePath, 'utf8');\n            const packageJson = JSON.parse(packageContent);\n            return packageJson.version || '1.0.0';\n        } catch {\n            return '1.0.0';\n        }\n    }\n    \n    private addToHistory(type: OutputType, action: string, filePath: string): void {\n        // Add to internal history tracking if needed\n        console.log(`File ${action}: ${type} -> ${filePath}`);\n    }\n    \n    private recreateWatchers(): void {\n        // Dispose existing watchers and recreate them with new output directory\n        this.watchers.forEach(watcher => watcher.dispose());\n        this.watchers.clear();\n    }\n\n    // Include all existing methods from the original FileManager\n    ensureOutputDirectory(): void {\n        if (!fs.existsSync(this.outputDirectory)) {\n            fs.mkdirSync(this.outputDirectory, { recursive: true });\n        }\n    }\n\n    async saveOutput(type: OutputType, content: string): Promise<string> {\n        this.ensureOutputDirectory();\n        \n        const fileName = this.getFileName(type);\n        const filePath = path.join(this.outputDirectory, fileName);\n        \n        try {\n            fs.writeFileSync(filePath, content, 'utf8');\n            return filePath;\n        } catch (error) {\n            throw new Error(`Failed to save ${type} output: ${error}`);\n        }\n    }\n\n    async getFileContent(type: OutputType): Promise<string | null> {\n        const fileName = this.getFileName(type);\n        const filePath = path.join(this.outputDirectory, fileName);\n        \n        try {\n            if (fs.existsSync(filePath)) {\n                return fs.readFileSync(filePath, 'utf8');\n            }\n        } catch (error) {\n            console.error(`Failed to read ${type} file:`, error);\n        }\n        \n        return null;\n    }\n\n    async openFile(filePath: string): Promise<void> {\n        try {\n            const uri = vscode.Uri.file(filePath);\n            const document = await vscode.workspace.openTextDocument(uri);\n            await vscode.window.showTextDocument(document);\n        } catch (error) {\n            vscode.window.showErrorMessage(`Failed to open file: ${error}`);\n        }\n    }\n\n    getFilePath(type: OutputType): string {\n        const fileName = this.getFileName(type);\n        return path.join(this.outputDirectory, fileName);\n    }\n\n    fileExists(type: OutputType): boolean {\n        const filePath = this.getFilePath(type);\n        return fs.existsSync(filePath);\n    }\n\n    getFileModTime(type: OutputType): Date | null {\n        const filePath = this.getFilePath(type);\n        try {\n            if (fs.existsSync(filePath)) {\n                const stats = fs.statSync(filePath);\n                return stats.mtime;\n            }\n        } catch (error) {\n            console.error(`Failed to get file stats for ${type}:`, error);\n        }\n        return null;\n    }\n\n    getAllOutputFiles(): Array<{ type: OutputType; path: string; exists: boolean; modified?: Date }> {\n        const types: OutputType[] = ['ai-debug-context', 'jest-output', 'diff', 'pr-description'];\n        \n        return types.map(type => ({\n            type,\n            path: this.getFilePath(type),\n            exists: this.fileExists(type),\n            modified: this.getFileModTime(type) || undefined\n        }));\n    }\n\n    async cleanupOldFiles(maxAge: number = 7 * 24 * 60 * 60 * 1000): Promise<void> {\n        const now = Date.now();\n        const files = this.getAllOutputFiles();\n        \n        for (const file of files) {\n            if (file.exists && file.modified) {\n                const age = now - file.modified.getTime();\n                if (age > maxAge) {\n                    try {\n                        fs.unlinkSync(file.path);\n                        console.log(`Cleaned up old file: ${file.path}`);\n                    } catch (error) {\n                        console.error(`Failed to cleanup file ${file.path}:`, error);\n                    }\n                }\n            }\n        }\n    }\n\n    async copyToClipboard(type: OutputType): Promise<void> {\n        const content = await this.getFileContent(type);\n        if (content) {\n            await vscode.env.clipboard.writeText(content);\n            vscode.window.showInformationMessage(`${type} content copied to clipboard`);\n        } else {\n            vscode.window.showWarningMessage(`No ${type} file found`);\n        }\n    }\n\n    async initializeOutputFiles(types: string[]): Promise<Record<string, string>> {\n        this.ensureOutputDirectory();\n        const filePaths: Record<string, string> = {};\n        \n        for (const type of types) {\n            const fileName = this.getFileNameFromType(type);\n            filePaths[type] = path.join(this.outputDirectory, fileName);\n        }\n        \n        return filePaths;\n    }\n\n    async getOutputFilePath(fileName: string): Promise<string> {\n        this.ensureOutputDirectory();\n        return path.join(this.outputDirectory, fileName);\n    }\n\n    async ensureDirectoryExists(dirPath: string): Promise<void> {\n        if (!fs.existsSync(dirPath)) {\n            fs.mkdirSync(dirPath, { recursive: true });\n        }\n    }\n\n    async deleteFile(filePath: string): Promise<void> {\n        try {\n            if (fs.existsSync(filePath)) {\n                fs.unlinkSync(filePath);\n            }\n        } catch (error) {\n            // Ignore errors when deleting files\n        }\n    }\n\n    async writeFile(filePath: string, content: string): Promise<void> {\n        const dir = path.dirname(filePath);\n        await this.ensureDirectoryExists(dir);\n        fs.writeFileSync(filePath, content, 'utf8');\n    }\n\n    async readFile(filePath: string): Promise<string> {\n        return fs.readFileSync(filePath, 'utf8');\n    }\n\n    async getFileStats(filePath: string): Promise<{ size: string; lines: number }> {\n        try {\n            const stats = fs.statSync(filePath);\n            const content = fs.readFileSync(filePath, 'utf8');\n            const lines = content.split('\\n').length;\n            const sizeKB = Math.round(stats.size / 1024);\n            \n            return {\n                size: `${sizeKB}KB`,\n                lines\n            };\n        } catch (error) {\n            return {\n                size: '0KB',\n                lines: 0\n            };\n        }\n    }\n\n    private getFileNameFromType(type: string): string {\n        switch (type) {\n            case 'ai-debug-context':\n                return 'ai-debug-context.txt';\n            case 'jest-output':\n                return 'jest-output.txt';\n            case 'diff':\n                return 'diff.txt';\n            case 'pr-description-prompt':\n                return 'pr-description-prompt.txt';\n            default:\n                return `${type}.txt`;\n        }\n    }\n\n    private getFileName(type: OutputType): string {\n        switch (type) {\n            case 'ai-debug-context':\n                return 'ai-debug-context.txt';\n            case 'jest-output':\n                return 'jest-output.txt';\n            case 'diff':\n                return 'diff.txt';\n            case 'pr-description':\n                return 'pr-description-prompt.txt';\n            default:\n                throw new Error(`Unknown output type: ${type}`);\n        }\n    }\n\n    private getTypeFromFileName(fileName: string): OutputType | null {\n        switch (fileName) {\n            case 'ai-debug-context.txt':\n                return 'ai-debug-context';\n            case 'jest-output.txt':\n                return 'jest-output';\n            case 'diff.txt':\n                return 'diff';\n            case 'pr-description-prompt.txt':\n                return 'pr-description';\n            default:\n                return null;\n        }\n    }\n}\n\n// Export the original FileManager class name for backward compatibility\nexport class FileManager extends EnhancedFileManager {\n    // This maintains backward compatibility while providing enhanced features\n}"],"version":3}