049fc6fb6304160a0b57ecd9d898671f
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitDiffCommand = void 0;
const vscode = __importStar(require("vscode"));
const child_process_1 = require("child_process");
const fileManager_1 = require("../utils/fileManager");
class GitDiffCommand {
    fileManager;
    outputChannel;
    constructor() {
        this.outputChannel = vscode.window.createOutputChannel('AI Debug Utilities');
        this.fileManager = new fileManager_1.FileManager(this.outputChannel);
    }
    /**
     * Run Git Diff command with AI-optimized analysis
     */
    async run(options = {}) {
        const startTime = Date.now();
        try {
            // Skip diff if noDiff option is set
            if (options.noDiff) {
                const duration = Date.now() - startTime;
                return {
                    success: true,
                    exitCode: 0,
                    output: 'Diff skipped due to noDiff option',
                    duration
                };
            }
            const outputFile = this.fileManager.getOutputFilePath('diff.txt');
            // Ensure output directory exists
            await this.fileManager.ensureDirectoryExists(require('path').dirname(outputFile));
            // Smart diff detection
            const diffArgs = await this.detectSmartDiff();
            // Generate the diff
            const diffResult = await this.executeDiff(diffArgs);
            if (!diffResult.success) {
                const duration = Date.now() - startTime;
                return {
                    success: false,
                    exitCode: diffResult.exitCode,
                    output: diffResult.output,
                    error: diffResult.error,
                    duration
                };
            }
            // Process diff for AI context
            const processedOutput = await this.createAiDiffContext(diffResult.output, diffArgs);
            // Save to file
            await this.fileManager.writeFile(outputFile, processedOutput);
            // Show statistics
            const stats = await this.fileManager.getFileStats(outputFile);
            if (!stats || stats.size === 0) {
                this.showWarning("No diff output generated");
            }
            else {
                this.showSuccess(`Diff saved to: ${outputFile}`);
                this.showInfo(`üìä Size: ${stats.size} bytes`);
                // Quick content summary
                const filesChanged = this.countChangedFiles(processedOutput);
                this.showInfo(`üìà AI-optimized format: ${filesChanged} files analyzed`);
            }
            const duration = Date.now() - startTime;
            return {
                success: true,
                exitCode: 0,
                output: processedOutput,
                outputFiles: [outputFile],
                duration
            };
        }
        catch (error) {
            const duration = Date.now() - startTime;
            return {
                success: false,
                exitCode: 1,
                output: "",
                error: error instanceof Error ? error.message : 'Unknown error',
                duration
            };
        }
    }
    async detectSmartDiff() {
        this.showInfo("üîç Smart diff detection...");
        // Check for unstaged changes
        const unstagedResult = await this.executeGitCommand(['diff', '--quiet']);
        if (unstagedResult.exitCode !== 0) {
            // Has unstaged changes
            this.showInfo("üìù Using unstaged changes");
            return [];
        }
        // Check for staged changes
        const stagedResult = await this.executeGitCommand(['diff', '--cached', '--quiet']);
        if (stagedResult.exitCode !== 0) {
            // Has staged changes
            this.showInfo("üìÇ Using staged changes");
            return ['--cached'];
        }
        // No unstaged or staged changes, check for commits
        const hasCommits = await this.executeGitCommand(['rev-parse', '--verify', 'HEAD~1']);
        if (hasCommits.success) {
            this.showInfo("üìã Using last commit changes (no unstaged/staged changes found)");
            return ['HEAD~1..HEAD'];
        }
        // No changes found
        this.showWarning("No changes detected (initial commit or clean working directory)");
        return [];
    }
    async executeDiff(args) {
        if (args.length === 0) {
            this.showInfo("Running: git diff");
        }
        else {
            this.showInfo(`Running: git diff ${args.join(' ')}`);
        }
        return this.executeGitCommand(['diff', ...args]);
    }
    async executeGitCommand(args) {
        return new Promise((resolve) => {
            const process = (0, child_process_1.spawn)('git', args, {
                cwd: this.getWorkspaceRoot(),
                shell: false
            });
            let output = '';
            let errorOutput = '';
            process.stdout?.on('data', (data) => {
                output += data.toString();
            });
            process.stderr?.on('data', (data) => {
                errorOutput += data.toString();
            });
            process.on('close', (code) => {
                resolve({
                    success: code === 0,
                    exitCode: code || 0,
                    output,
                    error: errorOutput || undefined,
                    duration: 0
                });
            });
            process.on('error', (error) => {
                resolve({
                    success: false,
                    exitCode: 1,
                    output,
                    error: error.message,
                    duration: 0
                });
            });
        });
    }
    async createAiDiffContext(diffOutput, diffArgs) {
        if (!diffOutput.trim()) {
            return this.createNoChangesOutput();
        }
        const timestamp = new Date().toISOString();
        const branch = await this.getCurrentBranch();
        let output = `=================================================================
üîç AI-OPTIMIZED GIT DIFF ANALYSIS
=================================================================

COMMAND: git diff ${diffArgs.join(' ')}
TIMESTAMP: ${timestamp}
BRANCH: ${branch}

`;
        // Analyze the diff for file changes
        const analysis = this.analyzeDiffChanges(diffOutput);
        // Generate change summary
        output += `==================================================================
üìä CHANGE SUMMARY
==================================================================

Total files changed: ${analysis.totalChanges}

`;
        if (analysis.newFiles.length > 0) {
            output += `üÜï NEW FILES (${analysis.newFiles.length}):\n`;
            analysis.newFiles.forEach(file => {
                output += `  ‚Ä¢ ${file}\n`;
            });
            output += '\n';
        }
        if (analysis.modifiedFiles.length > 0) {
            output += `üìù MODIFIED FILES (${analysis.modifiedFiles.length}):\n`;
            analysis.modifiedFiles.forEach(file => {
                output += `  ‚Ä¢ ${file}\n`;
            });
            output += '\n';
        }
        if (analysis.deletedFiles.length > 0) {
            output += `üóëÔ∏è DELETED FILES (${analysis.deletedFiles.length}):\n`;
            analysis.deletedFiles.forEach(file => {
                output += `  ‚Ä¢ ${file}\n`;
            });
            output += '\n';
        }
        if (analysis.renamedFiles.length > 0) {
            output += `üì¶ RENAMED/MOVED FILES (${analysis.renamedFiles.length}):\n`;
            analysis.renamedFiles.forEach(file => {
                output += `  ‚Ä¢ ${file}\n`;
            });
            output += '\n';
        }
        // File type analysis
        output += `==================================================================
üè∑Ô∏è FILE TYPE ANALYSIS
==================================================================

`;
        output += this.analyzeFileTypes(diffOutput);
        // Add the actual diff with file separators
        output += `==================================================================
üìã DETAILED CHANGES
==================================================================

`;
        output += this.addFileSeparators(diffOutput);
        // Add AI analysis context
        output += `
==================================================================
ü§ñ AI ANALYSIS CONTEXT
==================================================================
Key areas for analysis:
‚Ä¢ Focus on test-related files (.spec.ts, .test.ts)
‚Ä¢ Look for type/interface changes that might break tests
‚Ä¢ Check for new functionality that needs test coverage
‚Ä¢ Identify breaking changes in method signatures
‚Ä¢ Review dependency changes and imports

Change impact areas:
`;
        if (analysis.newFiles.length > 0) {
            output += "‚Ä¢ New files may need comprehensive test coverage\n";
        }
        if (analysis.modifiedFiles.length > 0) {
            output += "‚Ä¢ Modified files may have broken existing tests\n";
        }
        if (analysis.deletedFiles.length > 0) {
            output += "‚Ä¢ Deleted files may have orphaned tests or dependencies\n";
        }
        return output;
    }
    analyzeDiffChanges(diffOutput) {
        const lines = diffOutput.split('\n');
        const newFiles = [];
        const modifiedFiles = [];
        const deletedFiles = [];
        const renamedFiles = [];
        let currentFileA = '';
        let currentFileB = '';
        let isProcessingFile = false;
        for (const line of lines) {
            const diffMatch = line.match(/^diff --git a\/(.*) b\/(.*)/);
            if (diffMatch) {
                currentFileA = diffMatch[1];
                currentFileB = diffMatch[2];
                isProcessingFile = true;
                // Check if it's a rename/move
                if (currentFileA !== currentFileB) {
                    renamedFiles.push(`${currentFileA} ‚Üí ${currentFileB}`);
                }
                continue;
            }
            if (isProcessingFile) {
                if (line.match(/^new file mode/)) {
                    newFiles.push(currentFileB);
                    isProcessingFile = false;
                }
                else if (line.match(/^deleted file mode/)) {
                    deletedFiles.push(currentFileA);
                    isProcessingFile = false;
                }
                else if (line.match(/^index.*\.\./) && currentFileA === currentFileB && !renamedFiles.some(f => f.includes(currentFileA))) {
                    modifiedFiles.push(currentFileA);
                    isProcessingFile = false;
                }
            }
        }
        const totalChanges = newFiles.length + modifiedFiles.length + deletedFiles.length + renamedFiles.length;
        return {
            newFiles,
            modifiedFiles,
            deletedFiles,
            renamedFiles,
            totalChanges
        };
    }
    analyzeFileTypes(diffOutput) {
        const lines = diffOutput.split('\n');
        const counts = {
            ts: 0,
            spec: 0,
            html: 0,
            css: 0,
            json: 0,
            other: 0
        };
        for (const line of lines) {
            const match = line.match(/^diff --git.*b\/(.*)/);
            if (match) {
                const file = match[1];
                if (file.match(/\.(spec|test)\.ts$/)) {
                    counts.spec++;
                }
                else if (file.endsWith('.ts')) {
                    counts.ts++;
                }
                else if (file.endsWith('.html')) {
                    counts.html++;
                }
                else if (file.match(/\.(css|scss|sass)$/)) {
                    counts.css++;
                }
                else if (file.endsWith('.json')) {
                    counts.json++;
                }
                else {
                    counts.other++;
                }
            }
        }
        let output = `TypeScript files: ${counts.ts}
Test files: ${counts.spec}
Templates: ${counts.html}
Styles: ${counts.css}
Config/JSON: ${counts.json}
Other: ${counts.other}

`;
        // AI insights based on file types
        if (counts.spec > 0) {
            output += "üß™ Test files modified - may fix or introduce test issues\n";
        }
        if (counts.ts > counts.spec) {
            output += "‚ö†Ô∏è  More source files than test files changed - check test coverage\n";
        }
        if (counts.json > 0) {
            output += "‚öôÔ∏è  Configuration changes detected - may affect build/test setup\n";
        }
        return output;
    }
    addFileSeparators(diffOutput) {
        const lines = diffOutput.split('\n');
        const result = [];
        for (const line of lines) {
            const match = line.match(/^diff --git a\/(.*) b\/(.*)/);
            if (match) {
                const currentFile = match[2];
                result.push(`üìÅ FILE: ${currentFile}`);
                result.push('‚îÄ'.repeat(40));
            }
            result.push(line);
        }
        return result.join('\n');
    }
    createNoChangesOutput() {
        const timestamp = new Date().toISOString();
        return `=================================================================
üîç GIT DIFF ANALYSIS
=================================================================

STATUS: No changes detected
TIMESTAMP: ${timestamp}

=================================================================
üìä REPOSITORY STATUS
=================================================================
Working directory: Clean
Staged changes: None

=================================================================
ü§ñ AI ANALYSIS CONTEXT
=================================================================
No code changes were found to analyze. This could mean:
‚Ä¢ Working directory is clean (all changes committed)
‚Ä¢ You're analyzing test failures without recent changes
‚Ä¢ Focus should be on existing code patterns or environment issues
‚Ä¢ Consider checking if tests were recently updated in previous commits

Suggested actions:
‚Ä¢ Review recent commit history: git log --oneline -10
‚Ä¢ Check if issue is environment-related rather than code-related
‚Ä¢ Examine test setup or configuration files
`;
    }
    async getCurrentBranch() {
        try {
            const result = await this.executeGitCommand(['branch', '--show-current']);
            return result.success ? result.output.trim() : 'unknown';
        }
        catch {
            return 'unknown';
        }
    }
    countChangedFiles(output) {
        const matches = output.match(/^üìÅ FILE:/gm);
        return matches ? matches.length : 0;
    }
    getWorkspaceRoot() {
        return vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
    }
    showInfo(message) {
        this.outputChannel.appendLine(message);
        this.outputChannel.show();
    }
    showSuccess(message) {
        this.showInfo(`‚úÖ ${message}`);
    }
    showWarning(message) {
        this.showInfo(`‚ö†Ô∏è  ${message}`);
    }
    showError(message) {
        this.showInfo(`‚ùå ${message}`);
    }
}
exports.GitDiffCommand = GitDiffCommand;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2dyZWdkdW5uL3NyYy90ZXN0L2FpX2RlYnVnX2NvbnRleHQvdnNjb2RlL3NyYy9jb21tYW5kcy9naXREaWZmLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUFpQztBQUNqQyxpREFBc0M7QUFFdEMsc0RBQW1EO0FBRW5ELE1BQWEsY0FBYztJQUNmLFdBQVcsQ0FBYztJQUN6QixhQUFhLENBQXVCO0lBRTVDO1FBQ0ksSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLHlCQUFXLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7T0FFRztJQUNILEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBMEIsRUFBRTtRQUNsQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFN0IsSUFBSSxDQUFDO1lBQ0Qsb0NBQW9DO1lBQ3BDLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNqQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsU0FBUyxDQUFDO2dCQUN4QyxPQUFPO29CQUNILE9BQU8sRUFBRSxJQUFJO29CQUNiLFFBQVEsRUFBRSxDQUFDO29CQUNYLE1BQU0sRUFBRSxtQ0FBbUM7b0JBQzNDLFFBQVE7aUJBQ1gsQ0FBQztZQUNOLENBQUM7WUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBRWxFLGlDQUFpQztZQUNqQyxNQUFNLElBQUksQ0FBQyxXQUFXLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBRWxGLHVCQUF1QjtZQUN2QixNQUFN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QyxPQUFlO1FBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFTyxXQUFXLENBQUMsT0FBZTtRQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sT0FBTyxFQUFFLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRU8sU0FBUyxDQUFDLE9BQWU7UUFDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDbEMsQ0FBQztDQUNKO0FBemRELHdDQXlkQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMvZ3JlZ2R1bm4vc3JjL3Rlc3QvYWlfZGVidWdfY29udGV4dC92c2NvZGUvc3JjL2NvbW1hbmRzL2dpdERpZmYudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdnNjb2RlIGZyb20gJ3ZzY29kZSc7XG5pbXBvcnQgeyBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgQ29tbWFuZE9wdGlvbnMsIENvbW1hbmRSZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBGaWxlTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL2ZpbGVNYW5hZ2VyJztcblxuZXhwb3J0IGNsYXNzIEdpdERpZmZDb21tYW5kIHtcbiAgICBwcml2YXRlIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlcjtcbiAgICBwcml2YXRlIG91dHB1dENoYW5uZWw6IHZzY29kZS5PdXRwdXRDaGFubmVsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbCA9IHZzY29kZS53aW5kb3cuY3JlYXRlT3V0cHV0Q2hhbm5lbCgnQUkgRGVidWcgVXRpbGl0aWVzJyk7XG4gICAgICAgIHRoaXMuZmlsZU1hbmFnZXIgPSBuZXcgRmlsZU1hbmFnZXIodGhpcy5vdXRwdXRDaGFubmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gR2l0IERpZmYgY29tbWFuZCB3aXRoIEFJLW9wdGltaXplZCBhbmFseXNpc1xuICAgICAqL1xuICAgIGFzeW5jIHJ1bihvcHRpb25zOiBDb21tYW5kT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxDb21tYW5kUmVzdWx0PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2tpcCBkaWZmIGlmIG5vRGlmZiBvcHRpb24gaXMgc2V0XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ub0RpZmYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogJ0RpZmYgc2tpcHBlZCBkdWUgdG8gbm9EaWZmIG9wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0RmlsZSA9IHRoaXMuZmlsZU1hbmFnZXIuZ2V0T3V0cHV0RmlsZVBhdGgoJ2RpZmYudHh0Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEVuc3VyZSBvdXRwdXQgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci5lbnN1cmVEaXJlY3RvcnlFeGlzdHMocmVxdWlyZSgncGF0aCcpLmRpcm5hbWUob3V0cHV0RmlsZSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTbWFydCBkaWZmIGRldGVjdGlvblxuICAgICAgICAgICAgY29uc3QgZGlmZkFyZ3MgPSBhd2FpdCB0aGlzLmRldGVjdFNtYXJ0RGlmZigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgZGlmZlxuICAgICAgICAgICAgY29uc3QgZGlmZlJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZURpZmYoZGlmZkFyZ3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWRpZmZSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXhpdENvZGU6IGRpZmZSZXN1bHQuZXhpdENvZGUsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogZGlmZlJlc3VsdC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBkaWZmUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgZGlmZiBmb3IgQUkgY29udGV4dFxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkT3V0cHV0ID0gYXdhaXQgdGhpcy5jcmVhdGVBaURpZmZDb250ZXh0KGRpZmZSZXN1bHQub3V0cHV0LCBkaWZmQXJncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNhdmUgdG8gZmlsZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci53cml0ZUZpbGUob3V0cHV0RmlsZSwgcHJvY2Vzc2VkT3V0cHV0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyBzdGF0aXN0aWNzXG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuZmlsZU1hbmFnZXIuZ2V0RmlsZVN0YXRzKG91dHB1dEZpbGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXN0YXRzIHx8IHN0YXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dXYXJuaW5nKFwiTm8gZGlmZiBvdXRwdXQgZ2VuZXJhdGVkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dTdWNjZXNzKGBEaWZmIHNhdmVkIHRvOiAke291dHB1dEZpbGV9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93SW5mbyhg8J+TiiBTaXplOiAke3N0YXRzLnNpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUXVpY2sgY29udGVudCBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXNDaGFuZ2VkID0gdGhpcy5jb3VudENoYW5nZWRGaWxlcyhwcm9jZXNzZWRPdXRwdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0luZm8oYPCfk4ggQUktb3B0aW1pemVkIGZvcm1hdDogJHtmaWxlc0NoYW5nZWR9IGZpbGVzIGFuYWx5emVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHByb2Nlc3NlZE91dHB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRGaWxlczogW291dHB1dEZpbGVdLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlOiAxLFxuICAgICAgICAgICAgICAgIG91dHB1dDogXCJcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICAgICAgZHVyYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGRldGVjdFNtYXJ0RGlmZigpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIHRoaXMuc2hvd0luZm8oXCLwn5SNIFNtYXJ0IGRpZmYgZGV0ZWN0aW9uLi4uXCIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHVuc3RhZ2VkIGNoYW5nZXNcbiAgICAgICAgY29uc3QgdW5zdGFnZWRSZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVHaXRDb21tYW5kKFsnZGlmZicsICctLXF1aWV0J10pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHVuc3RhZ2VkUmVzdWx0LmV4aXRDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBIYXMgdW5zdGFnZWQgY2hhbmdlc1xuICAgICAgICAgICAgdGhpcy5zaG93SW5mbyhcIvCfk50gVXNpbmcgdW5zdGFnZWQgY2hhbmdlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHN0YWdlZCBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IHN0YWdlZFJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUdpdENvbW1hbmQoWydkaWZmJywgJy0tY2FjaGVkJywgJy0tcXVpZXQnXSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhZ2VkUmVzdWx0LmV4aXRDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAvLyBIYXMgc3RhZ2VkIGNoYW5nZXNcbiAgICAgICAgICAgIHRoaXMuc2hvd0luZm8oXCLwn5OCIFVzaW5nIHN0YWdlZCBjaGFuZ2VzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFsnLS1jYWNoZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTm8gdW5zdGFnZWQgb3Igc3RhZ2VkIGNoYW5nZXMsIGNoZWNrIGZvciBjb21taXRzXG4gICAgICAgIGNvbnN0IGhhc0NvbW1pdHMgPSBhd2FpdCB0aGlzLmV4ZWN1dGVHaXRDb21tYW5kKFsncmV2LXBhcnNlJywgJy0tdmVyaWZ5JywgJ0hFQUR+MSddKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChoYXNDb21taXRzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0luZm8oXCLwn5OLIFVzaW5nIGxhc3QgY29tbWl0IGNoYW5nZXMgKG5vIHVuc3RhZ2VkL3N0YWdlZCBjaGFuZ2VzIGZvdW5kKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBbJ0hFQUR+MS4uSEVBRCddO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBObyBjaGFuZ2VzIGZvdW5kXG4gICAgICAgIHRoaXMuc2hvd1dhcm5pbmcoXCJObyBjaGFuZ2VzIGRldGVjdGVkIChpbml0aWFsIGNvbW1pdCBvciBjbGVhbiB3b3JraW5nIGRpcmVjdG9yeSlcIik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVEaWZmKGFyZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxDb21tYW5kUmVzdWx0PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zaG93SW5mbyhcIlJ1bm5pbmc6IGdpdCBkaWZmXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93SW5mbyhgUnVubmluZzogZ2l0IGRpZmYgJHthcmdzLmpvaW4oJyAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUdpdENvbW1hbmQoWydkaWZmJywgLi4uYXJnc10pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZXhlY3V0ZUdpdENvbW1hbmQoYXJnczogc3RyaW5nW10pOiBQcm9taXNlPENvbW1hbmRSZXN1bHQ+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzID0gc3Bhd24oJ2dpdCcsIGFyZ3MsIHtcbiAgICAgICAgICAgICAgICBjd2Q6IHRoaXMuZ2V0V29ya3NwYWNlUm9vdCgpLFxuICAgICAgICAgICAgICAgIHNoZWxsOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGxldCBlcnJvck91dHB1dCA9ICcnO1xuXG4gICAgICAgICAgICBwcm9jZXNzLnN0ZG91dD8ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnI/Lm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBlcnJvck91dHB1dCArPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBjb2RlID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBleGl0Q29kZTogY29kZSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck91dHB1dCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcHJvY2Vzcy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb2RlOiAxLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgY3JlYXRlQWlEaWZmQ29udGV4dChkaWZmT3V0cHV0OiBzdHJpbmcsIGRpZmZBcmdzOiBzdHJpbmdbXSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGlmICghZGlmZk91dHB1dC50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5vQ2hhbmdlc091dHB1dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBicmFuY2ggPSBhd2FpdCB0aGlzLmdldEN1cnJlbnRCcmFuY2goKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBvdXRwdXQgPSBgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbvCflI0gQUktT1BUSU1JWkVEIEdJVCBESUZGIEFOQUxZU0lTXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5DT01NQU5EOiBnaXQgZGlmZiAke2RpZmZBcmdzLmpvaW4oJyAnKX1cblRJTUVTVEFNUDogJHt0aW1lc3RhbXB9XG5CUkFOQ0g6ICR7YnJhbmNofVxuXG5gO1xuXG4gICAgICAgIC8vIEFuYWx5emUgdGhlIGRpZmYgZm9yIGZpbGUgY2hhbmdlc1xuICAgICAgICBjb25zdCBhbmFseXNpcyA9IHRoaXMuYW5hbHl6ZURpZmZDaGFuZ2VzKGRpZmZPdXRwdXQpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgY2hhbmdlIHN1bW1hcnlcbiAgICAgICAgb3V0cHV0ICs9IGA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbvCfk4ogQ0hBTkdFIFNVTU1BUllcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5Ub3RhbCBmaWxlcyBjaGFuZ2VkOiAke2FuYWx5c2lzLnRvdGFsQ2hhbmdlc31cblxuYDtcblxuICAgICAgICBpZiAoYW5hbHlzaXMubmV3RmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGDwn4aVIE5FVyBGSUxFUyAoJHthbmFseXNpcy5uZXdGaWxlcy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICAgICAgYW5hbHlzaXMubmV3RmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCAg4oCiICR7ZmlsZX1cXG5gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5hbHlzaXMubW9kaWZpZWRGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYPCfk50gTU9ESUZJRUQgRklMRVMgKCR7YW5hbHlzaXMubW9kaWZpZWRGaWxlcy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICAgICAgYW5hbHlzaXMubW9kaWZpZWRGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBgICDigKIgJHtmaWxlfVxcbmA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG91dHB1dCArPSAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmFseXNpcy5kZWxldGVkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGDwn5eR77iPIERFTEVURUQgRklMRVMgKCR7YW5hbHlzaXMuZGVsZXRlZEZpbGVzLmxlbmd0aH0pOlxcbmA7XG4gICAgICAgICAgICBhbmFseXNpcy5kZWxldGVkRmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYCAg4oCiICR7ZmlsZX1cXG5gO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5hbHlzaXMucmVuYW1lZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBg8J+TpiBSRU5BTUVEL01PVkVEIEZJTEVTICgke2FuYWx5c2lzLnJlbmFtZWRGaWxlcy5sZW5ndGh9KTpcXG5gO1xuICAgICAgICAgICAgYW5hbHlzaXMucmVuYW1lZEZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAgIOKAoiAke2ZpbGV9XFxuYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsZSB0eXBlIGFuYWx5c2lzXG4gICAgICAgIG91dHB1dCArPSBgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG7wn4+377iPIEZJTEUgVFlQRSBBTkFMWVNJU1xuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmA7XG4gICAgICAgIG91dHB1dCArPSB0aGlzLmFuYWx5emVGaWxlVHlwZXMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBhY3R1YWwgZGlmZiB3aXRoIGZpbGUgc2VwYXJhdG9yc1xuICAgICAgICBvdXRwdXQgKz0gYD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxu8J+TiyBERVRBSUxFRCBDSEFOR0VTXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuYDtcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMuYWRkRmlsZVNlcGFyYXRvcnMoZGlmZk91dHB1dCk7XG5cbiAgICAgICAgLy8gQWRkIEFJIGFuYWx5c2lzIGNvbnRleHRcbiAgICAgICAgb3V0cHV0ICs9IGBcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxu8J+kliBBSSBBTkFMWVNJUyBDT05URVhUXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbktleSBhcmVhcyBmb3IgYW5hbHlzaXM6XG7igKIgRm9jdXMgb24gdGVzdC1yZWxhdGVkIGZpbGVzICguc3BlYy50cywgLnRlc3QudHMpXG7igKIgTG9vayBmb3IgdHlwZS9pbnRlcmZhY2UgY2hhbmdlcyB0aGF0IG1pZ2h0IGJyZWFrIHRlc3RzXG7igKIgQ2hlY2sgZm9yIG5ldyBmdW5jdGlvbmFsaXR5IHRoYXQgbmVlZHMgdGVzdCBjb3ZlcmFnZVxu4oCiIElkZW50aWZ5IGJyZWFraW5nIGNoYW5nZXMgaW4gbWV0aG9kIHNpZ25hdHVyZXNcbuKAoiBSZXZpZXcgZGVwZW5kZW5jeSBjaGFuZ2VzIGFuZCBpbXBvcnRzXG5cbkNoYW5nZSBpbXBhY3QgYXJlYXM6XG5gO1xuXG4gICAgICAgIGlmIChhbmFseXNpcy5uZXdGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCLigKIgTmV3IGZpbGVzIG1heSBuZWVkIGNvbXByZWhlbnNpdmUgdGVzdCBjb3ZlcmFnZVxcblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmFseXNpcy5tb2RpZmllZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIuKAoiBNb2RpZmllZCBmaWxlcyBtYXkgaGF2ZSBicm9rZW4gZXhpc3RpbmcgdGVzdHNcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5hbHlzaXMuZGVsZXRlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIuKAoiBEZWxldGVkIGZpbGVzIG1heSBoYXZlIG9ycGhhbmVkIHRlc3RzIG9yIGRlcGVuZGVuY2llc1xcblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFuYWx5emVEaWZmQ2hhbmdlcyhkaWZmT3V0cHV0OiBzdHJpbmcpOiB7XG4gICAgICAgIG5ld0ZpbGVzOiBzdHJpbmdbXTtcbiAgICAgICAgbW9kaWZpZWRGaWxlczogc3RyaW5nW107XG4gICAgICAgIGRlbGV0ZWRGaWxlczogc3RyaW5nW107XG4gICAgICAgIHJlbmFtZWRGaWxlczogc3RyaW5nW107XG4gICAgICAgIHRvdGFsQ2hhbmdlczogbnVtYmVyO1xuICAgIH0ge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGRpZmZPdXRwdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBuZXdGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRGaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgZGVsZXRlZEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCByZW5hbWVkRmlsZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIFxuICAgICAgICBsZXQgY3VycmVudEZpbGVBID0gJyc7XG4gICAgICAgIGxldCBjdXJyZW50RmlsZUIgPSAnJztcbiAgICAgICAgbGV0IGlzUHJvY2Vzc2luZ0ZpbGUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3QgZGlmZk1hdGNoID0gbGluZS5tYXRjaCgvXmRpZmYgLS1naXQgYVxcLyguKikgYlxcLyguKikvKTtcbiAgICAgICAgICAgIGlmIChkaWZmTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RmlsZUEgPSBkaWZmTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgY3VycmVudEZpbGVCID0gZGlmZk1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIGlzUHJvY2Vzc2luZ0ZpbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSByZW5hbWUvbW92ZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmlsZUEgIT09IGN1cnJlbnRGaWxlQikge1xuICAgICAgICAgICAgICAgICAgICByZW5hbWVkRmlsZXMucHVzaChgJHtjdXJyZW50RmlsZUF9IOKGkiAke2N1cnJlbnRGaWxlQn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmdGaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubWF0Y2goL15uZXcgZmlsZSBtb2RlLykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmlsZXMucHVzaChjdXJyZW50RmlsZUIpO1xuICAgICAgICAgICAgICAgICAgICBpc1Byb2Nlc3NpbmdGaWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9eZGVsZXRlZCBmaWxlIG1vZGUvKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmlsZXMucHVzaChjdXJyZW50RmlsZUEpO1xuICAgICAgICAgICAgICAgICAgICBpc1Byb2Nlc3NpbmdGaWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9eaW5kZXguKlxcLlxcLi8pICYmIGN1cnJlbnRGaWxlQSA9PT0gY3VycmVudEZpbGVCICYmICFyZW5hbWVkRmlsZXMuc29tZShmID0+IGYuaW5jbHVkZXMoY3VycmVudEZpbGVBKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRGaWxlcy5wdXNoKGN1cnJlbnRGaWxlQSk7XG4gICAgICAgICAgICAgICAgICAgIGlzUHJvY2Vzc2luZ0ZpbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRvdGFsQ2hhbmdlcyA9IG5ld0ZpbGVzLmxlbmd0aCArIG1vZGlmaWVkRmlsZXMubGVuZ3RoICsgZGVsZXRlZEZpbGVzLmxlbmd0aCArIHJlbmFtZWRGaWxlcy5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV3RmlsZXMsXG4gICAgICAgICAgICBtb2RpZmllZEZpbGVzLFxuICAgICAgICAgICAgZGVsZXRlZEZpbGVzLFxuICAgICAgICAgICAgcmVuYW1lZEZpbGVzLFxuICAgICAgICAgICAgdG90YWxDaGFuZ2VzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhbmFseXplRmlsZVR5cGVzKGRpZmZPdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGlmZk91dHB1dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGNvbnN0IGNvdW50cyA9IHtcbiAgICAgICAgICAgIHRzOiAwLFxuICAgICAgICAgICAgc3BlYzogMCxcbiAgICAgICAgICAgIGh0bWw6IDAsXG4gICAgICAgICAgICBjc3M6IDAsXG4gICAgICAgICAgICBqc29uOiAwLFxuICAgICAgICAgICAgb3RoZXI6IDBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eZGlmZiAtLWdpdC4qYlxcLyguKikvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5tYXRjaCgvXFwuKHNwZWN8dGVzdClcXC50cyQvKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudHMuc3BlYysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZS5lbmRzV2l0aCgnLnRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRzLnRzKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlLmVuZHNXaXRoKCcuaHRtbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50cy5odG1sKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlLm1hdGNoKC9cXC4oY3NzfHNjc3N8c2FzcykkLykpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRzLmNzcysrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZS5lbmRzV2l0aCgnLmpzb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudHMuanNvbisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50cy5vdGhlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IG91dHB1dCA9IGBUeXBlU2NyaXB0IGZpbGVzOiAke2NvdW50cy50c31cblRlc3QgZmlsZXM6ICR7Y291bnRzLnNwZWN9XG5UZW1wbGF0ZXM6ICR7Y291bnRzLmh0bWx9XG5TdHlsZXM6ICR7Y291bnRzLmNzc31cbkNvbmZpZy9KU09OOiAke2NvdW50cy5qc29ufVxuT3RoZXI6ICR7Y291bnRzLm90aGVyfVxuXG5gO1xuICAgICAgICBcbiAgICAgICAgLy8gQUkgaW5zaWdodHMgYmFzZWQgb24gZmlsZSB0eXBlc1xuICAgICAgICBpZiAoY291bnRzLnNwZWMgPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCLwn6eqIFRlc3QgZmlsZXMgbW9kaWZpZWQgLSBtYXkgZml4IG9yIGludHJvZHVjZSB0ZXN0IGlzc3Vlc1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudHMudHMgPiBjb3VudHMuc3BlYykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IFwi4pqg77iPICBNb3JlIHNvdXJjZSBmaWxlcyB0aGFuIHRlc3QgZmlsZXMgY2hhbmdlZCAtIGNoZWNrIHRlc3QgY292ZXJhZ2VcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnRzLmpzb24gPiAwKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gXCLimpnvuI8gIENvbmZpZ3VyYXRpb24gY2hhbmdlcyBkZXRlY3RlZCAtIG1heSBhZmZlY3QgYnVpbGQvdGVzdCBzZXR1cFxcblwiO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkRmlsZVNlcGFyYXRvcnMoZGlmZk91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBkaWZmT3V0cHV0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goL15kaWZmIC0tZ2l0IGFcXC8oLiopIGJcXC8oLiopLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmlsZSA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGDwn5OBIEZJTEU6ICR7Y3VycmVudEZpbGV9YCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ+KUgCcucmVwZWF0KDQwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZU5vQ2hhbmdlc091dHB1dCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG7wn5SNIEdJVCBESUZGIEFOQUxZU0lTXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5TVEFUVVM6IE5vIGNoYW5nZXMgZGV0ZWN0ZWRcblRJTUVTVEFNUDogJHt0aW1lc3RhbXB9XG5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG7wn5OKIFJFUE9TSVRPUlkgU1RBVFVTXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuV29ya2luZyBkaXJlY3Rvcnk6IENsZWFuXG5TdGFnZWQgY2hhbmdlczogTm9uZVxuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxu8J+kliBBSSBBTkFMWVNJUyBDT05URVhUXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuTm8gY29kZSBjaGFuZ2VzIHdlcmUgZm91bmQgdG8gYW5hbHl6ZS4gVGhpcyBjb3VsZCBtZWFuOlxu4oCiIFdvcmtpbmcgZGlyZWN0b3J5IGlzIGNsZWFuIChhbGwgY2hhbmdlcyBjb21taXR0ZWQpXG7igKIgWW91J3JlIGFuYWx5emluZyB0ZXN0IGZhaWx1cmVzIHdpdGhvdXQgcmVjZW50IGNoYW5nZXNcbuKAoiBGb2N1cyBzaG91bGQgYmUgb24gZXhpc3RpbmcgY29kZSBwYXR0ZXJucyBvciBlbnZpcm9ubWVudCBpc3N1ZXNcbuKAoiBDb25zaWRlciBjaGVja2luZyBpZiB0ZXN0cyB3ZXJlIHJlY2VudGx5IHVwZGF0ZWQgaW4gcHJldmlvdXMgY29tbWl0c1xuXG5TdWdnZXN0ZWQgYWN0aW9uczpcbuKAoiBSZXZpZXcgcmVjZW50IGNvbW1pdCBoaXN0b3J5OiBnaXQgbG9nIC0tb25lbGluZSAtMTBcbuKAoiBDaGVjayBpZiBpc3N1ZSBpcyBlbnZpcm9ubWVudC1yZWxhdGVkIHJhdGhlciB0aGFuIGNvZGUtcmVsYXRlZFxu4oCiIEV4YW1pbmUgdGVzdCBzZXR1cCBvciBjb25maWd1cmF0aW9uIGZpbGVzXG5gO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Q3VycmVudEJyYW5jaCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlR2l0Q29tbWFuZChbJ2JyYW5jaCcsICctLXNob3ctY3VycmVudCddKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHJlc3VsdC5vdXRwdXQudHJpbSgpIDogJ3Vua25vd24nO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNvdW50Q2hhbmdlZEZpbGVzKG91dHB1dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG91dHB1dC5tYXRjaCgvXvCfk4EgRklMRTovZ20pO1xuICAgICAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFdvcmtzcGFjZVJvb3QoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHZzY29kZS53b3Jrc3BhY2Uud29ya3NwYWNlRm9sZGVycz8uWzBdPy51cmkuZnNQYXRoIHx8ICcnO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd0luZm8obWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm91dHB1dENoYW5uZWwuc2hvdygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hvd1N1Y2Nlc3MobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2hvd0luZm8oYOKchSAke21lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG93V2FybmluZyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zaG93SW5mbyhg4pqg77iPICAke21lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG93RXJyb3IobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2hvd0luZm8oYOKdjCAke21lc3NhZ2V9YCk7XG4gICAgfVxufVxuIl0sInZlcnNpb24iOjN9