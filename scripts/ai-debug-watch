#!/usr/bin/env bash
# ai-debug-watch - Real-time test execution on file changes
# Part of AI Debug Context V3 - Shell-first architecture
# Compatible with bash 4+, zsh 5+, fish 3+

set -euo pipefail

# Script metadata
readonly SCRIPT_NAME="ai-debug-watch"
readonly VERSION="3.0.0"

# Default configuration
readonly DEFAULT_DEBOUNCE_TIME=2
readonly DEFAULT_WATCH_PATTERNS="*.ts,*.js"
readonly DEFAULT_EXCLUDE_PATTERNS="*.spec.ts,*.test.ts,*.spec.js,*.test.js,*.d.ts"

# Color output (if terminal supports it)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1; then
    readonly RED=$(tput setaf 1)
    readonly GREEN=$(tput setaf 2)
    readonly YELLOW=$(tput setaf 3)
    readonly BLUE=$(tput setaf 4)
    readonly BOLD=$(tput bold)
    readonly RESET=$(tput sgr0)
else
    readonly RED=""
    readonly GREEN=""
    readonly YELLOW=""
    readonly BLUE=""
    readonly BOLD=""
    readonly RESET=""
fi

# Global variables for cleanup
WATCH_PID=""
DEBOUNCE_PID=""
TEMP_FILES=()

# Logging functions
log_info() {
    echo "${BLUE}[INFO]${RESET} $*" >&2
}

log_warn() {
    echo "${YELLOW}[WARN]${RESET} $*" >&2
}

log_error() {
    echo "${RED}[ERROR]${RESET} $*" >&2
}

log_success() {
    echo "${GREEN}[SUCCESS]${RESET} $*" >&2
}

log_watch() {
    echo "${YELLOW}[WATCH]${RESET} $*" >&2
}

# Show usage information
show_usage() {
    cat << EOF
${BOLD}$SCRIPT_NAME${RESET} - Real-time test execution on file changes

${BOLD}USAGE:${RESET}
    $SCRIPT_NAME [OPTIONS] [DIRECTORY]

${BOLD}OPTIONS:${RESET}
    -d, --debounce SEC      Debounce time in seconds (default: $DEFAULT_DEBOUNCE_TIME)
    -p, --patterns GLOB     File patterns to watch (default: $DEFAULT_WATCH_PATTERNS)
    -e, --exclude GLOB      Patterns to exclude (default: $DEFAULT_EXCLUDE_PATTERNS)
    -c, --concurrency NUM   Parallel test execution (default: auto)
    -v, --verbose           Enable verbose output
    -q, --quiet             Suppress normal output, show only errors
    --dry-run              Show what would be watched without starting
    -h, --help             Show this help message
    --version              Show version information

${BOLD}EXAMPLES:${RESET}
    $SCRIPT_NAME                              # Watch current directory
    $SCRIPT_NAME ./src                        # Watch specific directory
    $SCRIPT_NAME --debounce 1                 # Faster response (1 second)
    $SCRIPT_NAME --patterns "*.ts"            # Watch only TypeScript files
    $SCRIPT_NAME --exclude "*.spec.ts,dist/*" # Custom exclusions

${BOLD}DESCRIPTION:${RESET}
    Watches for file changes and automatically runs affected tests with
    real-time feedback. Uses cross-platform file watching (inotify, fswatch,
    or polling) with intelligent debouncing to prevent excessive test runs.

${BOLD}PERFORMANCE:${RESET}
    - Cross-platform file watching (Linux, macOS, Windows/WSL)
    - Intelligent debouncing prevents test spam during rapid changes
    - Automatic affected test detection (only runs changed tests)
    - Parallel test execution for maximum speed
    - Target: <2 second feedback from file save to test results

${BOLD}PLATFORMS:${RESET}
    - Linux: Uses inotify (install inotify-tools for best performance)
    - macOS: Uses fswatch (install via: brew install fswatch)
    - Windows/WSL: Uses polling fallback (works everywhere)
    - Fallback: Polling mode works on any POSIX system

EOF
}

# Show version information
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Detect best available file watching tool
detect_file_watcher() {
    if command -v inotifywait >/dev/null 2>&1; then
        echo "inotify"
    elif command -v fswatch >/dev/null 2>&1; then
        echo "fswatch"
    else
        echo "polling"
    fi
}

# Check if other required scripts are available
check_dependencies() {
    local script_dir
    script_dir="$(dirname "${BASH_SOURCE[0]}")"
    
    if [[ ! -f "$script_dir/ai-debug-affected-tests" ]]; then
        log_error "Required script not found: $script_dir/ai-debug-affected-tests"
        log_error "Please ensure all AI Debug Context scripts are in the same directory"
        return 1
    fi
    
    if [[ ! -x "$script_dir/ai-debug-affected-tests" ]]; then
        log_error "Script not executable: $script_dir/ai-debug-affected-tests"
        log_error "Run: chmod +x $script_dir/ai-debug-affected-tests"
        return 1
    fi
    
    return 0
}

# Linux file watching using inotify
watch_with_inotify() {
    local watch_dir="$1"
    local patterns="$2"
    local exclude_patterns="$3"
    local debounce_time="$4"
    local verbose="$5"
    
    log_info "Using inotify for file watching (Linux)"
    
    # Build inotify include/exclude patterns
    local inotify_include=""
    local inotify_exclude=""
    
    # Convert comma-separated patterns to regex
    IFS=',' read -ra PATTERN_ARRAY <<< "$patterns"
    for pattern in "${PATTERN_ARRAY[@]}"; do
        # Convert glob pattern to regex
        local regex_pattern
        regex_pattern=$(echo "$pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\./g')
        if [[ -z "$inotify_include" ]]; then
            inotify_include="$regex_pattern"
        else
            inotify_include="$inotify_include|$regex_pattern"
        fi
    done
    
    IFS=',' read -ra EXCLUDE_ARRAY <<< "$exclude_patterns"
    for pattern in "${EXCLUDE_ARRAY[@]}"; do
        local regex_pattern
        regex_pattern=$(echo "$pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\./g')
        if [[ -z "$inotify_exclude" ]]; then
            inotify_exclude="$regex_pattern"
        else
            inotify_exclude="$inotify_exclude|$regex_pattern"
        fi
    done
    
    if [[ "$verbose" == "true" ]]; then
        log_info "Include patterns: $inotify_include"
        log_info "Exclude patterns: $inotify_exclude"
    fi
    
    # Start inotify monitoring
    inotifywait -m -r -e modify,create,delete,move \
        --include "($inotify_include)$" \
        --exclude "($inotify_exclude)$" \
        --format '%w%f' \
        "$watch_dir" 2>/dev/null | while read -r file_path; do
        
        if [[ "$verbose" == "true" ]]; then
            log_watch "File changed: $file_path"
        fi
        
        handle_file_change "$file_path" "$debounce_time" "$verbose"
    done
}

# macOS file watching using fswatch
watch_with_fswatch() {
    local watch_dir="$1"
    local patterns="$2"
    local exclude_patterns="$3"
    local debounce_time="$4"
    local verbose="$5"
    
    log_info "Using fswatch for file watching (macOS)"
    
    # Build fswatch include/exclude arguments
    local fswatch_args=()
    fswatch_args+=("-r")  # recursive
    fswatch_args+=("--event=Updated")
    fswatch_args+=("--event=Created")
    fswatch_args+=("--event=Removed")
    fswatch_args+=("--event=Renamed")
    
    # Add include patterns
    IFS=',' read -ra PATTERN_ARRAY <<< "$patterns"
    for pattern in "${PATTERN_ARRAY[@]}"; do
        # Convert glob to regex for fswatch
        local regex_pattern
        regex_pattern=$(echo "$pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\./g')
        fswatch_args+=("--include=$regex_pattern")
    done
    
    # Add exclude patterns
    IFS=',' read -ra EXCLUDE_ARRAY <<< "$exclude_patterns"
    for pattern in "${EXCLUDE_ARRAY[@]}"; do
        local regex_pattern
        regex_pattern=$(echo "$pattern" | sed 's/\*/\.\*/g' | sed 's/\?/\./g')
        fswatch_args+=("--exclude=$regex_pattern")
    done
    
    if [[ "$verbose" == "true" ]]; then
        log_info "fswatch args: ${fswatch_args[*]}"
    fi
    
    # Start fswatch monitoring
    fswatch "${fswatch_args[@]}" "$watch_dir" | while read -r file_path; do
        if [[ "$verbose" == "true" ]]; then
            log_watch "File changed: $file_path"
        fi
        
        handle_file_change "$file_path" "$debounce_time" "$verbose"
    done
}

# Fallback polling for universal compatibility
watch_with_polling() {
    local watch_dir="$1"
    local patterns="$2"
    local exclude_patterns="$3"
    local debounce_time="$4"
    local verbose="$5"
    
    log_info "Using polling for file watching (universal fallback)"
    log_warn "For better performance, install inotify-tools (Linux) or fswatch (macOS)"
    
    local last_check_file="/tmp/ai_debug_watch_last_check_$$"
    touch "$last_check_file"
    TEMP_FILES+=("$last_check_file")
    
    # Convert patterns to find arguments
    local find_args=()
    IFS=',' read -ra PATTERN_ARRAY <<< "$patterns"
    local first_pattern=true
    for pattern in "${PATTERN_ARRAY[@]}"; do
        if [[ "$first_pattern" == "true" ]]; then
            find_args+=("-name" "$pattern")
            first_pattern=false
        else
            find_args+=("-o" "-name" "$pattern")
        fi
    done
    
    # Build exclude conditions
    local exclude_args=()
    IFS=',' read -ra EXCLUDE_ARRAY <<< "$exclude_patterns"
    for pattern in "${EXCLUDE_ARRAY[@]}"; do
        exclude_args+=("!" "-name" "$pattern")
    done
    
    if [[ "$verbose" == "true" ]]; then
        log_info "Find patterns: ${find_args[*]}"
        log_info "Exclude patterns: ${exclude_args[*]}"
    fi
    
    while true; do
        # Find files modified since last check
        local changed_files
        changed_files=$(find "$watch_dir" -type f \
            \( "${find_args[@]}" \) \
            "${exclude_args[@]}" \
            -newer "$last_check_file" \
            2>/dev/null || true)
        
        if [[ -n "$changed_files" ]]; then
            while IFS= read -r file_path; do
                if [[ -n "$file_path" ]]; then
                    if [[ "$verbose" == "true" ]]; then
                        log_watch "File changed: $file_path"
                    fi
                    handle_file_change "$file_path" "$debounce_time" "$verbose"
                fi
            done <<< "$changed_files"
        fi
        
        # Update last check timestamp
        touch "$last_check_file"
        
        # Sleep before next poll (use half of debounce time for responsiveness)
        local poll_interval=$((debounce_time > 2 ? debounce_time / 2 : 1))
        sleep "$poll_interval"
    done
}

# Handle file change with debouncing
handle_file_change() {
    local changed_file="$1"
    local debounce_time="$2"
    local verbose="$3"
    
    local lockfile="/tmp/ai_debug_watch_debounce_$$"
    
    # Check if we're already in debounce period
    if [[ -f "$lockfile" ]]; then
        if [[ "$verbose" == "true" ]]; then
            log_watch "Debouncing change for: $changed_file"
        fi
        return 0
    fi
    
    # Start debounce period
    touch "$lockfile"
    TEMP_FILES+=("$lockfile")
    
    # Kill any existing debounce process
    if [[ -n "$DEBOUNCE_PID" ]]; then
        kill "$DEBOUNCE_PID" 2>/dev/null || true
    fi
    
    # Start new debounce process in background
    (
        sleep "$debounce_time"
        
        # Check if file still exists (might have been deleted)
        if [[ -f "$changed_file" ]]; then
            execute_affected_tests "$changed_file" "$verbose"
        fi
        
        # Remove debounce lock
        rm -f "$lockfile"
    ) &
    
    DEBOUNCE_PID=$!
}

# Execute affected tests for the changed file
execute_affected_tests() {
    local changed_file="$1"
    local verbose="$2"
    local script_dir
    
    script_dir="$(dirname "${BASH_SOURCE[0]}")"
    
    log_watch "Running tests for: $changed_file"
    
    # Create temporary file with the changed file
    local temp_input="/tmp/ai_debug_watch_input_$$"
    echo "$changed_file" > "$temp_input"
    TEMP_FILES+=("$temp_input")
    
    # Build arguments for affected tests script
    local affected_args=()
    if [[ "$verbose" == "true" ]]; then
        affected_args+=("--verbose")
    fi
    
    # Execute affected tests script
    local start_time end_time duration exit_code=0
    start_time=$(date +%s)
    
    if "$script_dir/ai-debug-affected-tests" "${affected_args[@]}" < "$temp_input"; then
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        log_success "Tests completed in ${duration}s"
    else
        exit_code=$?
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        log_error "Tests failed in ${duration}s (exit code: $exit_code)"
    fi
    
    # Cleanup temp file
    rm -f "$temp_input"
    
    return $exit_code
}

# Setup file watching based on available tools
setup_file_watcher() {
    local watch_dir="$1"
    local patterns="$2"
    local exclude_patterns="$3"
    local debounce_time="$4"
    local verbose="$5"
    local watcher_type
    
    watcher_type=$(detect_file_watcher)
    
    case "$watcher_type" in
        "inotify")
            watch_with_inotify "$watch_dir" "$patterns" "$exclude_patterns" "$debounce_time" "$verbose"
            ;;
        "fswatch")
            watch_with_fswatch "$watch_dir" "$patterns" "$exclude_patterns" "$debounce_time" "$verbose"
            ;;
        "polling")
            watch_with_polling "$watch_dir" "$patterns" "$exclude_patterns" "$debounce_time" "$verbose"
            ;;
        *)
            log_error "Unknown file watcher type: $watcher_type"
            return 1
            ;;
    esac
}

# Clean up function
cleanup() {
    log_info "Stopping file watcher..."
    
    # Kill watch process
    if [[ -n "$WATCH_PID" ]]; then
        kill "$WATCH_PID" 2>/dev/null || true
    fi
    
    # Kill debounce process
    if [[ -n "$DEBOUNCE_PID" ]]; then
        kill "$DEBOUNCE_PID" 2>/dev/null || true
    fi
    
    # Clean up temporary files
    for temp_file in "${TEMP_FILES[@]}"; do
        rm -f "$temp_file" 2>/dev/null || true
    done
    
    exit 0
}

# Main execution function
main() {
    local watch_dir=""
    local debounce_time="$DEFAULT_DEBOUNCE_TIME"
    local patterns="$DEFAULT_WATCH_PATTERNS"
    local exclude_patterns="$DEFAULT_EXCLUDE_PATTERNS"
    local concurrency="auto"
    local verbose="false"
    local quiet="false"
    local dry_run="false"
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -d|--debounce)
                debounce_time="$2"
                shift 2
                ;;
            -p|--patterns)
                patterns="$2"
                shift 2
                ;;
            -e|--exclude)
                exclude_patterns="$2"
                shift 2
                ;;
            -c|--concurrency)
                concurrency="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -q|--quiet)
                quiet="true"
                shift
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            -h|--help)
                show_usage
                return 0
                ;;
            --version)
                show_version
                return 0
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                return 1
                ;;
            *)
                if [[ -z "$watch_dir" ]]; then
                    watch_dir="$1"
                else
                    log_error "Multiple directories not supported: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Default to current directory if none specified
    if [[ -z "$watch_dir" ]]; then
        watch_dir="."
    fi
    
    # Validate watch directory
    if [[ ! -d "$watch_dir" ]]; then
        log_error "Directory does not exist: $watch_dir"
        return 1
    fi
    
    # Convert to absolute path
    watch_dir=$(cd "$watch_dir" && pwd)
    
    # Validate debounce time
    if ! [[ "$debounce_time" =~ ^[0-9]+$ ]] || [[ $debounce_time -lt 1 ]]; then
        log_error "Invalid debounce time: $debounce_time"
        return 1
    fi
    
    # Enable verbose logging if requested (but not if quiet)
    if [[ "$verbose" == "true" && "$quiet" != "true" ]]; then
        set -x
    fi
    
    # Suppress normal output if quiet mode
    if [[ "$quiet" == "true" ]]; then
        exec 1>/dev/null
    fi
    
    log_info "Starting $SCRIPT_NAME v$VERSION"
    
    # Check dependencies
    check_dependencies || return 1
    
    # Show configuration
    log_info "Configuration:"
    log_info "  Watch directory: $watch_dir"
    log_info "  Debounce time: ${debounce_time}s"
    log_info "  Watch patterns: $patterns"
    log_info "  Exclude patterns: $exclude_patterns"
    log_info "  File watcher: $(detect_file_watcher)"
    
    if [[ "$dry_run" == "true" ]]; then
        log_info "DRY RUN - Would watch for file changes with above configuration"
        return 0
    fi
    
    # Set up cleanup on exit
    trap cleanup INT TERM EXIT
    
    # Show startup message
    log_info "Watching for file changes..."
    log_info "Press Ctrl+C to stop"
    
    # Start file watching (this runs indefinitely)
    setup_file_watcher "$watch_dir" "$patterns" "$exclude_patterns" "$debounce_time" "$verbose" &
    WATCH_PID=$!
    
    # Wait for watch process (should run forever until interrupted)
    wait "$WATCH_PID"
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi